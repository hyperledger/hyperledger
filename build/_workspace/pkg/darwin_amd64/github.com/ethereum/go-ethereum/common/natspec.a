!<arch>
__.PKGDEF       0           0     0     644     580960    `
go object darwin amd64 go1.5 X:none
build id "d72a362a1088b5d55a048c37e28ab45bc06d2dc0"

$$
package natspec
	import runtime "runtime"
	import bytes "bytes"
	import json "encoding/json"
	import fmt "fmt"
	import strings "strings"
	import common "github.com/ethereum/go-ethereum/common"
	import httpclient "github.com/ethereum/go-ethereum/common/httpclient"
	import crypto "github.com/ethereum/go-ethereum/crypto"
	import registrar "github.com/ethereum/go-ethereum/common/registrar"
	import xeth "github.com/ethereum/go-ethereum/xeth"
	import otto "github.com/robertkrimen/otto"
	type @"github.com/robertkrimen/otto"._propertyMode int
	type @"github.com/robertkrimen/otto"._valueKind int
	type @"github.com/robertkrimen/otto".Object struct { @"github.com/robertkrimen/otto".object *@"github.com/robertkrimen/otto"._object; @"github.com/robertkrimen/otto".value @"github.com/robertkrimen/otto".Value }
	func (@"github.com/robertkrimen/otto".self·3 @"github.com/robertkrimen/otto".Object) Call (@"github.com/robertkrimen/otto".name·4 string, @"github.com/robertkrimen/otto".argumentList·5 ...interface {} "esc:0x9") (? @"github.com/robertkrimen/otto".Value, ? error)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".Object "esc:0x22") Class () (? string) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".object.@"github.com/robertkrimen/otto".class }
	func (@"github.com/robertkrimen/otto".self·3 @"github.com/robertkrimen/otto".Object) Get (@"github.com/robertkrimen/otto".name·4 string) (? @"github.com/robertkrimen/otto".Value, ? error)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".Object) Keys () (? []string)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".Object) Set (@"github.com/robertkrimen/otto".name·3 string, @"github.com/robertkrimen/otto".value·4 interface {}) (? error)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".Object "esc:0x12") Value () (? @"github.com/robertkrimen/otto".Value) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".value }
	type @"github.com/robertkrimen/otto"._resultKind int
	type @"github.com/robertkrimen/otto"._numberKind int
	type @"github.com/robertkrimen/otto"._number struct { @"github.com/robertkrimen/otto".kind @"github.com/robertkrimen/otto"._numberKind; @"github.com/robertkrimen/otto".int64 int64; @"github.com/robertkrimen/otto".float64 float64 }
	type @"github.com/robertkrimen/otto"._reference interface { @"github.com/robertkrimen/otto".delete() (? bool); @"github.com/robertkrimen/otto".getValue() (? @"github.com/robertkrimen/otto".Value); @"github.com/robertkrimen/otto".invalid() (? bool); @"github.com/robertkrimen/otto".putValue(? @"github.com/robertkrimen/otto".Value) (? string) }
	import reflect "reflect" // indirect
	type @"reflect".typeAlg struct { @"reflect".hash func(? @"unsafe".Pointer, ? uintptr) (? uintptr); @"reflect".equal func(? @"unsafe".Pointer, ? @"unsafe".Pointer) (? bool) }
	type @"reflect".method struct { @"reflect".name *string; @"reflect".pkgPath *string; @"reflect".mtyp *@"reflect".rtype; @"reflect".typ *@"reflect".rtype; @"reflect".ifn @"unsafe".Pointer; @"reflect".tfn @"unsafe".Pointer }
	type @"reflect".ChanDir int
	func (@"reflect".d·2 @"reflect".ChanDir) String () (? string)
	type @"reflect".StructTag string
	func (@"reflect".tag·2 @"reflect".StructTag "esc:0x12") Get (@"reflect".key·3 string "esc:0x1") (? string)
	type @"reflect".StructField struct { Name string; PkgPath string; Type @"reflect".Type; Tag @"reflect".StructTag; Offset uintptr; Index []int; Anonymous bool }
	type @"reflect".Kind uint
	func (@"reflect".k·2 @"reflect".Kind) String () (? string)
	type @"reflect".Type interface { Align() (? int); AssignableTo(@"reflect".u @"reflect".Type) (? bool); Bits() (? int); ChanDir() (? @"reflect".ChanDir); Comparable() (? bool); ConvertibleTo(@"reflect".u @"reflect".Type) (? bool); Elem() (? @"reflect".Type); Field(@"reflect".i int) (? @"reflect".StructField); FieldAlign() (? int); FieldByIndex(@"reflect".index []int) (? @"reflect".StructField); FieldByName(@"reflect".name string) (? @"reflect".StructField, ? bool); FieldByNameFunc(@"reflect".match func(? string) (? bool)) (? @"reflect".StructField, ? bool); Implements(@"reflect".u @"reflect".Type) (? bool); In(@"reflect".i int) (? @"reflect".Type); IsVariadic() (? bool); Key() (? @"reflect".Type); Kind() (? @"reflect".Kind); Len() (? int); Method(? int) (? @"reflect".Method); MethodByName(? string) (? @"reflect".Method, ? bool); Name() (? string); NumField() (? int); NumIn() (? int); NumMethod() (? int); NumOut() (? int); Out(@"reflect".i int) (? @"reflect".Type); PkgPath() (? string); Size() (? uintptr); String() (? string); @"reflect".common() (? *@"reflect".rtype); @"reflect".uncommon() (? *@"reflect".uncommonType) }
	type @"reflect".Method struct { Name string; PkgPath string; Type @"reflect".Type; Func @"reflect".Value; Index int }
	type @"reflect".uncommonType struct { @"reflect".name *string; @"reflect".pkgPath *string; @"reflect".methods []@"reflect".method }
	func (@"reflect".t·2 *@"reflect".uncommonType "esc:0x22") Method (@"reflect".i·3 int) (@"reflect".m·1 @"reflect".Method)
	func (@"reflect".t·3 *@"reflect".uncommonType "esc:0x22") MethodByName (@"reflect".name·4 string "esc:0x1") (@"reflect".m·1 @"reflect".Method, @"reflect".ok·2 bool)
	func (@"reflect".t·2 *@"reflect".uncommonType "esc:0x32") Name () (? string) { if @"reflect".t·2 == nil || @"reflect".t·2.@"reflect".name == nil { return "" }; return *@"reflect".t·2.@"reflect".name }
	func (@"reflect".t·2 *@"reflect".uncommonType "esc:0x1") NumMethod () (? int) { if @"reflect".t·2 == nil { return 0x0 }; return len(@"reflect".t·2.@"reflect".methods) }
	func (@"reflect".t·2 *@"reflect".uncommonType "esc:0x32") PkgPath () (? string) { if @"reflect".t·2 == nil || @"reflect".t·2.@"reflect".pkgPath == nil { return "" }; return *@"reflect".t·2.@"reflect".pkgPath }
	func (@"reflect".t·2 *@"reflect".uncommonType "esc:0x12") @"reflect".uncommon () (? *@"reflect".uncommonType) { return @"reflect".t·2 }
	type @"reflect".rtype struct { @"reflect".size uintptr; @"reflect".ptrdata uintptr; @"reflect".hash uint32; _ uint8; @"reflect".align uint8; @"reflect".fieldAlign uint8; @"reflect".kind uint8; @"reflect".alg *@"reflect".typeAlg; @"reflect".gcdata *byte; @"reflect".string *string; @"reflect".? *@"reflect".uncommonType; @"reflect".ptrToThis *@"reflect".rtype; @"reflect".zero @"unsafe".Pointer }
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") Align () (? int) { return int(@"reflect".t·2.@"reflect".align) }
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") AssignableTo (@"reflect".u·3 @"reflect".Type "esc:0x1") (? bool)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") Bits () (? int)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") ChanDir () (? @"reflect".ChanDir)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") Comparable () (? bool) { return @"reflect".t·2.@"reflect".alg != nil && @"reflect".t·2.@"reflect".alg.@"reflect".equal != nil }
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x9") ConvertibleTo (@"reflect".u·3 @"reflect".Type "esc:0x9") (? bool)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x22") Elem () (? @"reflect".Type)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x3a") Field (@"reflect".i·3 int) (? @"reflect".StructField)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") FieldAlign () (? int) { return int(@"reflect".t·2.@"reflect".fieldAlign) }
	func (@"reflect".t·2 *@"reflect".rtype) FieldByIndex (@"reflect".index·3 []int "esc:0x1") (? @"reflect".StructField)
	func (@"reflect".t·3 *@"reflect".rtype) FieldByName (@"reflect".name·4 string "esc:0x1") (? @"reflect".StructField, ? bool)
	func (@"reflect".t·3 *@"reflect".rtype) FieldByNameFunc (@"reflect".match·4 func(? string) (? bool) "esc:0x1") (? @"reflect".StructField, ? bool)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") Implements (@"reflect".u·3 @"reflect".Type) (? bool)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x32") In (@"reflect".i·3 int) (? @"reflect".Type)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") IsVariadic () (? bool)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x22") Key () (? @"reflect".Type)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") Kind () (? @"reflect".Kind) { return @"reflect".Kind(@"reflect".t·2.@"reflect".kind & 0x1f) }
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") Len () (? int)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x32") Method (@"reflect".i·3 int) (@"reflect".m·1 @"reflect".Method)
	func (@"reflect".t·3 *@"reflect".rtype "esc:0x32") MethodByName (@"reflect".name·4 string "esc:0x1") (@"reflect".m·1 @"reflect".Method, @"reflect".ok·2 bool)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x42") Name () (? string) { return @"reflect".t·2.@"reflect".uncommonType.Name() }
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") NumField () (? int)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") NumIn () (? int)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") NumMethod () (? int) { if @"reflect".t·2.Kind() == @"reflect".Kind(0x14) { var @"reflect".tt·3 *@"reflect".interfaceType; ; @"reflect".tt·3 = (*@"reflect".interfaceType)(@"unsafe".Pointer(@"reflect".t·2)); return @"reflect".tt·3.NumMethod() }; return @"reflect".t·2.@"reflect".uncommonType.NumMethod() }
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") NumOut () (? int)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x32") Out (@"reflect".i·3 int) (? @"reflect".Type)
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x42") PkgPath () (? string) { return @"reflect".t·2.@"reflect".uncommonType.PkgPath() }
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") Size () (? uintptr) { return @"reflect".t·2.@"reflect".size }
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x32") String () (? string) { return *@"reflect".t·2.@"reflect".string }
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x12") @"reflect".common () (? *@"reflect".rtype) { return @"reflect".t·2 }
	func (@"reflect".t·2 *@"reflect".rtype "esc:0x1") @"reflect".pointers () (? bool) { return @"reflect".t·2.@"reflect".kind & 0x80 == 0x0 }
	func (@"reflect".t·2 *@"reflect".rtype) @"reflect".ptrTo () (? *@"reflect".rtype)
	type @"reflect".flag uintptr
	func (@"reflect".f·2 @"reflect".flag) @"reflect".kind () (? @"reflect".Kind) { return @"reflect".Kind(@"reflect".f·2 & @"reflect".flag(0x1f)) }
	func (@"reflect".f·1 @"reflect".flag) @"reflect".mustBe (@"reflect".expected·2 @"reflect".Kind)
	func (@"reflect".f·1 @"reflect".flag) @"reflect".mustBeAssignable ()
	func (@"reflect".f·1 @"reflect".flag) @"reflect".mustBeExported ()
	type @"reflect".Value struct { @"reflect".typ *@"reflect".rtype; @"reflect".ptr @"unsafe".Pointer; @"reflect".? @"reflect".flag }
	func (@"reflect".v·2 @"reflect".Value) Addr () (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") Bool () (? bool)
	func (@"reflect".v·2 @"reflect".Value "esc:0x2a") Bytes () (? []byte)
	func (@"reflect".v·2 @"reflect".Value) Call (@"reflect".in·3 []@"reflect".Value "esc:0x9") (? []@"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value) CallSlice (@"reflect".in·3 []@"reflect".Value "esc:0x9") (? []@"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") CanAddr () (? bool) { return @"reflect".v·2.@"reflect".flag & @"reflect".flag(0x80) != @"reflect".flag(0x0) }
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") CanInterface () (? bool)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") CanSet () (? bool) { return @"reflect".v·2.@"reflect".flag & @"reflect".flag(0xa0) == @"reflect".flag(0x80) }
	func (@"reflect".v·2 @"reflect".Value) Cap () (? int)
	func (@"reflect".v·1 @"reflect".Value) Close ()
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") Complex () (? complex128)
	func (@"reflect".v·2 @"reflect".Value) Convert (@"reflect".t·3 @"reflect".Type) (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x12") Elem () (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x12") Field (@"reflect".i·3 int) (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1a") FieldByIndex (@"reflect".index·3 []int "esc:0x1") (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value) FieldByName (@"reflect".name·3 string "esc:0x1") (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value) FieldByNameFunc (@"reflect".match·3 func(? string) (? bool) "esc:0x1") (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") Float () (? float64)
	func (@"reflect".v·2 @"reflect".Value "esc:0x12") Index (@"reflect".i·3 int) (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") Int () (? int64)
	func (@"reflect".v·2 @"reflect".Value) Interface () (@"reflect".i·1 interface {})
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") InterfaceData () (? [2]uintptr)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") IsNil () (? bool)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") IsValid () (? bool) { return @"reflect".v·2.@"reflect".flag != @"reflect".flag(0x0) }
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") Kind () (? @"reflect".Kind) { return @"reflect".v·2.@"reflect".flag.@"reflect".kind() }
	func (@"reflect".v·2 @"reflect".Value) Len () (? int)
	func (@"reflect".v·2 @"reflect".Value "esc:0x2a") MapIndex (@"reflect".key·3 @"reflect".Value) (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x9") MapKeys () (? []@"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x12") Method (@"reflect".i·3 int) (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x12") MethodByName (@"reflect".name·3 string "esc:0x1") (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") NumField () (? int)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") NumMethod () (? int)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") OverflowComplex (@"reflect".x·3 complex128) (? bool)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") OverflowFloat (@"reflect".x·3 float64) (? bool)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") OverflowInt (@"reflect".x·3 int64) (? bool)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") OverflowUint (@"reflect".x·3 uint64) (? bool)
	func (@"reflect".v·2 @"reflect".Value "esc:0x12") Pointer () (? uintptr)
	func (@"reflect".v·3 @"reflect".Value) Recv () (@"reflect".x·1 @"reflect".Value, @"reflect".ok·2 bool)
	func (@"reflect".v·1 @"reflect".Value "esc:0x9") Send (@"reflect".x·2 @"reflect".Value)
	func (@"reflect".v·1 @"reflect".Value) Set (@"reflect".x·2 @"reflect".Value)
	func (@"reflect".v·1 @"reflect".Value "esc:0x1") SetBool (@"reflect".x·2 bool)
	func (@"reflect".v·1 @"reflect".Value "esc:0x9") SetBytes (@"reflect".x·2 []byte)
	func (@"reflect".v·1 @"reflect".Value "esc:0x1") SetCap (@"reflect".n·2 int)
	func (@"reflect".v·1 @"reflect".Value "esc:0x1") SetComplex (@"reflect".x·2 complex128)
	func (@"reflect".v·1 @"reflect".Value "esc:0x1") SetFloat (@"reflect".x·2 float64)
	func (@"reflect".v·1 @"reflect".Value "esc:0x1") SetInt (@"reflect".x·2 int64)
	func (@"reflect".v·1 @"reflect".Value "esc:0x1") SetLen (@"reflect".n·2 int)
	func (@"reflect".v·1 @"reflect".Value) SetMapIndex (@"reflect".key·2 @"reflect".Value, @"reflect".val·3 @"reflect".Value)
	func (@"reflect".v·1 @"reflect".Value "esc:0x1") SetPointer (@"reflect".x·2 @"unsafe".Pointer)
	func (@"reflect".v·1 @"reflect".Value "esc:0x1") SetString (@"reflect".x·2 string)
	func (@"reflect".v·1 @"reflect".Value "esc:0x1") SetUint (@"reflect".x·2 uint64)
	func (@"reflect".v·2 @"reflect".Value) Slice (@"reflect".i·3 int, @"reflect".j·4 int) (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value) Slice3 (@"reflect".i·3 int, @"reflect".j·4 int, @"reflect".k·5 int) (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value) String () (? string)
	func (@"reflect".v·3 @"reflect".Value) TryRecv () (@"reflect".x·1 @"reflect".Value, @"reflect".ok·2 bool)
	func (@"reflect".v·2 @"reflect".Value "esc:0x9") TrySend (@"reflect".x·3 @"reflect".Value) (? bool)
	func (@"reflect".v·2 @"reflect".Value "esc:0x12") Type () (? @"reflect".Type)
	func (@"reflect".v·2 @"reflect".Value "esc:0x1") Uint () (? uint64)
	func (@"reflect".v·2 @"reflect".Value "esc:0x12") UnsafeAddr () (? uintptr)
	func (@"reflect".v·2 @"reflect".Value) @"reflect".assignTo (@"reflect".context·3 string "esc:0x1", @"reflect".dst·4 *@"reflect".rtype, @"reflect".target·5 @"unsafe".Pointer) (? @"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value) @"reflect".call (@"reflect".op·3 string "esc:0x1", @"reflect".in·4 []@"reflect".Value "esc:0x9") (? []@"reflect".Value)
	func (@"reflect".v·2 @"reflect".Value "esc:0x12") @"reflect".pointer () (? @"unsafe".Pointer)
	func (@"reflect".v·3 @"reflect".Value) @"reflect".recv (@"reflect".nb·4 bool) (@"reflect".val·1 @"reflect".Value, @"reflect".ok·2 bool)
	func (@"reflect".v·2 @"reflect".Value "esc:0x2a") @"reflect".runes () (? []rune)
	func (@"reflect".v·2 @"reflect".Value "esc:0x9") @"reflect".send (@"reflect".x·3 @"reflect".Value, @"reflect".nb·4 bool) (@"reflect".selected·1 bool)
	func (@"reflect".v·1 @"reflect".Value "esc:0x9") @"reflect".setRunes (@"reflect".x·2 []rune)
	type @"github.com/robertkrimen/otto".Value struct { @"github.com/robertkrimen/otto".kind @"github.com/robertkrimen/otto"._valueKind; @"github.com/robertkrimen/otto".value interface {} }
	func (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) Call (@"github.com/robertkrimen/otto".this·4 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".argumentList·5 ...interface {} "esc:0x9") (? @"github.com/robertkrimen/otto".Value, ? error)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x22") Class () (? string) { if @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind != @"github.com/robertkrimen/otto"._valueKind(0x5) { return "" }; return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".value.(*@"github.com/robertkrimen/otto"._object).@"github.com/robertkrimen/otto".class }
	func (@"github.com/robertkrimen/otto".self·3 @"github.com/robertkrimen/otto".Value) Export () (? interface {}, ? error)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") IsBoolean () (? bool) { return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind == @"github.com/robertkrimen/otto"._valueKind(0x4) }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") IsDefined () (? bool) { return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind != @"github.com/robertkrimen/otto"._valueKind(0x0) }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") IsFunction () (? bool) { if @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind != @"github.com/robertkrimen/otto"._valueKind(0x5) { return false }; return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".value.(*@"github.com/robertkrimen/otto"._object).@"github.com/robertkrimen/otto".class == "Function" }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value) IsNaN () (? bool)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") IsNull () (? bool) { return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind == @"github.com/robertkrimen/otto"._valueKind(0x1) }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") IsNumber () (? bool) { return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind == @"github.com/robertkrimen/otto"._valueKind(0x2) }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") IsObject () (? bool) { return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind == @"github.com/robertkrimen/otto"._valueKind(0x5) }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") IsPrimitive () (? bool) { return !@"github.com/robertkrimen/otto".value·2.IsObject() }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") IsString () (? bool) { return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind == @"github.com/robertkrimen/otto"._valueKind(0x3) }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") IsUndefined () (? bool) { return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind == @"github.com/robertkrimen/otto"._valueKind(0x0) }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value) Object () (? *@"github.com/robertkrimen/otto".Object)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value) String () (? string)
	func (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) ToBoolean () (? bool, ? error)
	func (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) ToFloat () (? float64, ? error)
	func (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) ToInteger () (? int64, ? error)
	func (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) ToString () (? string, ? error)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x12") @"github.com/robertkrimen/otto"._object () (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value) @"github.com/robertkrimen/otto".bool () (? bool)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value) @"github.com/robertkrimen/otto".call (@"github.com/robertkrimen/otto".rt·3 *@"github.com/robertkrimen/otto"._runtime "esc:0x9", @"github.com/robertkrimen/otto".this·4 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".argumentList·5 ...interface {} "esc:0x9") (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value) @"github.com/robertkrimen/otto".construct (@"github.com/robertkrimen/otto".rt·3 *@"github.com/robertkrimen/otto"._runtime "esc:0x9", @"github.com/robertkrimen/otto".this·4 @"github.com/robertkrimen/otto".Value "esc:0x1", @"github.com/robertkrimen/otto".argumentList·5 ...interface {} "esc:0x9") (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) @"github.com/robertkrimen/otto".constructSafe (@"github.com/robertkrimen/otto".rt·4 *@"github.com/robertkrimen/otto"._runtime "esc:0x9", @"github.com/robertkrimen/otto".this·5 @"github.com/robertkrimen/otto".Value "esc:0x1", @"github.com/robertkrimen/otto".argumentList·6 ...interface {} "esc:0x9") (? @"github.com/robertkrimen/otto".Value, ? error)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".evaluateBreak (@"github.com/robertkrimen/otto".labels·3 []string "esc:0x1") (? @"github.com/robertkrimen/otto"._resultKind)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".evaluateBreakContinue (@"github.com/robertkrimen/otto".labels·3 []string "esc:0x1") (? @"github.com/robertkrimen/otto"._resultKind)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".Value) @"github.com/robertkrimen/otto".export () (? interface {})
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".Value "esc:0x1a") @"github.com/robertkrimen/otto".exportNative () (? interface {})
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value) @"github.com/robertkrimen/otto".float64 () (? float64)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".isArray () (? bool) { if @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind != @"github.com/robertkrimen/otto"._valueKind(0x5) { return false }; return @"github.com/robertkrimen/otto".isArray(@"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".value.(*@"github.com/robertkrimen/otto"._object)) }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".isBooleanObject () (? bool) { if @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind != @"github.com/robertkrimen/otto"._valueKind(0x5) { return false }; return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".value.(*@"github.com/robertkrimen/otto"._object).@"github.com/robertkrimen/otto".class == "Boolean" }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".isCallable () (? bool)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".isDate () (? bool) { if @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind != @"github.com/robertkrimen/otto"._valueKind(0x5) { return false }; return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".value.(*@"github.com/robertkrimen/otto"._object).@"github.com/robertkrimen/otto".class == "Date" }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".isEmpty () (? bool) { return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind == @"github.com/robertkrimen/otto"._valueKind(0x6) }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".isError () (? bool) { if @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind != @"github.com/robertkrimen/otto"._valueKind(0x5) { return false }; return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".value.(*@"github.com/robertkrimen/otto"._object).@"github.com/robertkrimen/otto".class == "Error" }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".isNumberObject () (? bool) { if @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind != @"github.com/robertkrimen/otto"._valueKind(0x5) { return false }; return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".value.(*@"github.com/robertkrimen/otto"._object).@"github.com/robertkrimen/otto".class == "Number" }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".isRegExp () (? bool) { if @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind != @"github.com/robertkrimen/otto"._valueKind(0x5) { return false }; return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".value.(*@"github.com/robertkrimen/otto"._object).@"github.com/robertkrimen/otto".class == "RegExp" }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".isStringObject () (? bool) { if @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".kind != @"github.com/robertkrimen/otto"._valueKind(0x5) { return false }; return @"github.com/robertkrimen/otto".value·2.@"github.com/robertkrimen/otto".value.(*@"github.com/robertkrimen/otto"._object).@"github.com/robertkrimen/otto".class == "String" }
	func (@"github.com/robertkrimen/otto".vl·2 @"github.com/robertkrimen/otto".Value) @"github.com/robertkrimen/otto".number () (@"github.com/robertkrimen/otto".number·1 @"github.com/robertkrimen/otto"._number)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value) @"github.com/robertkrimen/otto".numberValue () (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value "esc:0x12") @"github.com/robertkrimen/otto".reference () (? @"github.com/robertkrimen/otto"._reference)
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value) @"github.com/robertkrimen/otto".resolve () (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".vl·2 @"github.com/robertkrimen/otto".Value "esc:0x1") @"github.com/robertkrimen/otto".safe () (? bool) { return @"github.com/robertkrimen/otto".vl·2.@"github.com/robertkrimen/otto".kind < @"github.com/robertkrimen/otto"._valueKind(0x6) }
	func (@"github.com/robertkrimen/otto".value·2 @"github.com/robertkrimen/otto".Value) @"github.com/robertkrimen/otto".string () (? string)
	func (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) @"github.com/robertkrimen/otto".toReflectValue (@"github.com/robertkrimen/otto".kind·4 @"reflect".Kind) (? @"reflect".Value, ? error)
	type @"github.com/robertkrimen/otto"._property struct { @"github.com/robertkrimen/otto".value interface {}; @"github.com/robertkrimen/otto".mode @"github.com/robertkrimen/otto"._propertyMode }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".configurable () (? bool) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".mode & @"github.com/robertkrimen/otto"._propertyMode(0x7) == @"github.com/robertkrimen/otto"._propertyMode(0x1) }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".configureOff () { @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".mode &= @"github.com/robertkrimen/otto"._propertyMode(-0x8) }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".configureOn () { @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".mode = @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".mode & @"github.com/robertkrimen/otto"._propertyMode(-0x8) | @"github.com/robertkrimen/otto"._propertyMode(0x1) }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".configureSet () (? bool) { return @"github.com/robertkrimen/otto"._propertyMode(0x0) == @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".mode & @"github.com/robertkrimen/otto"._propertyMode(0x7) & @"github.com/robertkrimen/otto"._propertyMode(0x92) }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property) @"github.com/robertkrimen/otto".copy () (? *@"github.com/robertkrimen/otto"._property) { var @"github.com/robertkrimen/otto".property·3 @"github.com/robertkrimen/otto"._property; ; @"github.com/robertkrimen/otto".property·3 = @"github.com/robertkrimen/otto".self·2; return &@"github.com/robertkrimen/otto".property·3 }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".enumerable () (? bool) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".mode & @"github.com/robertkrimen/otto"._propertyMode(0x38) == @"github.com/robertkrimen/otto"._propertyMode(0x8) }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".enumerateOff () { @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".mode &= @"github.com/robertkrimen/otto"._propertyMode(-0x39) }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".enumerateOn () { @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".mode = @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".mode & @"github.com/robertkrimen/otto"._propertyMode(-0x39) | @"github.com/robertkrimen/otto"._propertyMode(0x8) }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".enumerateSet () (? bool) { return @"github.com/robertkrimen/otto"._propertyMode(0x0) == @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".mode & @"github.com/robertkrimen/otto"._propertyMode(0x38) & @"github.com/robertkrimen/otto"._propertyMode(0x92) }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property) @"github.com/robertkrimen/otto".get (@"github.com/robertkrimen/otto".this·3 *@"github.com/robertkrimen/otto"._object) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".isAccessorDescriptor () (? bool) { var @"github.com/robertkrimen/otto".setGet·3 @"github.com/robertkrimen/otto"._propertyGetSet; ; var @"github.com/robertkrimen/otto".test·4 bool; ; @"github.com/robertkrimen/otto".setGet·3, @"github.com/robertkrimen/otto".test·4 = @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".value.(@"github.com/robertkrimen/otto"._propertyGetSet); return @"github.com/robertkrimen/otto".test·4 && (@"github.com/robertkrimen/otto".setGet·3[0x0] != nil || @"github.com/robertkrimen/otto".setGet·3[0x1] != nil) }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".isDataDescriptor () (? bool) { if @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".writeSet() { return true }; var @"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value; ; var @"github.com/robertkrimen/otto".valid·4 bool; ; @"github.com/robertkrimen/otto".value·3, @"github.com/robertkrimen/otto".valid·4 = @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".value.(@"github.com/robertkrimen/otto".Value); return @"github.com/robertkrimen/otto".valid·4 && !@"github.com/robertkrimen/otto".value·3.@"github.com/robertkrimen/otto".isEmpty() }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".isEmpty () (? bool)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".isGenericDescriptor () (? bool) { return !(@"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".isDataDescriptor() || @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".isAccessorDescriptor()) }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".writable () (? bool) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".mode & @"github.com/robertkrimen/otto"._propertyMode(0x1c0) == @"github.com/robertkrimen/otto"._propertyMode(0x40) }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".writeClear () { @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".mode = @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".mode & @"github.com/robertkrimen/otto"._propertyMode(-0x1c1) | @"github.com/robertkrimen/otto"._propertyMode(0x80) }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".writeOff () { @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".mode &= @"github.com/robertkrimen/otto"._propertyMode(-0x1c1) }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".writeOn () { @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".mode = @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".mode & @"github.com/robertkrimen/otto"._propertyMode(-0x1c1) | @"github.com/robertkrimen/otto"._propertyMode(0x40) }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto"._property "esc:0x1") @"github.com/robertkrimen/otto".writeSet () (? bool) { return @"github.com/robertkrimen/otto"._propertyMode(0x0) == @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".mode & @"github.com/robertkrimen/otto"._propertyMode(0x1c0) & @"github.com/robertkrimen/otto"._propertyMode(0x92) }
	type @"github.com/robertkrimen/otto"._at int
	type @"github.com/robertkrimen/otto"._stash interface { @"github.com/robertkrimen/otto".clone(@"github.com/robertkrimen/otto".clone *@"github.com/robertkrimen/otto"._clone) (? @"github.com/robertkrimen/otto"._stash); @"github.com/robertkrimen/otto".createBinding(? string, ? bool, ? @"github.com/robertkrimen/otto".Value); @"github.com/robertkrimen/otto".deleteBinding(? string) (? bool); @"github.com/robertkrimen/otto".getBinding(? string, ? bool) (? @"github.com/robertkrimen/otto".Value); @"github.com/robertkrimen/otto".hasBinding(? string) (? bool); @"github.com/robertkrimen/otto".newReference(? string, ? bool, ? @"github.com/robertkrimen/otto"._at) (? @"github.com/robertkrimen/otto"._reference); @"github.com/robertkrimen/otto".outer() (? @"github.com/robertkrimen/otto"._stash); @"github.com/robertkrimen/otto".runtime() (? *@"github.com/robertkrimen/otto"._runtime); @"github.com/robertkrimen/otto".setBinding(? string, ? @"github.com/robertkrimen/otto".Value, ? bool); @"github.com/robertkrimen/otto".setValue(? string, ? @"github.com/robertkrimen/otto".Value, ? bool) }
	type @"github.com/robertkrimen/otto"._objectStash struct { @"github.com/robertkrimen/otto"._runtime *@"github.com/robertkrimen/otto"._runtime; @"github.com/robertkrimen/otto"._outer @"github.com/robertkrimen/otto"._stash; @"github.com/robertkrimen/otto".object *@"github.com/robertkrimen/otto"._object }
	func (@"github.com/robertkrimen/otto".in·2 *@"github.com/robertkrimen/otto"._objectStash) @"github.com/robertkrimen/otto".clone (@"github.com/robertkrimen/otto".clone·3 *@"github.com/robertkrimen/otto"._clone) (? @"github.com/robertkrimen/otto"._stash)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._objectStash "esc:0x9") @"github.com/robertkrimen/otto".createBinding (@"github.com/robertkrimen/otto".name·2 string, @"github.com/robertkrimen/otto".deletable·3 bool, @"github.com/robertkrimen/otto".value·4 @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._objectStash "esc:0x9") @"github.com/robertkrimen/otto".deleteBinding (@"github.com/robertkrimen/otto".name·3 string) (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._objectStash "esc:0x9") @"github.com/robertkrimen/otto".getBinding (@"github.com/robertkrimen/otto".name·3 string, @"github.com/robertkrimen/otto".throw·4 bool) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._objectStash "esc:0x9") @"github.com/robertkrimen/otto".hasBinding (@"github.com/robertkrimen/otto".name·3 string) (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._objectStash "esc:0xa") @"github.com/robertkrimen/otto".newReference (@"github.com/robertkrimen/otto".name·3 string, @"github.com/robertkrimen/otto".strict·4 bool, @"github.com/robertkrimen/otto".at·5 @"github.com/robertkrimen/otto"._at) (? @"github.com/robertkrimen/otto"._reference) { return @"github.com/robertkrimen/otto".newPropertyReference(@"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto"._runtime, @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".object, @"github.com/robertkrimen/otto".name·3, @"github.com/robertkrimen/otto".strict·4, @"github.com/robertkrimen/otto".at·5) }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._objectStash "esc:0x22") @"github.com/robertkrimen/otto".outer () (? @"github.com/robertkrimen/otto"._stash) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto"._outer }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._objectStash "esc:0x22") @"github.com/robertkrimen/otto".runtime () (? *@"github.com/robertkrimen/otto"._runtime) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto"._runtime }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._objectStash "esc:0x9") @"github.com/robertkrimen/otto".setBinding (@"github.com/robertkrimen/otto".name·2 string, @"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".strict·4 bool)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._objectStash "esc:0x9") @"github.com/robertkrimen/otto".setValue (@"github.com/robertkrimen/otto".name·2 string, @"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".throw·4 bool)
	type @"github.com/robertkrimen/otto"._dclProperty struct { @"github.com/robertkrimen/otto".value @"github.com/robertkrimen/otto".Value; @"github.com/robertkrimen/otto".mutable bool; @"github.com/robertkrimen/otto".deletable bool; @"github.com/robertkrimen/otto".readable bool }
	type @"github.com/robertkrimen/otto"._dclStash struct { @"github.com/robertkrimen/otto"._runtime *@"github.com/robertkrimen/otto"._runtime; @"github.com/robertkrimen/otto"._outer @"github.com/robertkrimen/otto"._stash; @"github.com/robertkrimen/otto".property map[string]@"github.com/robertkrimen/otto"._dclProperty }
	func (@"github.com/robertkrimen/otto".in·2 *@"github.com/robertkrimen/otto"._dclStash) @"github.com/robertkrimen/otto".clone (@"github.com/robertkrimen/otto".clone·3 *@"github.com/robertkrimen/otto"._clone) (? @"github.com/robertkrimen/otto"._stash)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._dclStash "esc:0x1") @"github.com/robertkrimen/otto".createBinding (@"github.com/robertkrimen/otto".name·2 string, @"github.com/robertkrimen/otto".deletable·3 bool, @"github.com/robertkrimen/otto".value·4 @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._dclStash "esc:0x1") @"github.com/robertkrimen/otto".deleteBinding (@"github.com/robertkrimen/otto".name·3 string "esc:0x1") (? bool) { var @"github.com/robertkrimen/otto".property·4 @"github.com/robertkrimen/otto"._dclProperty; ; var @"github.com/robertkrimen/otto".exists·5 bool; ; @"github.com/robertkrimen/otto".property·4, @"github.com/robertkrimen/otto".exists·5 = @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".property[@"github.com/robertkrimen/otto".name·3]; if !@"github.com/robertkrimen/otto".exists·5 { return true }; if !@"github.com/robertkrimen/otto".property·4.@"github.com/robertkrimen/otto".deletable { return false }; delete(@"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".property, @"github.com/robertkrimen/otto".name·3); return true }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._dclStash "esc:0x9") @"github.com/robertkrimen/otto".getBinding (@"github.com/robertkrimen/otto".name·3 string, @"github.com/robertkrimen/otto".throw·4 bool) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._dclStash "esc:0x1") @"github.com/robertkrimen/otto".hasBinding (@"github.com/robertkrimen/otto".name·3 string "esc:0x1") (? bool) { var @"github.com/robertkrimen/otto".exists·4 bool; ; _, @"github.com/robertkrimen/otto".exists·4 = @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".property[@"github.com/robertkrimen/otto".name·3]; return @"github.com/robertkrimen/otto".exists·4 }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._dclStash) @"github.com/robertkrimen/otto".newReference (@"github.com/robertkrimen/otto".name·3 string, @"github.com/robertkrimen/otto".strict·4 bool, _ @"github.com/robertkrimen/otto"._at) (? @"github.com/robertkrimen/otto"._reference) { return (&@"github.com/robertkrimen/otto"._stashReference{ @"github.com/robertkrimen/otto".name:@"github.com/robertkrimen/otto".name·3, @"github.com/robertkrimen/otto".base:@"github.com/robertkrimen/otto".self·2 }) }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._dclStash "esc:0x22") @"github.com/robertkrimen/otto".outer () (? @"github.com/robertkrimen/otto"._stash) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto"._outer }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._dclStash "esc:0x22") @"github.com/robertkrimen/otto".runtime () (? *@"github.com/robertkrimen/otto"._runtime) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto"._runtime }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._dclStash "esc:0x9") @"github.com/robertkrimen/otto".setBinding (@"github.com/robertkrimen/otto".name·2 string, @"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".strict·4 bool)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._dclStash "esc:0x9") @"github.com/robertkrimen/otto".setValue (@"github.com/robertkrimen/otto".name·2 string, @"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".throw·4 bool)
	type @"github.com/robertkrimen/otto"._fnStash struct { @"github.com/robertkrimen/otto".? @"github.com/robertkrimen/otto"._dclStash; @"github.com/robertkrimen/otto".arguments *@"github.com/robertkrimen/otto"._object; @"github.com/robertkrimen/otto".indexOfArgumentName map[string]string }
	func (@"github.com/robertkrimen/otto".in·2 *@"github.com/robertkrimen/otto"._fnStash) @"github.com/robertkrimen/otto".clone (@"github.com/robertkrimen/otto".clone·3 *@"github.com/robertkrimen/otto"._clone) (? @"github.com/robertkrimen/otto"._stash)
	type @"github.com/robertkrimen/otto"._clone struct { @"github.com/robertkrimen/otto".runtime *@"github.com/robertkrimen/otto"._runtime; @"github.com/robertkrimen/otto"._object map[*@"github.com/robertkrimen/otto"._object]*@"github.com/robertkrimen/otto"._object; @"github.com/robertkrimen/otto"._objectStash map[*@"github.com/robertkrimen/otto"._objectStash]*@"github.com/robertkrimen/otto"._objectStash; @"github.com/robertkrimen/otto"._dclStash map[*@"github.com/robertkrimen/otto"._dclStash]*@"github.com/robertkrimen/otto"._dclStash; @"github.com/robertkrimen/otto"._fnStash map[*@"github.com/robertkrimen/otto"._fnStash]*@"github.com/robertkrimen/otto"._fnStash }
	func (@"github.com/robertkrimen/otto".clone·2 *@"github.com/robertkrimen/otto"._clone) @"github.com/robertkrimen/otto".dclProperty (@"github.com/robertkrimen/otto".in·3 @"github.com/robertkrimen/otto"._dclProperty) (? @"github.com/robertkrimen/otto"._dclProperty)
	func (@"github.com/robertkrimen/otto".clone·3 *@"github.com/robertkrimen/otto"._clone "esc:0x1") @"github.com/robertkrimen/otto".dclStash (@"github.com/robertkrimen/otto".in·4 *@"github.com/robertkrimen/otto"._dclStash) (? *@"github.com/robertkrimen/otto"._dclStash, ? bool) { var @"github.com/robertkrimen/otto".out·5 *@"github.com/robertkrimen/otto"._dclStash; ; var @"github.com/robertkrimen/otto".exists·6 bool; ; @"github.com/robertkrimen/otto".out·5, @"github.com/robertkrimen/otto".exists·6 = @"github.com/robertkrimen/otto".clone·3.@"github.com/robertkrimen/otto"._dclStash[@"github.com/robertkrimen/otto".in·4]; if @"github.com/robertkrimen/otto".exists·6 { return @"github.com/robertkrimen/otto".out·5, true }; var @"github.com/robertkrimen/otto".out·7 *@"github.com/robertkrimen/otto"._dclStash; ; @"github.com/robertkrimen/otto".out·7 = (&@"github.com/robertkrimen/otto"._dclStash{  }); @"github.com/robertkrimen/otto".clone·3.@"github.com/robertkrimen/otto"._dclStash[@"github.com/robertkrimen/otto".in·4] = @"github.com/robertkrimen/otto".out·7; return @"github.com/robertkrimen/otto".out·7, false }
	func (@"github.com/robertkrimen/otto".clone·3 *@"github.com/robertkrimen/otto"._clone "esc:0x1") @"github.com/robertkrimen/otto".fnStash (@"github.com/robertkrimen/otto".in·4 *@"github.com/robertkrimen/otto"._fnStash) (? *@"github.com/robertkrimen/otto"._fnStash, ? bool) { var @"github.com/robertkrimen/otto".out·5 *@"github.com/robertkrimen/otto"._fnStash; ; var @"github.com/robertkrimen/otto".exists·6 bool; ; @"github.com/robertkrimen/otto".out·5, @"github.com/robertkrimen/otto".exists·6 = @"github.com/robertkrimen/otto".clone·3.@"github.com/robertkrimen/otto"._fnStash[@"github.com/robertkrimen/otto".in·4]; if @"github.com/robertkrimen/otto".exists·6 { return @"github.com/robertkrimen/otto".out·5, true }; var @"github.com/robertkrimen/otto".out·7 *@"github.com/robertkrimen/otto"._fnStash; ; @"github.com/robertkrimen/otto".out·7 = (&@"github.com/robertkrimen/otto"._fnStash{  }); @"github.com/robertkrimen/otto".clone·3.@"github.com/robertkrimen/otto"._fnStash[@"github.com/robertkrimen/otto".in·4] = @"github.com/robertkrimen/otto".out·7; return @"github.com/robertkrimen/otto".out·7, false }
	func (@"github.com/robertkrimen/otto".clone·2 *@"github.com/robertkrimen/otto"._clone) @"github.com/robertkrimen/otto".object (@"github.com/robertkrimen/otto".in·3 *@"github.com/robertkrimen/otto"._object) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".clone·3 *@"github.com/robertkrimen/otto"._clone "esc:0x1") @"github.com/robertkrimen/otto".objectStash (@"github.com/robertkrimen/otto".in·4 *@"github.com/robertkrimen/otto"._objectStash) (? *@"github.com/robertkrimen/otto"._objectStash, ? bool) { var @"github.com/robertkrimen/otto".out·5 *@"github.com/robertkrimen/otto"._objectStash; ; var @"github.com/robertkrimen/otto".exists·6 bool; ; @"github.com/robertkrimen/otto".out·5, @"github.com/robertkrimen/otto".exists·6 = @"github.com/robertkrimen/otto".clone·3.@"github.com/robertkrimen/otto"._objectStash[@"github.com/robertkrimen/otto".in·4]; if @"github.com/robertkrimen/otto".exists·6 { return @"github.com/robertkrimen/otto".out·5, true }; var @"github.com/robertkrimen/otto".out·7 *@"github.com/robertkrimen/otto"._objectStash; ; @"github.com/robertkrimen/otto".out·7 = (&@"github.com/robertkrimen/otto"._objectStash{  }); @"github.com/robertkrimen/otto".clone·3.@"github.com/robertkrimen/otto"._objectStash[@"github.com/robertkrimen/otto".in·4] = @"github.com/robertkrimen/otto".out·7; return @"github.com/robertkrimen/otto".out·7, false }
	func (@"github.com/robertkrimen/otto".clone·2 *@"github.com/robertkrimen/otto"._clone) @"github.com/robertkrimen/otto".property (@"github.com/robertkrimen/otto".in·3 @"github.com/robertkrimen/otto"._property) (? @"github.com/robertkrimen/otto"._property)
	func (@"github.com/robertkrimen/otto".clone·2 *@"github.com/robertkrimen/otto"._clone) @"github.com/robertkrimen/otto".stash (@"github.com/robertkrimen/otto".in·3 @"github.com/robertkrimen/otto"._stash) (? @"github.com/robertkrimen/otto"._stash)
	func (@"github.com/robertkrimen/otto".clone·2 *@"github.com/robertkrimen/otto"._clone) @"github.com/robertkrimen/otto".value (@"github.com/robertkrimen/otto".in·3 @"github.com/robertkrimen/otto".Value) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".clone·2 *@"github.com/robertkrimen/otto"._clone) @"github.com/robertkrimen/otto".valueArray (@"github.com/robertkrimen/otto".in·3 []@"github.com/robertkrimen/otto".Value "esc:0x9") (? []@"github.com/robertkrimen/otto".Value)
	type @"encoding/json".Marshaler interface { MarshalJSON() (? []byte, ? error) }
	type @"github.com/robertkrimen/otto"._objectClass struct { @"github.com/robertkrimen/otto".getOwnProperty func(? *@"github.com/robertkrimen/otto"._object, ? string) (? *@"github.com/robertkrimen/otto"._property); @"github.com/robertkrimen/otto".getProperty func(? *@"github.com/robertkrimen/otto"._object, ? string) (? *@"github.com/robertkrimen/otto"._property); @"github.com/robertkrimen/otto".get func(? *@"github.com/robertkrimen/otto"._object, ? string) (? @"github.com/robertkrimen/otto".Value); @"github.com/robertkrimen/otto".canPut func(? *@"github.com/robertkrimen/otto"._object, ? string) (? bool); @"github.com/robertkrimen/otto".put func(? *@"github.com/robertkrimen/otto"._object, ? string, ? @"github.com/robertkrimen/otto".Value, ? bool); @"github.com/robertkrimen/otto".hasProperty func(? *@"github.com/robertkrimen/otto"._object, ? string) (? bool); @"github.com/robertkrimen/otto".hasOwnProperty func(? *@"github.com/robertkrimen/otto"._object, ? string) (? bool); @"github.com/robertkrimen/otto".defineOwnProperty func(? *@"github.com/robertkrimen/otto"._object, ? string, ? @"github.com/robertkrimen/otto"._property, ? bool) (? bool); @"github.com/robertkrimen/otto".delete func(? *@"github.com/robertkrimen/otto"._object, ? string, ? bool) (? bool); @"github.com/robertkrimen/otto".enumerate func(? *@"github.com/robertkrimen/otto"._object, ? bool, ? func(? string) (? bool)); @"github.com/robertkrimen/otto".clone func(? *@"github.com/robertkrimen/otto"._object, ? *@"github.com/robertkrimen/otto"._object, ? *@"github.com/robertkrimen/otto"._clone) (? *@"github.com/robertkrimen/otto"._object); @"github.com/robertkrimen/otto".marshalJSON func(? *@"github.com/robertkrimen/otto"._object) (? @"encoding/json".Marshaler) }
	type @"github.com/robertkrimen/otto"._defaultValueHint int
	import file "github.com/robertkrimen/otto/file" // indirect
	type @"github.com/robertkrimen/otto/file".File struct { @"github.com/robertkrimen/otto/file".name string; @"github.com/robertkrimen/otto/file".src string; @"github.com/robertkrimen/otto/file".base int }
	func (@"github.com/robertkrimen/otto/file".fl·2 *@"github.com/robertkrimen/otto/file".File "esc:0x1") Base () (? int) { return @"github.com/robertkrimen/otto/file".fl·2.@"github.com/robertkrimen/otto/file".base }
	func (@"github.com/robertkrimen/otto/file".fl·2 *@"github.com/robertkrimen/otto/file".File "esc:0x22") Name () (? string) { return @"github.com/robertkrimen/otto/file".fl·2.@"github.com/robertkrimen/otto/file".name }
	func (@"github.com/robertkrimen/otto/file".fl·2 *@"github.com/robertkrimen/otto/file".File "esc:0x22") Source () (? string) { return @"github.com/robertkrimen/otto/file".fl·2.@"github.com/robertkrimen/otto/file".src }
	type @"github.com/robertkrimen/otto"._frame struct { @"github.com/robertkrimen/otto".file *@"github.com/robertkrimen/otto/file".File; @"github.com/robertkrimen/otto".offset int; @"github.com/robertkrimen/otto".callee string }
	func (@"github.com/robertkrimen/otto".fr·2 @"github.com/robertkrimen/otto"._frame) @"github.com/robertkrimen/otto".location () (? string)
	import time "time" // indirect
	type @"time".zone struct { @"time".name string; @"time".offset int; @"time".isDST bool }
	type @"time".zoneTrans struct { @"time".when int64; @"time".index uint8; @"time".isstd bool; @"time".isutc bool }
	type @"time".Location struct { @"time".name string; @"time".zone []@"time".zone; @"time".tx []@"time".zoneTrans; @"time".cacheStart int64; @"time".cacheEnd int64; @"time".cacheZone *@"time".zone }
	func (@"time".l·2 *@"time".Location "esc:0x22") String () (? string)
	func (@"time".l·2 *@"time".Location "esc:0x1") @"time".firstZoneUsed () (? bool)
	func (@"time".l·2 *@"time".Location "esc:0x12") @"time".get () (? *@"time".Location)
	func (@"time".l·6 *@"time".Location "esc:0x32") @"time".lookup (@"time".sec·7 int64) (@"time".name·1 string, @"time".offset·2 int, @"time".isDST·3 bool, @"time".start·4 int64, @"time".end·5 int64)
	func (@"time".l·2 *@"time".Location "esc:0x1") @"time".lookupFirstZone () (? int)
	func (@"time".l·4 *@"time".Location "esc:0x1") @"time".lookupName (@"time".name·5 string "esc:0x1", @"time".unix·6 int64) (@"time".offset·1 int, @"time".isDST·2 bool, @"time".ok·3 bool)
	type @"time".Duration int64
	func (@"time".d·2 @"time".Duration) Hours () (? float64) { var @"time".hour·3 @"time".Duration; ; @"time".hour·3 = @"time".d·2 / @"time".Duration(0x34630b8a000); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0x34630b8a000); return float64(@"time".hour·3) + float64(@"time".nsec·4) * 8190022623310637111963488201822504381538623676021880892417778544696899264837610290203272971060556344039023584360473938041055625214280336402169897364226048p-553 }
	func (@"time".d·2 @"time".Duration) Minutes () (? float64) { var @"time".min·3 @"time".Duration; ; @"time".min·3 = @"time".d·2 / @"time".Duration(0xdf8475800); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0xdf8475800); return float64(@"time".min·3) + float64(@"time".nsec·4) * 7678146209353722106395056769533233877065564876941352542109479049699919628723768656821910653339403201031675627614471533358284117434246264392176261853609984p-547 }
	func (@"time".d·2 @"time".Duration) Nanoseconds () (? int64) { return int64(@"time".d·2) }
	func (@"time".d·2 @"time".Duration) Seconds () (? float64) { var @"time".sec·3 @"time".Duration; ; @"time".sec·3 = @"time".d·2 / @"time".Duration(0x3b9aca00); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0x3b9aca00); return float64(@"time".sec·3) + float64(@"time".nsec·4) * 7198262071269114660816079141112770740375861891461678802759824945047098083990024106014198994535558872472104883612039846078596891298747423852523262413111296p-541 }
	func (@"time".d·2 @"time".Duration) String () (? string)
	type @"time".Month int
	func (@"time".m·2 @"time".Month) String () (? string) { return @"time".months[@"time".m·2 - @"time".Month(0x1)] }
	type @"time".Weekday int
	func (@"time".d·2 @"time".Weekday) String () (? string) { return @"time".days[@"time".d·2] }
	type @"time".Time struct { @"time".sec int64; @"time".nsec int32; @"time".loc *@"time".Location }
	func (@"time".t·2 @"time".Time "esc:0x12") Add (@"time".d·3 @"time".Duration) (? @"time".Time) { @"time".t·2.@"time".sec += int64(@"time".d·3 / @"time".Duration(0x3b9aca00)); var @"time".nsec·4 int32; ; @"time".nsec·4 = int32(@"time".t·2.@"time".nsec) + int32(@"time".d·3 % @"time".Duration(0x3b9aca00)); if @"time".nsec·4 >= 0x3b9aca00 { @"time".t·2.@"time".sec++; @"time".nsec·4 -= 0x3b9aca00 } else { if @"time".nsec·4 < 0x0 { @"time".t·2.@"time".sec--; @"time".nsec·4 += 0x3b9aca00 } }; @"time".t·2.@"time".nsec = @"time".nsec·4; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x12") AddDate (@"time".years·3 int, @"time".months·4 int, @"time".days·5 int) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") After (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec > @"time".u·3.@"time".sec || @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec > @"time".u·3.@"time".nsec }
	func (@"time".t·2 @"time".Time "esc:0x9") AppendFormat (@"time".b·3 []byte "esc:0x1a", @"time".layout·4 string "esc:0x9") (? []byte)
	func (@"time".t·2 @"time".Time "esc:0x1") Before (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec < @"time".u·3.@"time".sec || @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec < @"time".u·3.@"time".nsec }
	func (@"time".t·4 @"time".Time "esc:0x1") Clock () (@"time".hour·1 int, @"time".min·2 int, @"time".sec·3 int)
	func (@"time".t·4 @"time".Time "esc:0x1") Date () (@"time".year·1 int, @"time".month·2 @"time".Month, @"time".day·3 int)
	func (@"time".t·2 @"time".Time "esc:0x1") Day () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") Equal (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec == @"time".u·3.@"time".nsec }
	func (@"time".t·2 @"time".Time "esc:0x9") Format (@"time".layout·3 string "esc:0x9") (? string)
	func (@"time".t·2 *@"time".Time "esc:0x1") GobDecode (@"time".data·3 []byte "esc:0x1") (? error)
	func (@"time".t·3 @"time".Time "esc:0x1") GobEncode () (? []byte, ? error)
	func (@"time".t·2 @"time".Time "esc:0x1") Hour () (? int)
	func (@"time".t·3 @"time".Time "esc:0x1") ISOWeek () (@"time".year·1 int, @"time".week·2 int)
	func (@"time".t·2 @"time".Time "esc:0x12") In (@"time".loc·3 *@"time".Location "esc:0x12") (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") IsZero () (? bool) { return @"time".t·2.@"time".sec == 0x0 && @"time".t·2.@"time".nsec == 0x0 }
	func (@"time".t·2 @"time".Time "esc:0x12") Local () (? @"time".Time) { @"time".t·2.@"time".loc = @"time".Local; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x12") Location () (? *@"time".Location) { var @"time".l·3 *@"time".Location; ; @"time".l·3 = @"time".t·2.@"time".loc; if @"time".l·3 == nil { @"time".l·3 = @"time".UTC }; return @"time".l·3 }
	func (@"time".t·3 @"time".Time "esc:0x1") MarshalBinary () (? []byte, ? error)
	func (@"time".t·3 @"time".Time "esc:0x9") MarshalJSON () (? []byte, ? error)
	func (@"time".t·3 @"time".Time "esc:0x9") MarshalText () (? []byte, ? error)
	func (@"time".t·2 @"time".Time "esc:0x1") Minute () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") Month () (? @"time".Month)
	func (@"time".t·2 @"time".Time "esc:0x1") Nanosecond () (? int) { return int(@"time".t·2.@"time".nsec) }
	func (@"time".t·2 @"time".Time "esc:0x12") Round (@"time".d·3 @"time".Duration) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") Second () (? int)
	func (@"time".t·2 @"time".Time "esc:0x9") String () (? string)
	func (@"time".t·2 @"time".Time "esc:0x1") Sub (@"time".u·3 @"time".Time "esc:0x1") (? @"time".Duration)
	func (@"time".t·2 @"time".Time "esc:0x12") Truncate (@"time".d·3 @"time".Duration) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x12") UTC () (? @"time".Time) { @"time".t·2.@"time".loc = @"time".UTC; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x1") Unix () (? int64) { return @"time".t·2.@"time".sec + -0xe7791f700 }
	func (@"time".t·2 @"time".Time "esc:0x1") UnixNano () (? int64) { return (@"time".t·2.@"time".sec + -0xe7791f700) * 0x3b9aca00 + int64(@"time".t·2.@"time".nsec) }
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalBinary (@"time".data·3 []byte "esc:0x1") (? error)
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalJSON (@"time".data·3 []byte "esc:0x1") (@"time".err·1 error)
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalText (@"time".data·3 []byte "esc:0x1") (@"time".err·1 error)
	func (@"time".t·2 @"time".Time "esc:0x1") Weekday () (? @"time".Weekday)
	func (@"time".t·2 @"time".Time "esc:0x1") Year () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") YearDay () (? int)
	func (@"time".t·3 @"time".Time "esc:0x32") Zone () (@"time".name·1 string, @"time".offset·2 int)
	func (@"time".t·2 @"time".Time "esc:0x1") @"time".abs () (? uint64)
	func (@"time".t·5 @"time".Time "esc:0x1") @"time".date (@"time".full·6 bool) (@"time".year·1 int, @"time".month·2 @"time".Month, @"time".day·3 int, @"time".yday·4 int)
	func (@"time".t·4 @"time".Time "esc:0x32") @"time".locabs () (@"time".name·1 string, @"time".offset·2 int, @"time".abs·3 uint64)
	type @"github.com/robertkrimen/otto"._dateObject struct { @"github.com/robertkrimen/otto".time @"time".Time; @"github.com/robertkrimen/otto".epoch int64; @"github.com/robertkrimen/otto".value @"github.com/robertkrimen/otto".Value; @"github.com/robertkrimen/otto".isNaN bool }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._dateObject "esc:0x1") Epoch () (? int64) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".epoch }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._dateObject "esc:0x1") Set (@"github.com/robertkrimen/otto".epoch·2 float64)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._dateObject "esc:0x1") SetNaN () { @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".time = (@"time".Time{  }); @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".epoch = -0x1; @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".value = @"github.com/robertkrimen/otto".NaNValue(); @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".isNaN = true }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._dateObject "esc:0x1") SetTime (@"github.com/robertkrimen/otto".time·2 @"time".Time "esc:0x1")
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._dateObject "esc:0x22") Time () (? @"time".Time) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".time }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._dateObject "esc:0x22") Value () (? @"github.com/robertkrimen/otto".Value) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".value }
	import regexp "regexp" // indirect
	import syntax "regexp/syntax" // indirect
	type @"regexp/syntax".InstOp uint8
	func (@"regexp/syntax".i·2 @"regexp/syntax".InstOp) String () (? string) { if uint(@"regexp/syntax".i·2) >= uint(len(@"regexp/syntax".instOpNames)) { return "" }; return @"regexp/syntax".instOpNames[@"regexp/syntax".i·2] }
	type @"regexp/syntax".Inst struct { Op @"regexp/syntax".InstOp; Out uint32; Arg uint32; Rune []rune }
	func (@"regexp/syntax".i·2 *@"regexp/syntax".Inst "esc:0x1") MatchEmptyWidth (@"regexp/syntax".before·3 rune, @"regexp/syntax".after·4 rune) (? bool)
	func (@"regexp/syntax".i·2 *@"regexp/syntax".Inst "esc:0x1") MatchRune (@"regexp/syntax".r·3 rune) (? bool)
	func (@"regexp/syntax".i·2 *@"regexp/syntax".Inst "esc:0x1") MatchRunePos (@"regexp/syntax".r·3 rune) (? int)
	func (@"regexp/syntax".i·2 *@"regexp/syntax".Inst "esc:0x1") String () (? string)
	func (@"regexp/syntax".i·2 *@"regexp/syntax".Inst "esc:0x1") @"regexp/syntax".op () (? @"regexp/syntax".InstOp)
	type @"regexp/syntax".EmptyOp uint8
	type @"regexp/syntax".Prog struct { Inst []@"regexp/syntax".Inst; Start int; NumCap int }
	func (@"regexp/syntax".p·3 *@"regexp/syntax".Prog "esc:0x1") Prefix () (@"regexp/syntax".prefix·1 string, @"regexp/syntax".complete·2 bool)
	func (@"regexp/syntax".p·2 *@"regexp/syntax".Prog "esc:0x1") StartCond () (? @"regexp/syntax".EmptyOp)
	func (@"regexp/syntax".p·2 *@"regexp/syntax".Prog "esc:0x1") String () (? string)
	func (@"regexp/syntax".p·3 *@"regexp/syntax".Prog "esc:0x22") @"regexp/syntax".skipNop (@"regexp/syntax".pc·4 uint32) (? *@"regexp/syntax".Inst, ? uint32)
	type @"regexp".onePassInst struct { ? @"regexp/syntax".Inst; Next []uint32 }
	type @"regexp".onePassProg struct { Inst []@"regexp".onePassInst; Start int; NumCap int }
	import sync "sync" // indirect
	type @"sync".Mutex struct { @"sync".state int32; @"sync".sema uint32 }
	func (@"sync".m·1 *@"sync".Mutex) Lock ()
	func (@"sync".m·1 *@"sync".Mutex) Unlock ()
	type @"regexp".input interface { @"regexp".canCheckPrefix() (? bool); @"regexp".context(@"regexp".pos int) (? @"regexp/syntax".EmptyOp); @"regexp".hasPrefix(@"regexp".re *@"regexp".Regexp) (? bool); @"regexp".index(@"regexp".re *@"regexp".Regexp, @"regexp".pos int) (? int); @"regexp".step(@"regexp".pos int) (@"regexp".r rune, @"regexp".width int) }
	type @"regexp".job struct { @"regexp".pc uint32; @"regexp".arg int; @"regexp".pos int }
	type @"regexp".bitState struct { @"regexp".prog *@"regexp/syntax".Prog; @"regexp".end int; @"regexp".cap []int; @"regexp".input @"regexp".input; @"regexp".jobs []@"regexp".job; @"regexp".visited []uint32 }
	func (@"regexp".b·1 *@"regexp".bitState "esc:0x9") @"regexp".push (@"regexp".pc·2 uint32, @"regexp".pos·3 int, @"regexp".arg·4 int)
	func (@"regexp".b·1 *@"regexp".bitState "esc:0x1") @"regexp".reset (@"regexp".end·2 int, @"regexp".ncap·3 int)
	func (@"regexp".b·2 *@"regexp".bitState "esc:0x1") @"regexp".shouldVisit (@"regexp".pc·3 uint32, @"regexp".pos·4 int) (? bool) { var @"regexp".n·5 uint; ; @"regexp".n·5 = uint(int(@"regexp".pc·3) * (@"regexp".b·2.@"regexp".end + 0x1) + @"regexp".pos·4); if @"regexp".b·2.@"regexp".visited[@"regexp".n·5 / 0x20] & (0x1 << (@"regexp".n·5 & 0x1f)) != 0x0 { return false }; @"regexp".b·2.@"regexp".visited[@"regexp".n·5 / 0x20] |= 0x1 << (@"regexp".n·5 & 0x1f); return true }
	type @"regexp".thread struct { @"regexp".inst *@"regexp/syntax".Inst; @"regexp".cap []int }
	type @"regexp".entry struct { @"regexp".pc uint32; @"regexp".t *@"regexp".thread }
	type @"regexp".queue struct { @"regexp".sparse []uint32; @"regexp".dense []@"regexp".entry }
	type @"regexp".inputBytes struct { @"regexp".str []byte }
	func (@"regexp".i·2 *@"regexp".inputBytes "esc:0x1") @"regexp".canCheckPrefix () (? bool) { return true }
	func (@"regexp".i·2 *@"regexp".inputBytes "esc:0x1") @"regexp".context (@"regexp".pos·3 int) (? @"regexp/syntax".EmptyOp)
	func (@"regexp".i·2 *@"regexp".inputBytes "esc:0x1") @"regexp".hasPrefix (@"regexp".re·3 *@"regexp".Regexp "esc:0x1") (? bool)
	func (@"regexp".i·2 *@"regexp".inputBytes "esc:0x1") @"regexp".index (@"regexp".re·3 *@"regexp".Regexp "esc:0x1", @"regexp".pos·4 int) (? int)
	func (@"regexp".i·3 *@"regexp".inputBytes "esc:0x1") @"regexp".step (@"regexp".pos·4 int) (? rune, ? int)
	type @"regexp".inputString struct { @"regexp".str string }
	func (@"regexp".i·2 *@"regexp".inputString "esc:0x1") @"regexp".canCheckPrefix () (? bool) { return true }
	func (@"regexp".i·2 *@"regexp".inputString "esc:0x1") @"regexp".context (@"regexp".pos·3 int) (? @"regexp/syntax".EmptyOp)
	func (@"regexp".i·2 *@"regexp".inputString "esc:0x1") @"regexp".hasPrefix (@"regexp".re·3 *@"regexp".Regexp "esc:0x1") (? bool) { return @"strings".HasPrefix(@"regexp".i·2.@"regexp".str, @"regexp".re·3.@"regexp".prefix) }
	func (@"regexp".i·2 *@"regexp".inputString "esc:0x9") @"regexp".index (@"regexp".re·3 *@"regexp".Regexp "esc:0x1", @"regexp".pos·4 int) (? int)
	func (@"regexp".i·3 *@"regexp".inputString "esc:0x1") @"regexp".step (@"regexp".pos·4 int) (? rune, ? int)
	import io "io" // indirect
	type @"io".RuneReader interface { ReadRune() (@"io".r rune, @"io".size int, @"io".err error) }
	type @"regexp".inputReader struct { @"regexp".r @"io".RuneReader; @"regexp".atEOT bool; @"regexp".pos int }
	func (@"regexp".i·2 *@"regexp".inputReader "esc:0x1") @"regexp".canCheckPrefix () (? bool) { return false }
	func (@"regexp".i·2 *@"regexp".inputReader "esc:0x1") @"regexp".context (@"regexp".pos·3 int) (? @"regexp/syntax".EmptyOp) { return @"regexp/syntax".EmptyOp(0x0) }
	func (@"regexp".i·2 *@"regexp".inputReader "esc:0x1") @"regexp".hasPrefix (@"regexp".re·3 *@"regexp".Regexp "esc:0x1") (? bool) { return false }
	func (@"regexp".i·2 *@"regexp".inputReader "esc:0x1") @"regexp".index (@"regexp".re·3 *@"regexp".Regexp "esc:0x1", @"regexp".pos·4 int) (? int) { return -0x1 }
	func (@"regexp".i·3 *@"regexp".inputReader "esc:0x9") @"regexp".step (@"regexp".pos·4 int) (? rune, ? int)
	type @"regexp".machine struct { @"regexp".re *@"regexp".Regexp; @"regexp".p *@"regexp/syntax".Prog; @"regexp".op *@"regexp".onePassProg; @"regexp".maxBitStateLen int; @"regexp".b *@"regexp".bitState; @"regexp".q0 @"regexp".queue; @"regexp".q1 @"regexp".queue; @"regexp".pool []*@"regexp".thread; @"regexp".matched bool; @"regexp".matchcap []int; @"regexp".inputBytes @"regexp".inputBytes; @"regexp".inputString @"regexp".inputString; @"regexp".inputReader @"regexp".inputReader }
	func (@"regexp".m·2 *@"regexp".machine "esc:0x3a") @"regexp".add (@"regexp".q·3 *@"regexp".queue "esc:0x1", @"regexp".pc·4 uint32, @"regexp".pos·5 int, @"regexp".cap·6 []int "esc:0x9", @"regexp".cond·7 @"regexp/syntax".EmptyOp, @"regexp".t·8 *@"regexp".thread) (? *@"regexp".thread)
	func (@"regexp".m·2 *@"regexp".machine "esc:0x32") @"regexp".alloc (@"regexp".i·3 *@"regexp/syntax".Inst) (? *@"regexp".thread) { var @"regexp".t·4 *@"regexp".thread; ; var @"regexp".n·5 int; ; @"regexp".n·5 = len(@"regexp".m·2.@"regexp".pool); if @"regexp".n·5 > 0x0 { @"regexp".t·4 = @"regexp".m·2.@"regexp".pool[@"regexp".n·5 - 0x1]; @"regexp".m·2.@"regexp".pool = @"regexp".m·2.@"regexp".pool[:@"regexp".n·5 - 0x1] } else { @"regexp".t·4 = new(@"regexp".thread); @"regexp".t·4.@"regexp".cap = make([]int, len(@"regexp".m·2.@"regexp".matchcap), cap(@"regexp".m·2.@"regexp".matchcap)) }; @"regexp".t·4.@"regexp".inst = @"regexp".i·3; return @"regexp".t·4 }
	func (@"regexp".m·2 *@"regexp".machine "esc:0x9") @"regexp".backtrack (@"regexp".i·3 @"regexp".input, @"regexp".pos·4 int, @"regexp".end·5 int, @"regexp".ncap·6 int) (? bool)
	func (@"regexp".m·1 *@"regexp".machine "esc:0x9") @"regexp".clear (@"regexp".q·2 *@"regexp".queue "esc:0x9")
	func (@"regexp".m·1 *@"regexp".machine "esc:0x9") @"regexp".free (@"regexp".t·2 *@"regexp".thread) { @"regexp".m·1.@"regexp".inputBytes.@"regexp".str = nil; @"regexp".m·1.@"regexp".inputString.@"regexp".str = ""; @"regexp".m·1.@"regexp".inputReader.@"regexp".r = nil; @"regexp".m·1.@"regexp".pool = append(@"regexp".m·1.@"regexp".pool, @"regexp".t·2) }
	func (@"regexp".m·1 *@"regexp".machine "esc:0x1") @"regexp".init (@"regexp".ncap·2 int)
	func (@"regexp".m·2 *@"regexp".machine "esc:0x9") @"regexp".match (@"regexp".i·3 @"regexp".input, @"regexp".pos·4 int) (? bool)
	func (@"regexp".m·2 *@"regexp".machine "esc:0x12") @"regexp".newInputBytes (@"regexp".b·3 []byte) (? @"regexp".input) { @"regexp".m·2.@"regexp".inputBytes.@"regexp".str = @"regexp".b·3; return &@"regexp".m·2.@"regexp".inputBytes }
	func (@"regexp".m·2 *@"regexp".machine "esc:0x12") @"regexp".newInputReader (@"regexp".r·3 @"io".RuneReader) (? @"regexp".input) { @"regexp".m·2.@"regexp".inputReader.@"regexp".r = @"regexp".r·3; @"regexp".m·2.@"regexp".inputReader.@"regexp".atEOT = false; @"regexp".m·2.@"regexp".inputReader.@"regexp".pos = 0x0; return &@"regexp".m·2.@"regexp".inputReader }
	func (@"regexp".m·2 *@"regexp".machine "esc:0x12") @"regexp".newInputString (@"regexp".s·3 string) (? @"regexp".input) { @"regexp".m·2.@"regexp".inputString.@"regexp".str = @"regexp".s·3; return &@"regexp".m·2.@"regexp".inputString }
	func (@"regexp".m·2 *@"regexp".machine "esc:0x9") @"regexp".onepass (@"regexp".i·3 @"regexp".input, @"regexp".pos·4 int) (? bool)
	func (@"regexp".m·1 *@"regexp".machine "esc:0x9") @"regexp".step (@"regexp".runq·2 *@"regexp".queue "esc:0x9", @"regexp".nextq·3 *@"regexp".queue "esc:0x1", @"regexp".pos·4 int, @"regexp".nextPos·5 int, @"regexp".c·6 rune, @"regexp".nextCond·7 @"regexp/syntax".EmptyOp)
	func (@"regexp".m·2 *@"regexp".machine "esc:0x1") @"regexp".tryBacktrack (@"regexp".b·3 *@"regexp".bitState "esc:0x9", @"regexp".i·4 @"regexp".input, @"regexp".pc·5 uint32, @"regexp".pos·6 int) (? bool)
	type @"regexp".Regexp struct { @"regexp".expr string; @"regexp".prog *@"regexp/syntax".Prog; @"regexp".onepass *@"regexp".onePassProg; @"regexp".prefix string; @"regexp".prefixBytes []byte; @"regexp".prefixComplete bool; @"regexp".prefixRune rune; @"regexp".prefixEnd uint32; @"regexp".cond @"regexp/syntax".EmptyOp; @"regexp".numSubexp int; @"regexp".subexpNames []string; @"regexp".longest bool; @"regexp".mu @"sync".Mutex; @"regexp".machine []*@"regexp".machine }
	func (@"regexp".re·2 *@"regexp".Regexp "esc:0x1") Expand (@"regexp".dst·3 []byte "esc:0x1a", @"regexp".template·4 []byte "esc:0x1", @"regexp".src·5 []byte "esc:0x9", @"regexp".match·6 []int "esc:0x1") (? []byte)
	func (@"regexp".re·2 *@"regexp".Regexp "esc:0x1") ExpandString (@"regexp".dst·3 []byte "esc:0x1a", @"regexp".template·4 string, @"regexp".src·5 string "esc:0x9", @"regexp".match·6 []int "esc:0x1") (? []byte)
	func (@"regexp".re·2 *@"regexp".Regexp) Find (@"regexp".b·3 []byte) (? []byte)
	func (@"regexp".re·2 *@"regexp".Regexp) FindAll (@"regexp".b·3 []byte, @"regexp".n·4 int) (? [][]byte)
	func (@"regexp".re·2 *@"regexp".Regexp) FindAllIndex (@"regexp".b·3 []byte, @"regexp".n·4 int) (? [][]int)
	func (@"regexp".re·2 *@"regexp".Regexp) FindAllString (@"regexp".s·3 string, @"regexp".n·4 int) (? []string)
	func (@"regexp".re·2 *@"regexp".Regexp) FindAllStringIndex (@"regexp".s·3 string, @"regexp".n·4 int) (? [][]int)
	func (@"regexp".re·2 *@"regexp".Regexp) FindAllStringSubmatch (@"regexp".s·3 string, @"regexp".n·4 int) (? [][]string)
	func (@"regexp".re·2 *@"regexp".Regexp) FindAllStringSubmatchIndex (@"regexp".s·3 string, @"regexp".n·4 int) (? [][]int)
	func (@"regexp".re·2 *@"regexp".Regexp) FindAllSubmatch (@"regexp".b·3 []byte, @"regexp".n·4 int) (? [][][]byte)
	func (@"regexp".re·2 *@"regexp".Regexp) FindAllSubmatchIndex (@"regexp".b·3 []byte, @"regexp".n·4 int) (? [][]int)
	func (@"regexp".re·2 *@"regexp".Regexp) FindIndex (@"regexp".b·3 []byte) (@"regexp".loc·1 []int)
	func (@"regexp".re·2 *@"regexp".Regexp) FindReaderIndex (@"regexp".r·3 @"io".RuneReader) (@"regexp".loc·1 []int)
	func (@"regexp".re·2 *@"regexp".Regexp) FindReaderSubmatchIndex (@"regexp".r·3 @"io".RuneReader) (? []int)
	func (@"regexp".re·2 *@"regexp".Regexp) FindString (@"regexp".s·3 string) (? string)
	func (@"regexp".re·2 *@"regexp".Regexp) FindStringIndex (@"regexp".s·3 string) (@"regexp".loc·1 []int)
	func (@"regexp".re·2 *@"regexp".Regexp) FindStringSubmatch (@"regexp".s·3 string) (? []string)
	func (@"regexp".re·2 *@"regexp".Regexp) FindStringSubmatchIndex (@"regexp".s·3 string) (? []int)
	func (@"regexp".re·2 *@"regexp".Regexp) FindSubmatch (@"regexp".b·3 []byte) (? [][]byte)
	func (@"regexp".re·2 *@"regexp".Regexp) FindSubmatchIndex (@"regexp".b·3 []byte) (? []int)
	func (@"regexp".re·3 *@"regexp".Regexp "esc:0x22") LiteralPrefix () (@"regexp".prefix·1 string, @"regexp".complete·2 bool) { return @"regexp".re·3.@"regexp".prefix, @"regexp".re·3.@"regexp".prefixComplete }
	func (@"regexp".re·1 *@"regexp".Regexp "esc:0x1") Longest () { @"regexp".re·1.@"regexp".longest = true }
	func (@"regexp".re·2 *@"regexp".Regexp) Match (@"regexp".b·3 []byte) (? bool)
	func (@"regexp".re·2 *@"regexp".Regexp) MatchReader (@"regexp".r·3 @"io".RuneReader) (? bool)
	func (@"regexp".re·2 *@"regexp".Regexp) MatchString (@"regexp".s·3 string) (? bool)
	func (@"regexp".re·2 *@"regexp".Regexp "esc:0x1") NumSubexp () (? int) { return @"regexp".re·2.@"regexp".numSubexp }
	func (@"regexp".re·2 *@"regexp".Regexp) ReplaceAll (@"regexp".src·3 []byte, @"regexp".repl·4 []byte "esc:0x1") (? []byte)
	func (@"regexp".re·2 *@"regexp".Regexp) ReplaceAllFunc (@"regexp".src·3 []byte, @"regexp".repl·4 func(? []byte) (? []byte) "esc:0x1") (? []byte)
	func (@"regexp".re·2 *@"regexp".Regexp) ReplaceAllLiteral (@"regexp".src·3 []byte, @"regexp".repl·4 []byte "esc:0x9") (? []byte)
	func (@"regexp".re·2 *@"regexp".Regexp) ReplaceAllLiteralString (@"regexp".src·3 string, @"regexp".repl·4 string "esc:0x9") (? string)
	func (@"regexp".re·2 *@"regexp".Regexp) ReplaceAllString (@"regexp".src·3 string, @"regexp".repl·4 string) (? string)
	func (@"regexp".re·2 *@"regexp".Regexp) ReplaceAllStringFunc (@"regexp".src·3 string, @"regexp".repl·4 func(? string) (? string) "esc:0x1") (? string)
	func (@"regexp".re·2 *@"regexp".Regexp) Split (@"regexp".s·3 string, @"regexp".n·4 int) (? []string)
	func (@"regexp".re·2 *@"regexp".Regexp "esc:0x22") String () (? string) { return @"regexp".re·2.@"regexp".expr }
	func (@"regexp".re·2 *@"regexp".Regexp "esc:0x22") SubexpNames () (? []string) { return @"regexp".re·2.@"regexp".subexpNames }
	func (@"regexp".re·1 *@"regexp".Regexp) @"regexp".allMatches (@"regexp".s·2 string, @"regexp".b·3 []byte, @"regexp".n·4 int, @"regexp".deliver·5 func(? []int) "esc:0x1")
	func (@"regexp".re·2 *@"regexp".Regexp) @"regexp".doExecute (@"regexp".r·3 @"io".RuneReader, @"regexp".b·4 []byte, @"regexp".s·5 string, @"regexp".pos·6 int, @"regexp".ncap·7 int) (? []int)
	func (@"regexp".re·2 *@"regexp".Regexp "esc:0x1") @"regexp".expand (@"regexp".dst·3 []byte "esc:0x1a", @"regexp".template·4 string, @"regexp".bsrc·5 []byte "esc:0x9", @"regexp".src·6 string "esc:0x9", @"regexp".match·7 []int "esc:0x1") (? []byte)
	func (@"regexp".re·2 *@"regexp".Regexp) @"regexp".get () (? *@"regexp".machine)
	func (@"regexp".re·2 *@"regexp".Regexp "esc:0x1") @"regexp".pad (@"regexp".a·3 []int "esc:0x1a") (? []int)
	func (@"regexp".re·1 *@"regexp".Regexp) @"regexp".put (@"regexp".z·2 *@"regexp".machine)
	func (@"regexp".re·2 *@"regexp".Regexp) @"regexp".replaceAll (@"regexp".bsrc·3 []byte, @"regexp".src·4 string, @"regexp".nmatch·5 int, @"regexp".repl·6 func(@"regexp".dst []byte, @"regexp".m []int) (? []byte) "esc:0x1") (? []byte)
	type @"github.com/robertkrimen/otto"._regExpObject struct { @"github.com/robertkrimen/otto".regularExpression *@"regexp".Regexp; @"github.com/robertkrimen/otto".global bool; @"github.com/robertkrimen/otto".ignoreCase bool; @"github.com/robertkrimen/otto".multiline bool; @"github.com/robertkrimen/otto".source string; @"github.com/robertkrimen/otto".flags string }
	type @"github.com/robertkrimen/otto"._stringObject interface { At(? int) (? rune); Length() (? int); String() (? string) }
	type @"github.com/robertkrimen/otto"._object struct { @"github.com/robertkrimen/otto".runtime *@"github.com/robertkrimen/otto"._runtime; @"github.com/robertkrimen/otto".class string; @"github.com/robertkrimen/otto".objectClass *@"github.com/robertkrimen/otto"._objectClass; @"github.com/robertkrimen/otto".value interface {}; @"github.com/robertkrimen/otto".prototype *@"github.com/robertkrimen/otto"._object; @"github.com/robertkrimen/otto".extensible bool; @"github.com/robertkrimen/otto".property map[string]@"github.com/robertkrimen/otto"._property; @"github.com/robertkrimen/otto".propertyOrder []string }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) DefaultValue (@"github.com/robertkrimen/otto".hint·3 @"github.com/robertkrimen/otto"._defaultValueHint) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) String () (? string)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._object "esc:0x9") @"github.com/robertkrimen/otto"._delete (@"github.com/robertkrimen/otto".name·2 string "esc:0x1")
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object "esc:0x1") @"github.com/robertkrimen/otto"._exists (@"github.com/robertkrimen/otto".name·3 string "esc:0x1") (? bool) { var @"github.com/robertkrimen/otto".exists·4 bool; ; _, @"github.com/robertkrimen/otto".exists·4 = @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".property[@"github.com/robertkrimen/otto".name·3]; return @"github.com/robertkrimen/otto".exists·4 }
	func (@"github.com/robertkrimen/otto".self·3 *@"github.com/robertkrimen/otto"._object "esc:0x1") @"github.com/robertkrimen/otto"._read (@"github.com/robertkrimen/otto".name·4 string "esc:0x1") (? @"github.com/robertkrimen/otto"._property, ? bool) { var @"github.com/robertkrimen/otto".property·5 @"github.com/robertkrimen/otto"._property; ; var @"github.com/robertkrimen/otto".exists·6 bool; ; @"github.com/robertkrimen/otto".property·5, @"github.com/robertkrimen/otto".exists·6 = @"github.com/robertkrimen/otto".self·3.@"github.com/robertkrimen/otto".property[@"github.com/robertkrimen/otto".name·4]; return @"github.com/robertkrimen/otto".property·5, @"github.com/robertkrimen/otto".exists·6 }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._object "esc:0x9") @"github.com/robertkrimen/otto"._write (@"github.com/robertkrimen/otto".name·2 string, @"github.com/robertkrimen/otto".value·3 interface {}, @"github.com/robertkrimen/otto".mode·4 @"github.com/robertkrimen/otto"._propertyMode) { if @"github.com/robertkrimen/otto".value·3 == nil { @"github.com/robertkrimen/otto".value·3 = (@"github.com/robertkrimen/otto".Value{  }) }; var @"github.com/robertkrimen/otto".exists·5 bool; ; _, @"github.com/robertkrimen/otto".exists·5 = @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".property[@"github.com/robertkrimen/otto".name·2]; @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".property[@"github.com/robertkrimen/otto".name·2] = (@"github.com/robertkrimen/otto"._property{ @"github.com/robertkrimen/otto".value:@"github.com/robertkrimen/otto".value·3, @"github.com/robertkrimen/otto".mode:@"github.com/robertkrimen/otto".mode·4 }); if !@"github.com/robertkrimen/otto".exists·5 { @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".propertyOrder = append(@"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".propertyOrder, @"github.com/robertkrimen/otto".name·2) } }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".call (@"github.com/robertkrimen/otto".this·3 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".argumentList·4 []@"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".eval·5 bool, @"github.com/robertkrimen/otto".frame·6 @"github.com/robertkrimen/otto"._frame) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".canPut (@"github.com/robertkrimen/otto".name·3 string) (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".construct (@"github.com/robertkrimen/otto".argumentList·3 []@"github.com/robertkrimen/otto".Value) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object "esc:0x22") @"github.com/robertkrimen/otto".dateValue () (? @"github.com/robertkrimen/otto"._dateObject) { var @"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto"._dateObject; ; @"github.com/robertkrimen/otto".value·3, _ = @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".value.(@"github.com/robertkrimen/otto"._dateObject); return @"github.com/robertkrimen/otto".value·3 }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".defineOwnProperty (@"github.com/robertkrimen/otto".name·3 string, @"github.com/robertkrimen/otto".descriptor·4 @"github.com/robertkrimen/otto"._property, @"github.com/robertkrimen/otto".throw·5 bool) (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".defineProperty (@"github.com/robertkrimen/otto".name·3 string, @"github.com/robertkrimen/otto".value·4 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".mode·5 @"github.com/robertkrimen/otto"._propertyMode, @"github.com/robertkrimen/otto".throw·6 bool) (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".delete (@"github.com/robertkrimen/otto".name·3 string, @"github.com/robertkrimen/otto".throw·4 bool) (? bool)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".enumerate (@"github.com/robertkrimen/otto".all·2 bool, @"github.com/robertkrimen/otto".each·3 func(? string) (? bool))
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".get (@"github.com/robertkrimen/otto".name·3 string) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".getOwnProperty (@"github.com/robertkrimen/otto".name·3 string) (? *@"github.com/robertkrimen/otto"._property)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".getProperty (@"github.com/robertkrimen/otto".name·3 string) (? *@"github.com/robertkrimen/otto"._property)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".hasInstance (@"github.com/robertkrimen/otto".of·3 @"github.com/robertkrimen/otto".Value "esc:0x1") (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".hasOwnProperty (@"github.com/robertkrimen/otto".name·3 string) (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object "esc:0x1") @"github.com/robertkrimen/otto".hasPrimitive () (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".hasProperty (@"github.com/robertkrimen/otto".name·3 string) (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object "esc:0x1") @"github.com/robertkrimen/otto".isCall () (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object "esc:0x2a") @"github.com/robertkrimen/otto".primitiveValue () (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._object) @"github.com/robertkrimen/otto".put (@"github.com/robertkrimen/otto".name·2 string, @"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".throw·4 bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object "esc:0x22") @"github.com/robertkrimen/otto".regExpValue () (? @"github.com/robertkrimen/otto"._regExpObject) { var @"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto"._regExpObject; ; @"github.com/robertkrimen/otto".value·3, _ = @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".value.(@"github.com/robertkrimen/otto"._regExpObject); return @"github.com/robertkrimen/otto".value·3 }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._object "esc:0x22") @"github.com/robertkrimen/otto".stringValue () (? @"github.com/robertkrimen/otto"._stringObject) { var @"github.com/robertkrimen/otto".str·3 @"github.com/robertkrimen/otto"._stringObject; ; var @"github.com/robertkrimen/otto".ok·4 bool; ; @"github.com/robertkrimen/otto".str·3, @"github.com/robertkrimen/otto".ok·4 = @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".value.(@"github.com/robertkrimen/otto"._stringObject); if @"github.com/robertkrimen/otto".ok·4 { return @"github.com/robertkrimen/otto".str·3 }; return nil }
	type @"github.com/robertkrimen/otto"._global struct { Object *@"github.com/robertkrimen/otto"._object; Function *@"github.com/robertkrimen/otto"._object; Array *@"github.com/robertkrimen/otto"._object; String *@"github.com/robertkrimen/otto"._object; Boolean *@"github.com/robertkrimen/otto"._object; Number *@"github.com/robertkrimen/otto"._object; Math *@"github.com/robertkrimen/otto"._object; Date *@"github.com/robertkrimen/otto"._object; RegExp *@"github.com/robertkrimen/otto"._object; Error *@"github.com/robertkrimen/otto"._object; EvalError *@"github.com/robertkrimen/otto"._object; TypeError *@"github.com/robertkrimen/otto"._object; RangeError *@"github.com/robertkrimen/otto"._object; ReferenceError *@"github.com/robertkrimen/otto"._object; SyntaxError *@"github.com/robertkrimen/otto"._object; URIError *@"github.com/robertkrimen/otto"._object; JSON *@"github.com/robertkrimen/otto"._object; ObjectPrototype *@"github.com/robertkrimen/otto"._object; FunctionPrototype *@"github.com/robertkrimen/otto"._object; ArrayPrototype *@"github.com/robertkrimen/otto"._object; StringPrototype *@"github.com/robertkrimen/otto"._object; BooleanPrototype *@"github.com/robertkrimen/otto"._object; NumberPrototype *@"github.com/robertkrimen/otto"._object; DatePrototype *@"github.com/robertkrimen/otto"._object; RegExpPrototype *@"github.com/robertkrimen/otto"._object; ErrorPrototype *@"github.com/robertkrimen/otto"._object; EvalErrorPrototype *@"github.com/robertkrimen/otto"._object; TypeErrorPrototype *@"github.com/robertkrimen/otto"._object; RangeErrorPrototype *@"github.com/robertkrimen/otto"._object; ReferenceErrorPrototype *@"github.com/robertkrimen/otto"._object; SyntaxErrorPrototype *@"github.com/robertkrimen/otto"._object; URIErrorPrototype *@"github.com/robertkrimen/otto"._object }
	type @"github.com/robertkrimen/otto"._scope struct { @"github.com/robertkrimen/otto".lexical @"github.com/robertkrimen/otto"._stash; @"github.com/robertkrimen/otto".variable @"github.com/robertkrimen/otto"._stash; @"github.com/robertkrimen/otto".this *@"github.com/robertkrimen/otto"._object; @"github.com/robertkrimen/otto".eval bool; @"github.com/robertkrimen/otto".outer *@"github.com/robertkrimen/otto"._scope; @"github.com/robertkrimen/otto".frame @"github.com/robertkrimen/otto"._frame }
	import token "github.com/robertkrimen/otto/token" // indirect
	type @"github.com/robertkrimen/otto/token".Token int
	func (@"github.com/robertkrimen/otto/token".tkn·2 @"github.com/robertkrimen/otto/token".Token) String () (? string)
	func (@"github.com/robertkrimen/otto/token".tkn·2 @"github.com/robertkrimen/otto/token".Token) @"github.com/robertkrimen/otto/token".precedence (@"github.com/robertkrimen/otto/token".in·3 bool) (? int)
	type @"github.com/robertkrimen/otto"._nodeStatement interface { @"github.com/robertkrimen/otto"._statementNode() }
	type @"github.com/robertkrimen/otto"._nodeFunctionLiteral struct { @"github.com/robertkrimen/otto".name string; @"github.com/robertkrimen/otto".body @"github.com/robertkrimen/otto"._nodeStatement; @"github.com/robertkrimen/otto".source string; @"github.com/robertkrimen/otto".parameterList []string; @"github.com/robertkrimen/otto".varList []string; @"github.com/robertkrimen/otto".functionList []*@"github.com/robertkrimen/otto"._nodeFunctionLiteral; @"github.com/robertkrimen/otto".file *@"github.com/robertkrimen/otto/file".File }
	func (? *@"github.com/robertkrimen/otto"._nodeFunctionLiteral) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._nodeExpression interface { @"github.com/robertkrimen/otto"._expressionNode() }
	type @"github.com/robertkrimen/otto"._nodeArrayLiteral struct { @"github.com/robertkrimen/otto".value []@"github.com/robertkrimen/otto"._nodeExpression }
	func (? *@"github.com/robertkrimen/otto"._nodeArrayLiteral) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._nodeAssignExpression struct { @"github.com/robertkrimen/otto".operator @"github.com/robertkrimen/otto/token".Token; @"github.com/robertkrimen/otto".left @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".right @"github.com/robertkrimen/otto"._nodeExpression }
	func (? *@"github.com/robertkrimen/otto"._nodeAssignExpression) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._nodeBinaryExpression struct { @"github.com/robertkrimen/otto".operator @"github.com/robertkrimen/otto/token".Token; @"github.com/robertkrimen/otto".left @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".right @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".comparison bool }
	func (? *@"github.com/robertkrimen/otto"._nodeBinaryExpression) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto/file".Idx int
	type @"github.com/robertkrimen/otto"._nodeBracketExpression struct { @"github.com/robertkrimen/otto".idx @"github.com/robertkrimen/otto/file".Idx; @"github.com/robertkrimen/otto".left @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".member @"github.com/robertkrimen/otto"._nodeExpression }
	func (? *@"github.com/robertkrimen/otto"._nodeBracketExpression) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._nodeCallExpression struct { @"github.com/robertkrimen/otto".callee @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".argumentList []@"github.com/robertkrimen/otto"._nodeExpression }
	func (? *@"github.com/robertkrimen/otto"._nodeCallExpression) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._nodeConditionalExpression struct { @"github.com/robertkrimen/otto".test @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".consequent @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".alternate @"github.com/robertkrimen/otto"._nodeExpression }
	func (? *@"github.com/robertkrimen/otto"._nodeConditionalExpression) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._nodeDoWhileStatement struct { @"github.com/robertkrimen/otto".test @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".body []@"github.com/robertkrimen/otto"._nodeStatement }
	func (? *@"github.com/robertkrimen/otto"._nodeDoWhileStatement) @"github.com/robertkrimen/otto"._statementNode () {  }
	type @"github.com/robertkrimen/otto"._nodeDotExpression struct { @"github.com/robertkrimen/otto".idx @"github.com/robertkrimen/otto/file".Idx; @"github.com/robertkrimen/otto".left @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".identifier string }
	func (? *@"github.com/robertkrimen/otto"._nodeDotExpression) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._nodeForInStatement struct { @"github.com/robertkrimen/otto".into @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".source @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".body []@"github.com/robertkrimen/otto"._nodeStatement }
	func (? *@"github.com/robertkrimen/otto"._nodeForInStatement) @"github.com/robertkrimen/otto"._statementNode () {  }
	type @"github.com/robertkrimen/otto"._nodeForStatement struct { @"github.com/robertkrimen/otto".initializer @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".update @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".test @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".body []@"github.com/robertkrimen/otto"._nodeStatement }
	func (? *@"github.com/robertkrimen/otto"._nodeForStatement) @"github.com/robertkrimen/otto"._statementNode () {  }
	type @"github.com/robertkrimen/otto"._nodeIfStatement struct { @"github.com/robertkrimen/otto".test @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".consequent @"github.com/robertkrimen/otto"._nodeStatement; @"github.com/robertkrimen/otto".alternate @"github.com/robertkrimen/otto"._nodeStatement }
	func (? *@"github.com/robertkrimen/otto"._nodeIfStatement) @"github.com/robertkrimen/otto"._statementNode () {  }
	type @"github.com/robertkrimen/otto"._nodeNewExpression struct { @"github.com/robertkrimen/otto".callee @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".argumentList []@"github.com/robertkrimen/otto"._nodeExpression }
	func (? *@"github.com/robertkrimen/otto"._nodeNewExpression) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._nodeProperty struct { @"github.com/robertkrimen/otto".key string; @"github.com/robertkrimen/otto".kind string; @"github.com/robertkrimen/otto".value @"github.com/robertkrimen/otto"._nodeExpression }
	type @"github.com/robertkrimen/otto"._nodeObjectLiteral struct { @"github.com/robertkrimen/otto".value []@"github.com/robertkrimen/otto"._nodeProperty }
	func (? *@"github.com/robertkrimen/otto"._nodeObjectLiteral) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._node interface {}
	type @"github.com/robertkrimen/otto"._nodeDeclaration struct { @"github.com/robertkrimen/otto".name string; @"github.com/robertkrimen/otto".definition @"github.com/robertkrimen/otto"._node }
	type @"github.com/robertkrimen/otto"._nodeProgram struct { @"github.com/robertkrimen/otto".body []@"github.com/robertkrimen/otto"._nodeStatement; @"github.com/robertkrimen/otto".varList []string; @"github.com/robertkrimen/otto".functionList []*@"github.com/robertkrimen/otto"._nodeFunctionLiteral; @"github.com/robertkrimen/otto".variableList []@"github.com/robertkrimen/otto"._nodeDeclaration; @"github.com/robertkrimen/otto".file *@"github.com/robertkrimen/otto/file".File }
	type @"github.com/robertkrimen/otto"._nodeSequenceExpression struct { @"github.com/robertkrimen/otto".sequence []@"github.com/robertkrimen/otto"._nodeExpression }
	func (? *@"github.com/robertkrimen/otto"._nodeSequenceExpression) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._nodeCaseStatement struct { @"github.com/robertkrimen/otto".test @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".consequent []@"github.com/robertkrimen/otto"._nodeStatement }
	func (? *@"github.com/robertkrimen/otto"._nodeCaseStatement) @"github.com/robertkrimen/otto"._statementNode () {  }
	type @"github.com/robertkrimen/otto"._nodeSwitchStatement struct { @"github.com/robertkrimen/otto".discriminant @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".default_ int; @"github.com/robertkrimen/otto".body []*@"github.com/robertkrimen/otto"._nodeCaseStatement }
	func (? *@"github.com/robertkrimen/otto"._nodeSwitchStatement) @"github.com/robertkrimen/otto"._statementNode () {  }
	type @"github.com/robertkrimen/otto"._nodeCatchStatement struct { @"github.com/robertkrimen/otto".parameter string; @"github.com/robertkrimen/otto".body @"github.com/robertkrimen/otto"._nodeStatement }
	func (? *@"github.com/robertkrimen/otto"._nodeCatchStatement) @"github.com/robertkrimen/otto"._statementNode () {  }
	type @"github.com/robertkrimen/otto"._nodeTryStatement struct { @"github.com/robertkrimen/otto".body @"github.com/robertkrimen/otto"._nodeStatement; @"github.com/robertkrimen/otto".catch *@"github.com/robertkrimen/otto"._nodeCatchStatement; @"github.com/robertkrimen/otto".finally @"github.com/robertkrimen/otto"._nodeStatement }
	func (? *@"github.com/robertkrimen/otto"._nodeTryStatement) @"github.com/robertkrimen/otto"._statementNode () {  }
	type @"github.com/robertkrimen/otto"._nodeUnaryExpression struct { @"github.com/robertkrimen/otto".operator @"github.com/robertkrimen/otto/token".Token; @"github.com/robertkrimen/otto".operand @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".postfix bool }
	func (? *@"github.com/robertkrimen/otto"._nodeUnaryExpression) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._nodeVariableExpression struct { @"github.com/robertkrimen/otto".idx @"github.com/robertkrimen/otto/file".Idx; @"github.com/robertkrimen/otto".name string; @"github.com/robertkrimen/otto".initializer @"github.com/robertkrimen/otto"._nodeExpression }
	func (? *@"github.com/robertkrimen/otto"._nodeVariableExpression) @"github.com/robertkrimen/otto"._expressionNode () {  }
	type @"github.com/robertkrimen/otto"._nodeWhileStatement struct { @"github.com/robertkrimen/otto".test @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".body []@"github.com/robertkrimen/otto"._nodeStatement }
	func (? *@"github.com/robertkrimen/otto"._nodeWhileStatement) @"github.com/robertkrimen/otto"._statementNode () {  }
	type @"github.com/robertkrimen/otto"._nodeWithStatement struct { @"github.com/robertkrimen/otto".object @"github.com/robertkrimen/otto"._nodeExpression; @"github.com/robertkrimen/otto".body @"github.com/robertkrimen/otto"._nodeStatement }
	func (? *@"github.com/robertkrimen/otto"._nodeWithStatement) @"github.com/robertkrimen/otto"._statementNode () {  }
	type @"github.com/robertkrimen/otto".FunctionCall struct { @"github.com/robertkrimen/otto".runtime *@"github.com/robertkrimen/otto"._runtime; @"github.com/robertkrimen/otto"._thisObject *@"github.com/robertkrimen/otto"._object; @"github.com/robertkrimen/otto".eval bool; This @"github.com/robertkrimen/otto".Value; ArgumentList []@"github.com/robertkrimen/otto".Value; Otto *@"github.com/robertkrimen/otto".Otto }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".FunctionCall "esc:0x22") Argument (@"github.com/robertkrimen/otto".index·3 int) (? @"github.com/robertkrimen/otto".Value) { return @"github.com/robertkrimen/otto".valueOfArrayIndex(@"github.com/robertkrimen/otto".self·2.ArgumentList, @"github.com/robertkrimen/otto".index·3) }
	func (@"github.com/robertkrimen/otto".self·3 @"github.com/robertkrimen/otto".FunctionCall "esc:0x22") @"github.com/robertkrimen/otto".getArgument (@"github.com/robertkrimen/otto".index·4 int) (? @"github.com/robertkrimen/otto".Value, ? bool) { return @"github.com/robertkrimen/otto".getValueOfArrayIndex(@"github.com/robertkrimen/otto".self·3.ArgumentList, @"github.com/robertkrimen/otto".index·4) }
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".FunctionCall "esc:0x12") @"github.com/robertkrimen/otto".slice (@"github.com/robertkrimen/otto".index·3 int) (? []@"github.com/robertkrimen/otto".Value) { if @"github.com/robertkrimen/otto".index·3 < len(@"github.com/robertkrimen/otto".self·2.ArgumentList) { return @"github.com/robertkrimen/otto".self·2.ArgumentList[@"github.com/robertkrimen/otto".index·3:] }; return ([]@"github.com/robertkrimen/otto".Value{  }) }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto".FunctionCall "esc:0x2a") @"github.com/robertkrimen/otto".thisClassObject (@"github.com/robertkrimen/otto".class·3 string "esc:0x1") (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto".FunctionCall "esc:0x2a") @"github.com/robertkrimen/otto".thisObject () (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".FunctionCall) @"github.com/robertkrimen/otto".toObject (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	type @"github.com/robertkrimen/otto"._nativeFunction func(? @"github.com/robertkrimen/otto".FunctionCall) (? @"github.com/robertkrimen/otto".Value)
	type @"github.com/robertkrimen/otto"._exception struct { @"github.com/robertkrimen/otto".value interface {} }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._exception "esc:0x22") @"github.com/robertkrimen/otto".eject () (? interface {}) { var @"github.com/robertkrimen/otto".value·3 interface {}; ; @"github.com/robertkrimen/otto".value·3 = @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".value; @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".value = nil; return @"github.com/robertkrimen/otto".value·3 }
	import ast "github.com/robertkrimen/otto/ast" // indirect
	type @"github.com/robertkrimen/otto/ast".Statement interface { Idx0() (? @"github.com/robertkrimen/otto/file".Idx); Idx1() (? @"github.com/robertkrimen/otto/file".Idx); @"github.com/robertkrimen/otto/ast"._statementNode() }
	type @"github.com/robertkrimen/otto/ast".Declaration interface { @"github.com/robertkrimen/otto/ast"._declarationNode() }
	type @"github.com/robertkrimen/otto/ast".Program struct { Body []@"github.com/robertkrimen/otto/ast".Statement; DeclarationList []@"github.com/robertkrimen/otto/ast".Declaration; File *@"github.com/robertkrimen/otto/file".File }
	func (@"github.com/robertkrimen/otto/ast".self·2 *@"github.com/robertkrimen/otto/ast".Program "esc:0x9") Idx0 () (? @"github.com/robertkrimen/otto/file".Idx)
	func (@"github.com/robertkrimen/otto/ast".self·2 *@"github.com/robertkrimen/otto/ast".Program "esc:0x9") Idx1 () (? @"github.com/robertkrimen/otto/file".Idx)
	type @"github.com/robertkrimen/otto"._runtime struct { @"github.com/robertkrimen/otto".global @"github.com/robertkrimen/otto"._global; @"github.com/robertkrimen/otto".globalObject *@"github.com/robertkrimen/otto"._object; @"github.com/robertkrimen/otto".globalStash *@"github.com/robertkrimen/otto"._objectStash; @"github.com/robertkrimen/otto".scope *@"github.com/robertkrimen/otto"._scope; @"github.com/robertkrimen/otto".otto *@"github.com/robertkrimen/otto".Otto; @"github.com/robertkrimen/otto".eval *@"github.com/robertkrimen/otto"._object; @"github.com/robertkrimen/otto".labels []string; @"github.com/robertkrimen/otto".lck @"sync".Mutex }
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto"._newRegExp (@"github.com/robertkrimen/otto".pattern·3 string, @"github.com/robertkrimen/otto".flags·4 string) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".calculateBinaryExpression (@"github.com/robertkrimen/otto".operator·3 @"github.com/robertkrimen/otto/token".Token, @"github.com/robertkrimen/otto".left·4 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".right·5 @"github.com/robertkrimen/otto".Value) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x1") @"github.com/robertkrimen/otto".calculateComparison (@"github.com/robertkrimen/otto".comparator·3 @"github.com/robertkrimen/otto/token".Token, @"github.com/robertkrimen/otto".left·4 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".right·5 @"github.com/robertkrimen/otto".Value) (? bool)
	func (@"github.com/robertkrimen/otto".in·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".clone () (? *@"github.com/robertkrimen/otto"._runtime)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_call_nodeFunction (@"github.com/robertkrimen/otto".function·3 *@"github.com/robertkrimen/otto"._object, @"github.com/robertkrimen/otto".stash·4 *@"github.com/robertkrimen/otto"._fnStash, @"github.com/robertkrimen/otto".node·5 *@"github.com/robertkrimen/otto"._nodeFunctionLiteral, @"github.com/robertkrimen/otto".this·6 @"github.com/robertkrimen/otto".Value "esc:0x1", @"github.com/robertkrimen/otto".argumentList·7 []@"github.com/robertkrimen/otto".Value "esc:0x9") (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeArrayLiteral (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeArrayLiteral) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeAssignExpression (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeAssignExpression) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeBinaryExpression (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeBinaryExpression) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeBinaryExpression_comparison (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeBinaryExpression) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeBracketExpression (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeBracketExpression) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeCallExpression (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeCallExpression, @"github.com/robertkrimen/otto".withArgumentList·4 []interface {} "esc:0x9") (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeConditionalExpression (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeConditionalExpression) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeDoWhileStatement (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeDoWhileStatement) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeDotExpression (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeDotExpression) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeExpression (@"github.com/robertkrimen/otto".node·3 @"github.com/robertkrimen/otto"._nodeExpression) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeForInStatement (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeForInStatement) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeForStatement (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeForStatement) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeIfStatement (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeIfStatement) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeNewExpression (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeNewExpression) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeObjectLiteral (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeObjectLiteral) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeProgram (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeProgram "esc:0x9", @"github.com/robertkrimen/otto".eval·4 bool) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeSequenceExpression (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeSequenceExpression) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeStatement (@"github.com/robertkrimen/otto".node·3 @"github.com/robertkrimen/otto"._nodeStatement) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeStatementList (@"github.com/robertkrimen/otto".list·3 []@"github.com/robertkrimen/otto"._nodeStatement) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeSwitchStatement (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeSwitchStatement) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeTryStatement (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeTryStatement) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeUnaryExpression (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeUnaryExpression) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeVariableExpression (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeVariableExpression) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeWhileStatement (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeWhileStatement) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_evaluate_nodeWithStatement (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeWithStatement) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_functionDeclaration (@"github.com/robertkrimen/otto".list·2 []*@"github.com/robertkrimen/otto"._nodeFunctionLiteral)
	func (@"github.com/robertkrimen/otto".runtime·3 *@"github.com/robertkrimen/otto"._runtime "esc:0x1") @"github.com/robertkrimen/otto".cmpl_parse (@"github.com/robertkrimen/otto".filename·4 string, @"github.com/robertkrimen/otto".src·5 interface {}) (? *@"github.com/robertkrimen/otto"._nodeProgram, ? error)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".cmpl_parseOrThrow (@"github.com/robertkrimen/otto".source·3 string) (? *@"github.com/robertkrimen/otto"._nodeProgram)
	func (@"github.com/robertkrimen/otto".self·3 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".cmpl_run (@"github.com/robertkrimen/otto".src·4 interface {}) (? @"github.com/robertkrimen/otto".Value, ? error)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".cmpl_variableDeclaration (@"github.com/robertkrimen/otto".list·2 []string "esc:0x9")
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".enterFunctionScope (@"github.com/robertkrimen/otto".outer·3 @"github.com/robertkrimen/otto"._stash, @"github.com/robertkrimen/otto".this·4 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._fnStash)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".enterGlobalScope () { @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".enterScope(@"github.com/robertkrimen/otto".newScope(@"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".globalStash, @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".globalStash, @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".globalObject)) }
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".enterScope (@"github.com/robertkrimen/otto".scope·2 *@"github.com/robertkrimen/otto"._scope) { @"github.com/robertkrimen/otto".scope·2.@"github.com/robertkrimen/otto".outer = @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".scope; @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".scope = @"github.com/robertkrimen/otto".scope·2 }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x1") @"github.com/robertkrimen/otto".evaluateDivide (@"github.com/robertkrimen/otto".left·3 float64, @"github.com/robertkrimen/otto".right·4 float64) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x1") @"github.com/robertkrimen/otto".evaluateModulo (@"github.com/robertkrimen/otto".left·3 float64, @"github.com/robertkrimen/otto".right·4 float64) (? @"github.com/robertkrimen/otto".Value) { return (@"github.com/robertkrimen/otto".Value{  }) }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x1") @"github.com/robertkrimen/otto".evaluateMultiply (@"github.com/robertkrimen/otto".left·3 float64, @"github.com/robertkrimen/otto".right·4 float64) (? @"github.com/robertkrimen/otto".Value) { return (@"github.com/robertkrimen/otto".Value{  }) }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".fromPropertyDescriptor (@"github.com/robertkrimen/otto".descriptor·3 @"github.com/robertkrimen/otto"._property) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".leaveScope () { @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".scope = @"github.com/robertkrimen/otto".self·1.@"github.com/robertkrimen/otto".scope.@"github.com/robertkrimen/otto".outer }
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newArgumentsObject (@"github.com/robertkrimen/otto".indexOfParameterName·3 []string, @"github.com/robertkrimen/otto".stash·4 @"github.com/robertkrimen/otto"._stash, @"github.com/robertkrimen/otto".length·5 int) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newArray (@"github.com/robertkrimen/otto".length·3 uint32) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newArrayObject (@"github.com/robertkrimen/otto".length·3 uint32) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newArrayOf (@"github.com/robertkrimen/otto".valueArray·3 []@"github.com/robertkrimen/otto".Value "esc:0x9") (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newBaseObject () (? *@"github.com/robertkrimen/otto"._object) { var @"github.com/robertkrimen/otto".self·3 *@"github.com/robertkrimen/otto"._object; ; @"github.com/robertkrimen/otto".self·3 = @"github.com/robertkrimen/otto".newObject(@"github.com/robertkrimen/otto".runtime·2, ""); return @"github.com/robertkrimen/otto".self·3 }
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newBoolean (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newBooleanObject (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newBoundFunction (@"github.com/robertkrimen/otto".target·3 *@"github.com/robertkrimen/otto"._object, @"github.com/robertkrimen/otto".this·4 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".argumentList·5 []@"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newBoundFunctionObject (@"github.com/robertkrimen/otto".target·3 *@"github.com/robertkrimen/otto"._object, @"github.com/robertkrimen/otto".this·4 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".argumentList·5 []@"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newClassObject (@"github.com/robertkrimen/otto".class·3 string) (? *@"github.com/robertkrimen/otto"._object) { return @"github.com/robertkrimen/otto".newObject(@"github.com/robertkrimen/otto".runtime·2, @"github.com/robertkrimen/otto".class·3) }
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newConsole () (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newDate (@"github.com/robertkrimen/otto".epoch·3 float64) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newDateObject (@"github.com/robertkrimen/otto".epoch·3 float64) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newDeclarationStash (@"github.com/robertkrimen/otto".outer·3 @"github.com/robertkrimen/otto"._stash) (? *@"github.com/robertkrimen/otto"._dclStash) { return (&@"github.com/robertkrimen/otto"._dclStash{ @"github.com/robertkrimen/otto"._runtime:@"github.com/robertkrimen/otto".runtime·2, @"github.com/robertkrimen/otto"._outer:@"github.com/robertkrimen/otto".outer·3, @"github.com/robertkrimen/otto".property:(map[string]@"github.com/robertkrimen/otto"._dclProperty{  }) }) }
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newError (@"github.com/robertkrimen/otto".name·3 string, @"github.com/robertkrimen/otto".message·4 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".rt·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newErrorObject (@"github.com/robertkrimen/otto".name·3 string, @"github.com/robertkrimen/otto".message·4 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newEvalError (@"github.com/robertkrimen/otto".message·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newFunctionStash (@"github.com/robertkrimen/otto".outer·3 @"github.com/robertkrimen/otto"._stash) (? *@"github.com/robertkrimen/otto"._fnStash) { return (&@"github.com/robertkrimen/otto"._fnStash{ @"github.com/robertkrimen/otto"._dclStash:(@"github.com/robertkrimen/otto"._dclStash{ @"github.com/robertkrimen/otto"._runtime:@"github.com/robertkrimen/otto".runtime·2, @"github.com/robertkrimen/otto"._outer:@"github.com/robertkrimen/otto".outer·3, @"github.com/robertkrimen/otto".property:(map[string]@"github.com/robertkrimen/otto"._dclProperty{  }) }) }) }
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newGoArray (@"github.com/robertkrimen/otto".value·3 @"reflect".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newGoArrayObject (@"github.com/robertkrimen/otto".value·3 @"reflect".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newGoMapObject (@"github.com/robertkrimen/otto".value·3 @"reflect".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newGoSlice (@"github.com/robertkrimen/otto".value·3 @"reflect".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newGoSliceObject (@"github.com/robertkrimen/otto".value·3 @"reflect".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newGoStructObject (@"github.com/robertkrimen/otto".value·3 @"reflect".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newNativeFunction (@"github.com/robertkrimen/otto".name·3 string "esc:0x1", @"github.com/robertkrimen/otto"._nativeFunction·4 @"github.com/robertkrimen/otto"._nativeFunction) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newNativeFunctionObject (@"github.com/robertkrimen/otto".name·3 string "esc:0x1", @"github.com/robertkrimen/otto".native·4 @"github.com/robertkrimen/otto"._nativeFunction, @"github.com/robertkrimen/otto".length·5 int) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newNodeFunction (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeFunctionLiteral, @"github.com/robertkrimen/otto".scopeEnvironment·4 @"github.com/robertkrimen/otto"._stash) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newNodeFunctionObject (@"github.com/robertkrimen/otto".node·3 *@"github.com/robertkrimen/otto"._nodeFunctionLiteral, @"github.com/robertkrimen/otto".stash·4 @"github.com/robertkrimen/otto"._stash) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newNumber (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newNumberObject (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newObject () (? *@"github.com/robertkrimen/otto"._object) { var @"github.com/robertkrimen/otto".self·3 *@"github.com/robertkrimen/otto"._object; ; @"github.com/robertkrimen/otto".self·3 = @"github.com/robertkrimen/otto".runtime·2.@"github.com/robertkrimen/otto".newClassObject("Object"); @"github.com/robertkrimen/otto".self·3.@"github.com/robertkrimen/otto".prototype = @"github.com/robertkrimen/otto".runtime·2.@"github.com/robertkrimen/otto".global.ObjectPrototype; return @"github.com/robertkrimen/otto".self·3 }
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newObjectStash (@"github.com/robertkrimen/otto".object·3 *@"github.com/robertkrimen/otto"._object, @"github.com/robertkrimen/otto".outer·4 @"github.com/robertkrimen/otto"._stash) (? *@"github.com/robertkrimen/otto"._objectStash) { if @"github.com/robertkrimen/otto".object·3 == nil { @"github.com/robertkrimen/otto".object·3 = @"github.com/robertkrimen/otto".runtime·2.@"github.com/robertkrimen/otto".newBaseObject(); @"github.com/robertkrimen/otto".object·3.@"github.com/robertkrimen/otto".class = "environment" }; return (&@"github.com/robertkrimen/otto"._objectStash{ @"github.com/robertkrimen/otto"._runtime:@"github.com/robertkrimen/otto".runtime·2, @"github.com/robertkrimen/otto"._outer:@"github.com/robertkrimen/otto".outer·4, @"github.com/robertkrimen/otto".object:@"github.com/robertkrimen/otto".object·3 }) }
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newPrimitiveObject (@"github.com/robertkrimen/otto".class·3 string, @"github.com/robertkrimen/otto".value·4 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object) { var @"github.com/robertkrimen/otto".self·5 *@"github.com/robertkrimen/otto"._object; ; @"github.com/robertkrimen/otto".self·5 = @"github.com/robertkrimen/otto".runtime·2.@"github.com/robertkrimen/otto".newClassObject(@"github.com/robertkrimen/otto".class·3); @"github.com/robertkrimen/otto".self·5.@"github.com/robertkrimen/otto".value = @"github.com/robertkrimen/otto".value·4; return @"github.com/robertkrimen/otto".self·5 }
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newRangeError (@"github.com/robertkrimen/otto".message·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newReferenceError (@"github.com/robertkrimen/otto".message·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newRegExp (@"github.com/robertkrimen/otto".patternValue·3 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".flagsValue·4 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newRegExpObject (@"github.com/robertkrimen/otto".pattern·3 string, @"github.com/robertkrimen/otto".flags·4 string) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newString (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newStringObject (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newSyntaxError (@"github.com/robertkrimen/otto".message·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newTypeError (@"github.com/robertkrimen/otto".message·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".newURIError (@"github.com/robertkrimen/otto".message·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".self·3 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".objectCoerce (@"github.com/robertkrimen/otto".value·4 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object, ? error)
	func (@"github.com/robertkrimen/otto".rt·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".panicRangeError (@"github.com/robertkrimen/otto".argumentList·3 ...interface {} "esc:0x9") (? *@"github.com/robertkrimen/otto"._exception)
	func (@"github.com/robertkrimen/otto".rt·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".panicReferenceError (@"github.com/robertkrimen/otto".argumentList·3 ...interface {} "esc:0x9") (? *@"github.com/robertkrimen/otto"._exception)
	func (@"github.com/robertkrimen/otto".rt·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".panicSyntaxError (@"github.com/robertkrimen/otto".argumentList·3 ...interface {} "esc:0x9") (? *@"github.com/robertkrimen/otto"._exception)
	func (@"github.com/robertkrimen/otto".rt·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".panicTypeError (@"github.com/robertkrimen/otto".argumentList·3 ...interface {} "esc:0x9") (? *@"github.com/robertkrimen/otto"._exception)
	func (@"github.com/robertkrimen/otto".rt·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".panicURIError (@"github.com/robertkrimen/otto".argumentList·3 ...interface {} "esc:0x9") (? *@"github.com/robertkrimen/otto"._exception)
	func (@"github.com/robertkrimen/otto".runtime·3 *@"github.com/robertkrimen/otto"._runtime "esc:0x1") @"github.com/robertkrimen/otto".parse (@"github.com/robertkrimen/otto".filename·4 string, @"github.com/robertkrimen/otto".src·5 interface {}) (? *@"github.com/robertkrimen/otto/ast".Program, ? error)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".parseOrThrow (@"github.com/robertkrimen/otto".source·3 string) (? *@"github.com/robertkrimen/otto/ast".Program)
	func (@"github.com/robertkrimen/otto".self·4 *@"github.com/robertkrimen/otto"._runtime "esc:0x1") @"github.com/robertkrimen/otto".parseSource (@"github.com/robertkrimen/otto".src·5 interface {}) (? *@"github.com/robertkrimen/otto"._nodeProgram, ? *@"github.com/robertkrimen/otto/ast".Program, ? error)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".parseThrow (@"github.com/robertkrimen/otto".err·2 error)
	func (@"github.com/robertkrimen/otto".self·1 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".putValue (@"github.com/robertkrimen/otto".reference·2 @"github.com/robertkrimen/otto"._reference, @"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·3 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".safeToValue (@"github.com/robertkrimen/otto".value·4 interface {}) (? @"github.com/robertkrimen/otto".Value, ? error)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".toObject (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) (? *@"github.com/robertkrimen/otto"._object)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".toValue (@"github.com/robertkrimen/otto".value·3 interface {}) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x1") @"github.com/robertkrimen/otto".toValueArray (@"github.com/robertkrimen/otto".arguments·3 ...interface {} "esc:0x2a") (? []@"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·3 *@"github.com/robertkrimen/otto"._runtime) @"github.com/robertkrimen/otto".tryCatchEvaluate (@"github.com/robertkrimen/otto".inner·4 func() (? @"github.com/robertkrimen/otto".Value) "esc:0x1") (@"github.com/robertkrimen/otto".tryValue·1 @"github.com/robertkrimen/otto".Value, @"github.com/robertkrimen/otto".exception·2 bool)
	func (@"github.com/robertkrimen/otto".rt·2 *@"github.com/robertkrimen/otto"._runtime "esc:0x9") @"github.com/robertkrimen/otto".typeErrorResult (@"github.com/robertkrimen/otto".throw·3 bool) (? bool)
	type @"github.com/robertkrimen/otto".Script struct { @"github.com/robertkrimen/otto".version string; @"github.com/robertkrimen/otto".program *@"github.com/robertkrimen/otto"._nodeProgram; @"github.com/robertkrimen/otto".filename string; @"github.com/robertkrimen/otto".src string }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto".Script "esc:0x1") String () (? string) { return "// " + @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".filename + "\n" + @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".src }
	func (@"github.com/robertkrimen/otto".self·3 *@"github.com/robertkrimen/otto".Script "esc:0x9") @"github.com/robertkrimen/otto".marshalBinary () (? []byte, ? error)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto".Script) @"github.com/robertkrimen/otto".unmarshalBinary (@"github.com/robertkrimen/otto".data·3 []byte) (? error)
	type @"github.com/robertkrimen/otto".Otto struct { Interrupt chan func(); @"github.com/robertkrimen/otto".runtime *@"github.com/robertkrimen/otto"._runtime }
	func (@"github.com/robertkrimen/otto".self·3 @"github.com/robertkrimen/otto".Otto) Call (@"github.com/robertkrimen/otto".source·4 string, @"github.com/robertkrimen/otto".this·5 interface {}, @"github.com/robertkrimen/otto".argumentList·6 ...interface {} "esc:0x9") (? @"github.com/robertkrimen/otto".Value, ? error)
	func (@"github.com/robertkrimen/otto".self·3 *@"github.com/robertkrimen/otto".Otto "esc:0x1") Compile (@"github.com/robertkrimen/otto".filename·4 string, @"github.com/robertkrimen/otto".src·5 interface {}) (? *@"github.com/robertkrimen/otto".Script, ? error)
	func (@"github.com/robertkrimen/otto".in·2 *@"github.com/robertkrimen/otto".Otto "esc:0x9") Copy () (? *@"github.com/robertkrimen/otto".Otto)
	func (@"github.com/robertkrimen/otto".self·3 @"github.com/robertkrimen/otto".Otto "esc:0x9") Get (@"github.com/robertkrimen/otto".name·4 string) (? @"github.com/robertkrimen/otto".Value, ? error)
	func (@"github.com/robertkrimen/otto".self·3 @"github.com/robertkrimen/otto".Otto) Object (@"github.com/robertkrimen/otto".source·4 string) (? *@"github.com/robertkrimen/otto".Object, ? error)
	func (@"github.com/robertkrimen/otto".self·3 @"github.com/robertkrimen/otto".Otto) Run (@"github.com/robertkrimen/otto".src·4 interface {}) (? @"github.com/robertkrimen/otto".Value, ? error)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".Otto) Set (@"github.com/robertkrimen/otto".name·3 string, @"github.com/robertkrimen/otto".value·4 interface {}) (? error)
	func (@"github.com/robertkrimen/otto".self·3 @"github.com/robertkrimen/otto".Otto) ToValue (@"github.com/robertkrimen/otto".value·4 interface {}) (? @"github.com/robertkrimen/otto".Value, ? error)
	func (@"github.com/robertkrimen/otto".otto·2 *@"github.com/robertkrimen/otto".Otto "esc:0x9") @"github.com/robertkrimen/otto".clone () (? *@"github.com/robertkrimen/otto".Otto)
	func (@"github.com/robertkrimen/otto".self·2 @"github.com/robertkrimen/otto".Otto "esc:0x9") @"github.com/robertkrimen/otto".getValue (@"github.com/robertkrimen/otto".name·3 string) (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·1 @"github.com/robertkrimen/otto".Otto "esc:0x9") @"github.com/robertkrimen/otto".setValue (@"github.com/robertkrimen/otto".name·2 string, @"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value)
	type @"".method struct { Notice string "json:notice"; @"".name string }
	type @"".userDoc struct { Methods map[string]*@"".method "json:methods" }
	type @"".NatSpec struct { @"".jsvm *@"github.com/robertkrimen/otto".Otto; @"".abiDocJson []byte; @"".userDoc @"".userDoc; @"".tx string; @"".data string }
	func (@"".self·3 *@"".NatSpec "esc:0x9") Notice () (@"".notice·1 string, @"".err·2 error)
	func (@"".self·2 *@"".NatSpec "esc:0x32") @"".makeAbi2method (@"".abiKey·3 [8]byte) (@"".meth·1 *@"".method)
	func (@"".self·3 *@"".NatSpec "esc:0x9") @"".noticeForMethod (@"".tx·4 string "esc:0x1", @"".name·5 string "esc:0x1", @"".expression·6 string) (@"".notice·1 string, @"".err·2 error)
	type @"sync".Locker interface { Lock(); Unlock() }
	type @"sync".RWMutex struct { @"sync".w @"sync".Mutex; @"sync".writerSem uint32; @"sync".readerSem uint32; @"sync".readerCount int32; @"sync".readerWait int32 }
	func (@"sync".rw·1 *@"sync".RWMutex) Lock ()
	func (@"sync".rw·1 *@"sync".RWMutex) RLock ()
	func (@"sync".rw·2 *@"sync".RWMutex "esc:0x12") RLocker () (? @"sync".Locker) { return (*@"sync".rlocker)(@"sync".rw·2) }
	func (@"sync".rw·1 *@"sync".RWMutex) RUnlock ()
	func (@"sync".rw·1 *@"sync".RWMutex) Unlock ()
	import vm "github.com/ethereum/go-ethereum/core/vm" // indirect
	import big "math/big" // indirect
	type @"math/big".Word uintptr
	type @"math/big".divisor struct { @"math/big".bbb @"math/big".nat; @"math/big".nbits int; @"math/big".ndigits int }
	import rand "math/rand" // indirect
	type @"math/rand".Source interface { Int63() (? int64); Seed(@"math/rand".seed int64) }
	type @"math/rand".Rand struct { @"math/rand".src @"math/rand".Source }
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") ExpFloat64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Float32 () (? float32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Float64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int () (? int)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int31 () (? int32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int31n (@"math/rand".n·3 int32) (? int32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int63 () (? int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int63n (@"math/rand".n·3 int64) (? int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Intn (@"math/rand".n·3 int) (? int)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") NormFloat64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Perm (@"math/rand".n·3 int) (? []int)
	func (@"math/rand".r·1 *@"math/rand".Rand "esc:0x9") Seed (@"math/rand".seed·2 int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Uint32 () (? uint32)
	type @"io".ByteScanner interface { ReadByte() (@"io".c byte, @"io".err error); UnreadByte() (? error) }
	type @"math/big".nat []@"math/big".Word
	func (@"math/big".z·2 @"math/big".nat) @"math/big".add (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".and (@"math/big".x·3 @"math/big".nat "esc:0x1", @"math/big".y·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".andNot (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".bit (@"math/big".i·3 uint) (? uint) { var @"math/big".j·4 uint; ; @"math/big".j·4 = @"math/big".i·3 / 0x40; if @"math/big".j·4 >= uint(len(@"math/big".x·2)) { return 0x0 }; return uint(@"math/big".x·2[@"math/big".j·4] >> (@"math/big".i·3 % 0x40) & @"math/big".Word(0x1)) }
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".bitLen () (? int)
	func (@"math/big".z·2 @"math/big".nat "esc:0x1") @"math/big".bytes (@"math/big".buf·3 []byte "esc:0x1") (@"math/big".i·1 int)
	func (@"math/big".z·1 @"math/big".nat "esc:0x1") @"math/big".clear ()
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".cmp (@"math/big".y·3 @"math/big".nat "esc:0x1") (@"math/big".r·1 int)
	func (@"math/big".q·1 @"math/big".nat) @"math/big".convertWords (@"math/big".s·2 []byte "esc:0x1", @"math/big".charset·3 string "esc:0x1", @"math/big".b·4 @"math/big".Word, @"math/big".ndigits·5 int, @"math/big".bb·6 @"math/big".Word, @"math/big".table·7 []@"math/big".divisor "esc:0x9")
	func (@"math/big".x·2 @"math/big".nat "esc:0x9") @"math/big".decimalString () (? string)
	func (@"math/big".z·3 @"math/big".nat) @"math/big".div (@"math/big".z2·4 @"math/big".nat, @"math/big".u·5 @"math/big".nat, @"math/big".v·6 @"math/big".nat) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".nat)
	func (@"math/big".z·3 @"math/big".nat "esc:0x12") @"math/big".divLarge (@"math/big".u·4 @"math/big".nat, @"math/big".uIn·5 @"math/big".nat, @"math/big".v·6 @"math/big".nat) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".nat)
	func (@"math/big".z·3 @"math/big".nat) @"math/big".divW (@"math/big".x·4 @"math/big".nat, @"math/big".y·5 @"math/big".Word) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".Word)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNN (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNNMontgomery (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNNWindowed (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expWW (@"math/big".x·3 @"math/big".Word, @"math/big".y·4 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x9") @"math/big".hexString () (? string)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".make (@"math/big".n·3 int) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat) @"math/big".modW (@"math/big".d·3 @"math/big".Word) (@"math/big".r·1 @"math/big".Word)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".montgomery (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat, @"math/big".k·6 @"math/big".Word, @"math/big".n·7 int) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mul (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mulAddWW (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".Word, @"math/big".r·5 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mulRange (@"math/big".a·3 uint64, @"math/big".b·4 uint64) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".norm () (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".or (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".n·2 @"math/big".nat) @"math/big".probablyPrime (@"math/big".reps·3 int) (? bool)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".random (@"math/big".rand·3 *@"math/rand".Rand "esc:0x9", @"math/big".limit·4 @"math/big".nat "esc:0x1", @"math/big".n·5 int) (? @"math/big".nat)
	func (@"math/big".z·5 @"math/big".nat) @"math/big".scan (@"math/big".r·6 @"io".ByteScanner, @"math/big".base·7 int, @"math/big".fracOk·8 bool) (@"math/big".res·1 @"math/big".nat, @"math/big".b·2 int, @"math/big".count·3 int, @"math/big".err·4 error)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".set (@"math/big".x·3 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setBit (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".i·4 uint, @"math/big".b·5 uint) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setBytes (@"math/big".buf·3 []byte "esc:0x1") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setUint64 (@"math/big".x·3 uint64) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setWord (@"math/big".x·3 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".shl (@"math/big".x·3 @"math/big".nat, @"math/big".s·4 uint) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".shr (@"math/big".x·3 @"math/big".nat, @"math/big".s·4 uint) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".sticky (@"math/big".i·3 uint) (? uint)
	func (@"math/big".x·2 @"math/big".nat "esc:0x9") @"math/big".string (@"math/big".charset·3 string "esc:0x1") (? string)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".sub (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".trailingZeroBits () (? uint)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".xor (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	type @"fmt".State interface { Flag(@"fmt".c int) (? bool); Precision() (@"fmt".prec int, @"fmt".ok bool); Width() (@"fmt".wid int, @"fmt".ok bool); Write(@"fmt".b []byte) (@"fmt".ret int, @"fmt".err error) }
	type @"fmt".ScanState interface { Read(@"fmt".buf []byte) (@"fmt".n int, @"fmt".err error); ReadRune() (@"fmt".r rune, @"fmt".size int, @"fmt".err error); SkipSpace(); Token(@"fmt".skipSpace bool, @"fmt".f func(? rune) (? bool)) (@"fmt".token []byte, @"fmt".err error); UnreadRune() (? error); Width() (@"fmt".wid int, @"fmt".ok bool) }
	type @"math/big".Int struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Abs (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Add (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") And (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") AndNot (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Binomial (@"math/big".n·3 int64, @"math/big".k·4 int64) (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") Bit (@"math/big".i·3 int) (? uint)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") BitLen () (? int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x22") Bits () (? []@"math/big".Word) { return @"math/big".x·2.@"math/big".abs }
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Bytes () (? []byte)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Cmp (@"math/big".y·3 *@"math/big".Int "esc:0x1") (@"math/big".r·1 int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Div (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") DivMod (@"math/big".x·4 *@"math/big".Int "esc:0x9", @"math/big".y·5 *@"math/big".Int "esc:0x9", @"math/big".m·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Exp (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x1", @"math/big".m·5 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·1 *@"math/big".Int "esc:0x9") Format (@"math/big".s·2 @"fmt".State, @"math/big".ch·3 rune)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") GCD (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9", @"math/big".a·5 *@"math/big".Int "esc:0x9", @"math/big".b·6 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") GobDecode (@"math/big".buf·3 []byte "esc:0x1") (? error)
	func (@"math/big".x·3 *@"math/big".Int "esc:0x1") GobEncode () (? []byte, ? error)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Int64 () (? int64) { var @"math/big".v·3 int64; ; @"math/big".v·3 = int64(@"math/big".low64(@"math/big".x·2.@"math/big".abs)); if @"math/big".x·2.@"math/big".neg { @"math/big".v·3 = -@"math/big".v·3 }; return @"math/big".v·3 }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Lsh (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 uint) (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x9") MarshalJSON () (? []byte, ? error)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x9") MarshalText () (@"math/big".text·1 []byte, @"math/big".err·2 error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Mod (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") ModInverse (@"math/big".g·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") ModSqrt (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".p·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Mul (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") MulRange (@"math/big".a·3 int64, @"math/big".b·4 int64) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Neg (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Not (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Or (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") ProbablyPrime (@"math/big".n·3 int) (? bool)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Quo (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") QuoRem (@"math/big".x·4 *@"math/big".Int "esc:0x9", @"math/big".y·5 *@"math/big".Int "esc:0x9", @"math/big".r·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rand (@"math/big".rnd·3 *@"math/rand".Rand "esc:0x9", @"math/big".n·4 *@"math/big".Int "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rem (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rsh (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 uint) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") Scan (@"math/big".s·3 @"fmt".ScanState, @"math/big".ch·4 rune) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Set (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetBit (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".i·4 int, @"math/big".b·5 uint) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x12") SetBits (@"math/big".abs·3 []@"math/big".Word) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetBytes (@"math/big".buf·3 []byte "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetInt64 (@"math/big".x·3 int64) (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") SetString (@"math/big".s·4 string, @"math/big".base·5 int) (? *@"math/big".Int, ? bool)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetUint64 (@"math/big".x·3 uint64) (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Sign () (? int) { if len(@"math/big".x·2.@"math/big".abs) == 0x0 { return 0x0 }; if @"math/big".x·2.@"math/big".neg { return -0x1 }; return 0x1 }
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") String () (? string)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Sub (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Uint64 () (? uint64) { return @"math/big".low64(@"math/big".x·2.@"math/big".abs) }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") UnmarshalJSON (@"math/big".text·3 []byte) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") UnmarshalText (@"math/big".text·3 []byte) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Xor (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") @"math/big".binaryGCD (@"math/big".a·3 *@"math/big".Int "esc:0x9", @"math/big".b·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·4 *@"math/big".Int "esc:0x1a") @"math/big".scan (@"math/big".r·5 @"io".ByteScanner, @"math/big".base·6 int) (? *@"math/big".Int, ? int, ? error)
	type @"github.com/ethereum/go-ethereum/common".Hash [32]byte
	func (@"github.com/ethereum/go-ethereum/common".h·2 @"github.com/ethereum/go-ethereum/common".Hash) Big () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/common".h·2 @"github.com/ethereum/go-ethereum/common".Hash) Bytes () (? []byte) { return @"github.com/ethereum/go-ethereum/common".h·2[:] }
	func (@"github.com/ethereum/go-ethereum/common".h·2 @"github.com/ethereum/go-ethereum/common".Hash) Generate (@"github.com/ethereum/go-ethereum/common".rand·3 *@"math/rand".Rand "esc:0x9", @"github.com/ethereum/go-ethereum/common".size·4 int) (? @"reflect".Value)
	func (@"github.com/ethereum/go-ethereum/common".h·2 @"github.com/ethereum/go-ethereum/common".Hash) Hex () (? string)
	func (@"github.com/ethereum/go-ethereum/common".h·1 *@"github.com/ethereum/go-ethereum/common".Hash "esc:0x1") Set (@"github.com/ethereum/go-ethereum/common".other·2 @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/common".h·1 *@"github.com/ethereum/go-ethereum/common".Hash "esc:0x1") SetBytes (@"github.com/ethereum/go-ethereum/common".b·2 []byte "esc:0x9") { if len(@"github.com/ethereum/go-ethereum/common".b·2) > 0x20 { @"github.com/ethereum/go-ethereum/common".b·2 = @"github.com/ethereum/go-ethereum/common".b·2[len(@"github.com/ethereum/go-ethereum/common".b·2) - 0x20:] }; copy(@"github.com/ethereum/go-ethereum/common".h·1[0x20 - len(@"github.com/ethereum/go-ethereum/common".b·2):], @"github.com/ethereum/go-ethereum/common".b·2) }
	func (@"github.com/ethereum/go-ethereum/common".h·1 *@"github.com/ethereum/go-ethereum/common".Hash "esc:0x1") SetString (@"github.com/ethereum/go-ethereum/common".s·2 string "esc:0x1") { @"github.com/ethereum/go-ethereum/common".h·1.SetBytes(([]byte)(@"github.com/ethereum/go-ethereum/common".s·2)) }
	func (@"github.com/ethereum/go-ethereum/common".h·2 @"github.com/ethereum/go-ethereum/common".Hash) Str () (? string) { return string(@"github.com/ethereum/go-ethereum/common".h·2[:]) }
	type @"github.com/ethereum/go-ethereum/common".Address [20]byte
	func (@"github.com/ethereum/go-ethereum/common".a·2 @"github.com/ethereum/go-ethereum/common".Address) Big () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/common".a·2 @"github.com/ethereum/go-ethereum/common".Address) Bytes () (? []byte) { return @"github.com/ethereum/go-ethereum/common".a·2[:] }
	func (@"github.com/ethereum/go-ethereum/common".a·2 @"github.com/ethereum/go-ethereum/common".Address) Hash () (? @"github.com/ethereum/go-ethereum/common".Hash) { return @"github.com/ethereum/go-ethereum/common".BytesToHash(@"github.com/ethereum/go-ethereum/common".a·2[:]) }
	func (@"github.com/ethereum/go-ethereum/common".a·2 @"github.com/ethereum/go-ethereum/common".Address) Hex () (? string)
	func (@"github.com/ethereum/go-ethereum/common".a·1 *@"github.com/ethereum/go-ethereum/common".Address "esc:0x1") Set (@"github.com/ethereum/go-ethereum/common".other·2 @"github.com/ethereum/go-ethereum/common".Address)
	func (@"github.com/ethereum/go-ethereum/common".a·1 *@"github.com/ethereum/go-ethereum/common".Address "esc:0x1") SetBytes (@"github.com/ethereum/go-ethereum/common".b·2 []byte "esc:0x9") { if len(@"github.com/ethereum/go-ethereum/common".b·2) > 0x14 { @"github.com/ethereum/go-ethereum/common".b·2 = @"github.com/ethereum/go-ethereum/common".b·2[len(@"github.com/ethereum/go-ethereum/common".b·2) - 0x14:] }; copy(@"github.com/ethereum/go-ethereum/common".a·1[0x14 - len(@"github.com/ethereum/go-ethereum/common".b·2):], @"github.com/ethereum/go-ethereum/common".b·2) }
	func (@"github.com/ethereum/go-ethereum/common".a·1 *@"github.com/ethereum/go-ethereum/common".Address "esc:0x1") SetString (@"github.com/ethereum/go-ethereum/common".s·2 string "esc:0x1") { @"github.com/ethereum/go-ethereum/common".a·1.SetBytes(([]byte)(@"github.com/ethereum/go-ethereum/common".s·2)) }
	func (@"github.com/ethereum/go-ethereum/common".a·2 @"github.com/ethereum/go-ethereum/common".Address) Str () (? string) { return string(@"github.com/ethereum/go-ethereum/common".a·2[:]) }
	import rlp "github.com/ethereum/go-ethereum/rlp" // indirect
	type @"github.com/ethereum/go-ethereum/rlp".ByteReader interface { Read(@"io".p []byte) (@"io".n int, @"io".err error); ReadByte() (@"io".c byte, @"io".err error) }
	type @"github.com/ethereum/go-ethereum/rlp".Kind int
	func (@"github.com/ethereum/go-ethereum/rlp".k·2 @"github.com/ethereum/go-ethereum/rlp".Kind) String () (? string)
	type @"github.com/ethereum/go-ethereum/rlp".listpos struct { @"github.com/ethereum/go-ethereum/rlp".pos uint64; @"github.com/ethereum/go-ethereum/rlp".size uint64 }
	type @"io".Reader interface { Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"github.com/ethereum/go-ethereum/rlp".Stream struct { @"github.com/ethereum/go-ethereum/rlp".r @"github.com/ethereum/go-ethereum/rlp".ByteReader; @"github.com/ethereum/go-ethereum/rlp".remaining uint64; @"github.com/ethereum/go-ethereum/rlp".limited bool; @"github.com/ethereum/go-ethereum/rlp".uintbuf []byte; @"github.com/ethereum/go-ethereum/rlp".kind @"github.com/ethereum/go-ethereum/rlp".Kind; @"github.com/ethereum/go-ethereum/rlp".size uint64; @"github.com/ethereum/go-ethereum/rlp".byteval byte; @"github.com/ethereum/go-ethereum/rlp".kinderr error; @"github.com/ethereum/go-ethereum/rlp".stack []@"github.com/ethereum/go-ethereum/rlp".listpos }
	func (@"github.com/ethereum/go-ethereum/rlp".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x10a") Bool () (? bool, ? error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x11a") Bytes () (? []byte, ? error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·2 *@"github.com/ethereum/go-ethereum/rlp".Stream) Decode (@"github.com/ethereum/go-ethereum/rlp".val·3 interface {}) (? error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·4 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x80a") Kind () (@"github.com/ethereum/go-ethereum/rlp".kind·1 @"github.com/ethereum/go-ethereum/rlp".Kind, @"github.com/ethereum/go-ethereum/rlp".size·2 uint64, @"github.com/ethereum/go-ethereum/rlp".err·3 error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x10a") List () (@"github.com/ethereum/go-ethereum/rlp".size·1 uint64, @"github.com/ethereum/go-ethereum/rlp".err·2 error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·2 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x1") ListEnd () (? error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x11a") Raw () (? []byte, ? error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·1 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x1") Reset (@"github.com/ethereum/go-ethereum/rlp".r·2 @"io".Reader, @"github.com/ethereum/go-ethereum/rlp".inputLimit·3 uint64)
	func (@"github.com/ethereum/go-ethereum/rlp".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x10a") Uint () (? uint64, ? error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x9") @"github.com/ethereum/go-ethereum/rlp".readByte () (? byte, ? error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·2 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x9") @"github.com/ethereum/go-ethereum/rlp".readFull (@"github.com/ethereum/go-ethereum/rlp".buf·3 []byte) (@"github.com/ethereum/go-ethereum/rlp".err·1 error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·4 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x9") @"github.com/ethereum/go-ethereum/rlp".readKind () (@"github.com/ethereum/go-ethereum/rlp".kind·1 @"github.com/ethereum/go-ethereum/rlp".Kind, @"github.com/ethereum/go-ethereum/rlp".size·2 uint64, @"github.com/ethereum/go-ethereum/rlp".err·3 error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x9") @"github.com/ethereum/go-ethereum/rlp".readUint (@"github.com/ethereum/go-ethereum/rlp".size·4 byte) (? uint64, ? error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x10a") @"github.com/ethereum/go-ethereum/rlp".uint (@"github.com/ethereum/go-ethereum/rlp".maxbits·4 int) (? uint64, ? error)
	func (@"github.com/ethereum/go-ethereum/rlp".s·2 *@"github.com/ethereum/go-ethereum/rlp".Stream "esc:0x1") @"github.com/ethereum/go-ethereum/rlp".willRead (@"github.com/ethereum/go-ethereum/rlp".n·3 uint64) (? error) { @"github.com/ethereum/go-ethereum/rlp".s·2.@"github.com/ethereum/go-ethereum/rlp".kind = @"github.com/ethereum/go-ethereum/rlp".Kind(-0x1); if len(@"github.com/ethereum/go-ethereum/rlp".s·2.@"github.com/ethereum/go-ethereum/rlp".stack) > 0x0 { var @"github.com/ethereum/go-ethereum/rlp".tos·4 @"github.com/ethereum/go-ethereum/rlp".listpos; ; @"github.com/ethereum/go-ethereum/rlp".tos·4 = @"github.com/ethereum/go-ethereum/rlp".s·2.@"github.com/ethereum/go-ethereum/rlp".stack[len(@"github.com/ethereum/go-ethereum/rlp".s·2.@"github.com/ethereum/go-ethereum/rlp".stack) - 0x1]; if @"github.com/ethereum/go-ethereum/rlp".n·3 > @"github.com/ethereum/go-ethereum/rlp".tos·4.@"github.com/ethereum/go-ethereum/rlp".size - @"github.com/ethereum/go-ethereum/rlp".tos·4.@"github.com/ethereum/go-ethereum/rlp".pos { return @"github.com/ethereum/go-ethereum/rlp".ErrElemTooLarge }; @"github.com/ethereum/go-ethereum/rlp".s·2.@"github.com/ethereum/go-ethereum/rlp".stack[len(@"github.com/ethereum/go-ethereum/rlp".s·2.@"github.com/ethereum/go-ethereum/rlp".stack) - 0x1].@"github.com/ethereum/go-ethereum/rlp".pos += @"github.com/ethereum/go-ethereum/rlp".n·3 }; if @"github.com/ethereum/go-ethereum/rlp".s·2.@"github.com/ethereum/go-ethereum/rlp".limited { if @"github.com/ethereum/go-ethereum/rlp".n·3 > @"github.com/ethereum/go-ethereum/rlp".s·2.@"github.com/ethereum/go-ethereum/rlp".remaining { return @"github.com/ethereum/go-ethereum/rlp".ErrValueTooLarge }; @"github.com/ethereum/go-ethereum/rlp".s·2.@"github.com/ethereum/go-ethereum/rlp".remaining -= @"github.com/ethereum/go-ethereum/rlp".n·3 }; return nil }
	type @"io".Writer interface { Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"github.com/ethereum/go-ethereum/core/vm".Log struct { Address @"github.com/ethereum/go-ethereum/common".Address; Topics []@"github.com/ethereum/go-ethereum/common".Hash; Data []byte; BlockNumber uint64; TxHash @"github.com/ethereum/go-ethereum/common".Hash; TxIndex uint; BlockHash @"github.com/ethereum/go-ethereum/common".Hash; Index uint }
	func (@"github.com/ethereum/go-ethereum/core/vm".l·2 *@"github.com/ethereum/go-ethereum/core/vm".Log "esc:0x1") DecodeRLP (@"github.com/ethereum/go-ethereum/core/vm".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream) (? error)
	func (@"github.com/ethereum/go-ethereum/core/vm".l·2 *@"github.com/ethereum/go-ethereum/core/vm".Log "esc:0x9") EncodeRLP (@"github.com/ethereum/go-ethereum/core/vm".w·3 @"io".Writer) (? error)
	func (@"github.com/ethereum/go-ethereum/core/vm".l·2 *@"github.com/ethereum/go-ethereum/core/vm".Log "esc:0x9") String () (? string)
	type @"github.com/ethereum/go-ethereum/core/vm".Logs []*@"github.com/ethereum/go-ethereum/core/vm".Log
	type @"github.com/ethereum/go-ethereum/xeth".logQueue struct { @"github.com/ethereum/go-ethereum/xeth".mu @"sync".Mutex; @"github.com/ethereum/go-ethereum/xeth".logs @"github.com/ethereum/go-ethereum/core/vm".Logs; @"github.com/ethereum/go-ethereum/xeth".timeout @"time".Time; @"github.com/ethereum/go-ethereum/xeth".id int }
	func (@"github.com/ethereum/go-ethereum/xeth".l·1 *@"github.com/ethereum/go-ethereum/xeth".logQueue) @"github.com/ethereum/go-ethereum/xeth".add (@"github.com/ethereum/go-ethereum/xeth".logs·2 ...*@"github.com/ethereum/go-ethereum/core/vm".Log "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/xeth".l·2 *@"github.com/ethereum/go-ethereum/xeth".logQueue) @"github.com/ethereum/go-ethereum/xeth".get () (? @"github.com/ethereum/go-ethereum/core/vm".Logs)
	type @"github.com/ethereum/go-ethereum/xeth".hashQueue struct { @"github.com/ethereum/go-ethereum/xeth".mu @"sync".Mutex; @"github.com/ethereum/go-ethereum/xeth".hashes []@"github.com/ethereum/go-ethereum/common".Hash; @"github.com/ethereum/go-ethereum/xeth".timeout @"time".Time; @"github.com/ethereum/go-ethereum/xeth".id int }
	func (@"github.com/ethereum/go-ethereum/xeth".l·1 *@"github.com/ethereum/go-ethereum/xeth".hashQueue) @"github.com/ethereum/go-ethereum/xeth".add (@"github.com/ethereum/go-ethereum/xeth".hashes·2 ...@"github.com/ethereum/go-ethereum/common".Hash "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/xeth".l·2 *@"github.com/ethereum/go-ethereum/xeth".hashQueue) @"github.com/ethereum/go-ethereum/xeth".get () (? []@"github.com/ethereum/go-ethereum/common".Hash)
	import whisper "github.com/ethereum/go-ethereum/whisper" // indirect
	import p2p "github.com/ethereum/go-ethereum/p2p" // indirect
	import net "net" // indirect
	type @"net".Addr interface { Network() (? string); String() (? string) }
	type @"net".Conn interface { Close() (? error); LocalAddr() (? @"net".Addr); Read(@"net".b []byte) (@"net".n int, @"net".err error); RemoteAddr() (? @"net".Addr); SetDeadline(@"net".t @"time".Time) (? error); SetReadDeadline(@"net".t @"time".Time) (? error); SetWriteDeadline(@"net".t @"time".Time) (? error); Write(@"net".b []byte) (@"net".n int, @"net".err error) }
	type @"github.com/ethereum/go-ethereum/p2p".Msg struct { Code uint64; Size uint32; Payload @"io".Reader; ReceivedAt @"time".Time }
	func (@"github.com/ethereum/go-ethereum/p2p".msg·2 @"github.com/ethereum/go-ethereum/p2p".Msg) Decode (@"github.com/ethereum/go-ethereum/p2p".val·3 interface {}) (? error)
	func (@"github.com/ethereum/go-ethereum/p2p".msg·2 @"github.com/ethereum/go-ethereum/p2p".Msg) Discard () (? error)
	func (@"github.com/ethereum/go-ethereum/p2p".msg·2 @"github.com/ethereum/go-ethereum/p2p".Msg "esc:0x1") String () (? string)
	import discover "github.com/ethereum/go-ethereum/p2p/discover" // indirect
	import ecdsa "crypto/ecdsa" // indirect
	import elliptic "crypto/elliptic" // indirect
	type @"crypto/elliptic".CurveParams struct { P *@"math/big".Int; N *@"math/big".Int; B *@"math/big".Int; Gx *@"math/big".Int; Gy *@"math/big".Int; BitSize int; Name string }
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") Add (@"crypto/elliptic".x1·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".x2·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y2·7 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") Double (@"crypto/elliptic".x1·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·5 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·2 *@"crypto/elliptic".CurveParams "esc:0x9") IsOnCurve (@"crypto/elliptic".x·3 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·4 *@"math/big".Int "esc:0x9") (? bool)
	func (@"crypto/elliptic".curve·2 *@"crypto/elliptic".CurveParams "esc:0x12") Params () (? *@"crypto/elliptic".CurveParams) { return @"crypto/elliptic".curve·2 }
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") ScalarBaseMult (@"crypto/elliptic".k·4 []byte "esc:0x1") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") ScalarMult (@"crypto/elliptic".Bx·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".By·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".k·6 []byte "esc:0x1") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·4 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".addJacobian (@"crypto/elliptic".x1·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z1·7 *@"math/big".Int "esc:0x9", @"crypto/elliptic".x2·8 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y2·9 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z2·10 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".affineFromJacobian (@"crypto/elliptic".x·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z·6 *@"math/big".Int "esc:0x9") (@"crypto/elliptic".xOut·1 *@"math/big".Int, @"crypto/elliptic".yOut·2 *@"math/big".Int)
	func (@"crypto/elliptic".curve·4 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".doubleJacobian (@"crypto/elliptic".x·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z·7 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	type @"crypto/elliptic".Curve interface { Add(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".x2 *@"math/big".Int, @"crypto/elliptic".y2 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); Double(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); IsOnCurve(@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) (? bool); Params() (? *@"crypto/elliptic".CurveParams); ScalarBaseMult(@"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); ScalarMult(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) }
	type @"crypto/ecdsa".PublicKey struct { ? @"crypto/elliptic".Curve; X *@"math/big".Int; Y *@"math/big".Int }
	type @"github.com/ethereum/go-ethereum/p2p/discover".NodeID [64]byte
	func (@"github.com/ethereum/go-ethereum/p2p/discover".n·2 @"github.com/ethereum/go-ethereum/p2p/discover".NodeID) GoString () (? string)
	func (@"github.com/ethereum/go-ethereum/p2p/discover".id·3 @"github.com/ethereum/go-ethereum/p2p/discover".NodeID) Pubkey () (? *@"crypto/ecdsa".PublicKey, ? error)
	func (@"github.com/ethereum/go-ethereum/p2p/discover".n·2 @"github.com/ethereum/go-ethereum/p2p/discover".NodeID) String () (? string)
	import crypto "crypto" // indirect
	type @"crypto".PublicKey interface {}
	import hash "hash" // indirect
	type @"hash".Hash interface { BlockSize() (? int); Reset(); Size() (? int); Sum(@"hash".b []byte) (? []byte); Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"crypto".Hash uint
	func (@"crypto".h·2 @"crypto".Hash) Available () (? bool) { return @"crypto".h·2 < @"crypto".Hash(0x10) && @"crypto".hashes[@"crypto".h·2] != nil }
	func (@"crypto".h·2 @"crypto".Hash) HashFunc () (? @"crypto".Hash) { return @"crypto".h·2 }
	func (@"crypto".h·2 @"crypto".Hash) New () (? @"hash".Hash)
	func (@"crypto".h·2 @"crypto".Hash) Size () (? int)
	type @"crypto".SignerOpts interface { HashFunc() (? @"crypto".Hash) }
	type @"crypto/ecdsa".PrivateKey struct { ? @"crypto/ecdsa".PublicKey; D *@"math/big".Int }
	func (@"crypto/ecdsa".priv·2 *@"crypto/ecdsa".PrivateKey "esc:0x12") Public () (? @"crypto".PublicKey) { return &@"crypto/ecdsa".priv·2.PublicKey }
	func (@"crypto/ecdsa".priv·3 *@"crypto/ecdsa".PrivateKey "esc:0x9") Sign (@"crypto/ecdsa".rand·4 @"io".Reader, @"crypto/ecdsa".msg·5 []byte, @"crypto/ecdsa".opts·6 @"crypto".SignerOpts "esc:0x1") (? []byte, ? error)
	type @"net".IPMask []byte
	func (@"net".m·3 @"net".IPMask "esc:0x1") Size () (@"net".ones·1 int, @"net".bits·2 int)
	func (@"net".m·2 @"net".IPMask "esc:0x1") String () (? string)
	type @"net".IP []byte
	func (@"net".ip·2 @"net".IP "esc:0x1") DefaultMask () (? @"net".IPMask)
	func (@"net".ip·2 @"net".IP "esc:0x1") Equal (@"net".x·3 @"net".IP "esc:0x1") (? bool)
	func (@"net".ip·2 @"net".IP "esc:0x1") IsGlobalUnicast () (? bool)
	func (@"net".ip·2 @"net".IP "esc:0x1") IsInterfaceLocalMulticast () (? bool) { return len(@"net".ip·2) == 0x10 && @"net".ip·2[0x0] == byte(0xff) && @"net".ip·2[0x1] & byte(0xf) == byte(0x1) }
	func (@"net".ip·2 @"net".IP "esc:0x1") IsLinkLocalMulticast () (? bool)
	func (@"net".ip·2 @"net".IP "esc:0x1") IsLinkLocalUnicast () (? bool)
	func (@"net".ip·2 @"net".IP "esc:0x1") IsLoopback () (? bool)
	func (@"net".ip·2 @"net".IP "esc:0x1") IsMulticast () (? bool)
	func (@"net".ip·2 @"net".IP "esc:0x1") IsUnspecified () (? bool)
	func (@"net".ip·3 @"net".IP "esc:0x1") MarshalText () (? []byte, ? error)
	func (@"net".ip·2 @"net".IP "esc:0x1") Mask (@"net".mask·3 @"net".IPMask "esc:0x1") (? @"net".IP)
	func (@"net".ip·2 @"net".IP "esc:0x1") String () (? string)
	func (@"net".ip·2 @"net".IP "esc:0x12") To16 () (? @"net".IP) { if len(@"net".ip·2) == 0x4 { return @"net".IPv4(@"net".ip·2[0x0], @"net".ip·2[0x1], @"net".ip·2[0x2], @"net".ip·2[0x3]) }; if len(@"net".ip·2) == 0x10 { return @"net".ip·2 }; return nil }
	func (@"net".ip·2 @"net".IP "esc:0x12") To4 () (? @"net".IP)
	func (@"net".ip·2 *@"net".IP "esc:0x1") UnmarshalText (@"net".text·3 []byte "esc:0x1") (? error)
	import syscall "syscall" // indirect
	type @"syscall"._Socklen uint32
	type @"syscall".Sockaddr interface { @"syscall".sockaddr() (@"syscall".ptr @"unsafe".Pointer, @"syscall".len @"syscall"._Socklen, @"syscall".err error) }
	type @"net".UDPAddr struct { IP @"net".IP; Port int; Zone string }
	func (@"net".a·2 *@"net".UDPAddr "esc:0x1") Network () (? string) { return "udp" }
	func (@"net".a·2 *@"net".UDPAddr "esc:0x1") String () (? string)
	func (@"net".a·2 *@"net".UDPAddr "esc:0x1") @"net".family () (? int)
	func (@"net".a·2 *@"net".UDPAddr "esc:0x1") @"net".isWildcard () (? bool)
	func (@"net".a·2 *@"net".UDPAddr "esc:0x12") @"net".opAddr () (? @"net".Addr) { if @"net".a·2 == nil { return nil }; return @"net".a·2 }
	func (@"net".a·3 *@"net".UDPAddr "esc:0x1") @"net".sockaddr (@"net".family·4 int) (? @"syscall".Sockaddr, ? error)
	type @"github.com/ethereum/go-ethereum/p2p/discover".Node struct { IP @"net".IP; UDP uint16; TCP uint16; ID @"github.com/ethereum/go-ethereum/p2p/discover".NodeID; @"github.com/ethereum/go-ethereum/p2p/discover".sha @"github.com/ethereum/go-ethereum/common".Hash; @"github.com/ethereum/go-ethereum/p2p/discover".contested bool }
	func (@"github.com/ethereum/go-ethereum/p2p/discover".n·2 *@"github.com/ethereum/go-ethereum/p2p/discover".Node) String () (? string)
	func (@"github.com/ethereum/go-ethereum/p2p/discover".n·2 *@"github.com/ethereum/go-ethereum/p2p/discover".Node "esc:0xa") @"github.com/ethereum/go-ethereum/p2p/discover".addr () (? *@"net".UDPAddr) { return (&@"net".UDPAddr{ IP:@"github.com/ethereum/go-ethereum/p2p/discover".n·2.IP, Port:int(@"github.com/ethereum/go-ethereum/p2p/discover".n·2.UDP) }) }
	type @"github.com/ethereum/go-ethereum/p2p".Cap struct { Name string; Version uint }
	func (@"github.com/ethereum/go-ethereum/p2p".cap·2 @"github.com/ethereum/go-ethereum/p2p".Cap) RlpData () (? interface {}) { return ([]interface {}{ 0x0:@"github.com/ethereum/go-ethereum/p2p".cap·2.Name, 0x1:@"github.com/ethereum/go-ethereum/p2p".cap·2.Version }) }
	func (@"github.com/ethereum/go-ethereum/p2p".cap·2 @"github.com/ethereum/go-ethereum/p2p".Cap) String () (? string)
	type @"github.com/ethereum/go-ethereum/p2p".protoHandshake struct { Version uint64; Name string; Caps []@"github.com/ethereum/go-ethereum/p2p".Cap; ListenPort uint64; ID @"github.com/ethereum/go-ethereum/p2p/discover".NodeID }
	type @"github.com/ethereum/go-ethereum/p2p".transport interface { ReadMsg() (? @"github.com/ethereum/go-ethereum/p2p".Msg, ? error); WriteMsg(? @"github.com/ethereum/go-ethereum/p2p".Msg) (? error); @"github.com/ethereum/go-ethereum/p2p".close(@"github.com/ethereum/go-ethereum/p2p".err error); @"github.com/ethereum/go-ethereum/p2p".doEncHandshake(@"github.com/ethereum/go-ethereum/p2p".prv *@"crypto/ecdsa".PrivateKey, @"github.com/ethereum/go-ethereum/p2p".dialDest *@"github.com/ethereum/go-ethereum/p2p/discover".Node) (? @"github.com/ethereum/go-ethereum/p2p/discover".NodeID, ? error); @"github.com/ethereum/go-ethereum/p2p".doProtoHandshake(@"github.com/ethereum/go-ethereum/p2p".our *@"github.com/ethereum/go-ethereum/p2p".protoHandshake) (? *@"github.com/ethereum/go-ethereum/p2p".protoHandshake, ? error) }
	type @"github.com/ethereum/go-ethereum/p2p".connFlag int
	func (@"github.com/ethereum/go-ethereum/p2p".f·2 @"github.com/ethereum/go-ethereum/p2p".connFlag) String () (? string) { var @"github.com/ethereum/go-ethereum/p2p".s·3 string; ; @"github.com/ethereum/go-ethereum/p2p".s·3 = ""; if @"github.com/ethereum/go-ethereum/p2p".f·2 & @"github.com/ethereum/go-ethereum/p2p".connFlag(0x8) != @"github.com/ethereum/go-ethereum/p2p".connFlag(0x0) { @"github.com/ethereum/go-ethereum/p2p".s·3 += " trusted" }; if @"github.com/ethereum/go-ethereum/p2p".f·2 & @"github.com/ethereum/go-ethereum/p2p".connFlag(0x1) != @"github.com/ethereum/go-ethereum/p2p".connFlag(0x0) { @"github.com/ethereum/go-ethereum/p2p".s·3 += " dyn dial" }; if @"github.com/ethereum/go-ethereum/p2p".f·2 & @"github.com/ethereum/go-ethereum/p2p".connFlag(0x2) != @"github.com/ethereum/go-ethereum/p2p".connFlag(0x0) { @"github.com/ethereum/go-ethereum/p2p".s·3 += " static dial" }; if @"github.com/ethereum/go-ethereum/p2p".f·2 & @"github.com/ethereum/go-ethereum/p2p".connFlag(0x4) != @"github.com/ethereum/go-ethereum/p2p".connFlag(0x0) { @"github.com/ethereum/go-ethereum/p2p".s·3 += " inbound" }; if @"github.com/ethereum/go-ethereum/p2p".s·3 != "" { @"github.com/ethereum/go-ethereum/p2p".s·3 = @"github.com/ethereum/go-ethereum/p2p".s·3[0x1:] }; return @"github.com/ethereum/go-ethereum/p2p".s·3 }
	type @"github.com/ethereum/go-ethereum/p2p".conn struct { @"github.com/ethereum/go-ethereum/p2p".fd @"net".Conn; @"github.com/ethereum/go-ethereum/p2p".? @"github.com/ethereum/go-ethereum/p2p".transport; @"github.com/ethereum/go-ethereum/p2p".flags @"github.com/ethereum/go-ethereum/p2p".connFlag; @"github.com/ethereum/go-ethereum/p2p".cont chan error; @"github.com/ethereum/go-ethereum/p2p".id @"github.com/ethereum/go-ethereum/p2p/discover".NodeID; @"github.com/ethereum/go-ethereum/p2p".caps []@"github.com/ethereum/go-ethereum/p2p".Cap; @"github.com/ethereum/go-ethereum/p2p".name string }
	func (@"github.com/ethereum/go-ethereum/p2p".c·2 *@"github.com/ethereum/go-ethereum/p2p".conn) String () (? string)
	func (@"github.com/ethereum/go-ethereum/p2p".c·2 *@"github.com/ethereum/go-ethereum/p2p".conn "esc:0x1") @"github.com/ethereum/go-ethereum/p2p".is (@"github.com/ethereum/go-ethereum/p2p".f·3 @"github.com/ethereum/go-ethereum/p2p".connFlag) (? bool) { return @"github.com/ethereum/go-ethereum/p2p".c·2.@"github.com/ethereum/go-ethereum/p2p".flags & @"github.com/ethereum/go-ethereum/p2p".f·3 != @"github.com/ethereum/go-ethereum/p2p".connFlag(0x0) }
	type @"github.com/ethereum/go-ethereum/p2p".MsgWriter interface { WriteMsg(? @"github.com/ethereum/go-ethereum/p2p".Msg) (? error) }
	type @"github.com/ethereum/go-ethereum/p2p".protoRW struct { ? @"github.com/ethereum/go-ethereum/p2p".Protocol; @"github.com/ethereum/go-ethereum/p2p".in chan @"github.com/ethereum/go-ethereum/p2p".Msg; @"github.com/ethereum/go-ethereum/p2p".closed <-chan struct {}; @"github.com/ethereum/go-ethereum/p2p".wstart <-chan struct {}; @"github.com/ethereum/go-ethereum/p2p".werr chan<- error; @"github.com/ethereum/go-ethereum/p2p".offset uint64; @"github.com/ethereum/go-ethereum/p2p".w @"github.com/ethereum/go-ethereum/p2p".MsgWriter }
	func (@"github.com/ethereum/go-ethereum/p2p".rw·3 *@"github.com/ethereum/go-ethereum/p2p".protoRW "esc:0x1") ReadMsg () (? @"github.com/ethereum/go-ethereum/p2p".Msg, ? error)
	func (@"github.com/ethereum/go-ethereum/p2p".rw·2 *@"github.com/ethereum/go-ethereum/p2p".protoRW "esc:0x9") WriteMsg (@"github.com/ethereum/go-ethereum/p2p".msg·3 @"github.com/ethereum/go-ethereum/p2p".Msg) (@"github.com/ethereum/go-ethereum/p2p".err·1 error)
	type @"sync".WaitGroup struct { @"sync".state1 [12]byte; @"sync".sema uint32 }
	func (@"sync".wg·1 *@"sync".WaitGroup) Add (@"sync".delta·2 int)
	func (@"sync".wg·1 *@"sync".WaitGroup) Done ()
	func (@"sync".wg·1 *@"sync".WaitGroup) Wait ()
	func (@"sync".wg·2 *@"sync".WaitGroup "esc:0x12") @"sync".state () (? *uint64) { if uintptr(@"unsafe".Pointer(&@"sync".wg·2.@"sync".state1)) % 0x8 == 0x0 { return (*uint64)(@"unsafe".Pointer(&@"sync".wg·2.@"sync".state1)) } else { return (*uint64)(@"unsafe".Pointer(&@"sync".wg·2.@"sync".state1[0x4])) } }
	type @"github.com/ethereum/go-ethereum/p2p".DiscReason uint
	func (@"github.com/ethereum/go-ethereum/p2p".d·2 @"github.com/ethereum/go-ethereum/p2p".DiscReason) Error () (? string)
	func (@"github.com/ethereum/go-ethereum/p2p".d·2 @"github.com/ethereum/go-ethereum/p2p".DiscReason) String () (? string)
	type @"github.com/ethereum/go-ethereum/p2p".PeerInfo struct { ID string "json:\"id\""; Name string "json:\"name\""; Caps []string "json:\"caps\""; Network struct { LocalAddress string "json:\"localAddress\""; RemoteAddress string "json:\"remoteAddress\"" } "json:\"network\""; Protocols map[string]interface {} "json:\"protocols\"" }
	type @"github.com/ethereum/go-ethereum/p2p".Peer struct { @"github.com/ethereum/go-ethereum/p2p".rw *@"github.com/ethereum/go-ethereum/p2p".conn; @"github.com/ethereum/go-ethereum/p2p".running map[string]*@"github.com/ethereum/go-ethereum/p2p".protoRW; @"github.com/ethereum/go-ethereum/p2p".wg @"sync".WaitGroup; @"github.com/ethereum/go-ethereum/p2p".protoErr chan error; @"github.com/ethereum/go-ethereum/p2p".closed chan struct {}; @"github.com/ethereum/go-ethereum/p2p".disc chan @"github.com/ethereum/go-ethereum/p2p".DiscReason }
	func (@"github.com/ethereum/go-ethereum/p2p".p·2 *@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x32") Caps () (? []@"github.com/ethereum/go-ethereum/p2p".Cap) { return @"github.com/ethereum/go-ethereum/p2p".p·2.@"github.com/ethereum/go-ethereum/p2p".rw.@"github.com/ethereum/go-ethereum/p2p".caps }
	func (@"github.com/ethereum/go-ethereum/p2p".p·1 *@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x1") Disconnect (@"github.com/ethereum/go-ethereum/p2p".reason·2 @"github.com/ethereum/go-ethereum/p2p".DiscReason)
	func (@"github.com/ethereum/go-ethereum/p2p".p·2 *@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x1") ID () (? @"github.com/ethereum/go-ethereum/p2p/discover".NodeID) { return @"github.com/ethereum/go-ethereum/p2p".p·2.@"github.com/ethereum/go-ethereum/p2p".rw.@"github.com/ethereum/go-ethereum/p2p".id }
	func (@"github.com/ethereum/go-ethereum/p2p".p·2 *@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x2a") Info () (? *@"github.com/ethereum/go-ethereum/p2p".PeerInfo)
	func (@"github.com/ethereum/go-ethereum/p2p".p·2 *@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x9") LocalAddr () (? @"net".Addr)
	func (@"github.com/ethereum/go-ethereum/p2p".p·2 *@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x32") Name () (? string) { return @"github.com/ethereum/go-ethereum/p2p".p·2.@"github.com/ethereum/go-ethereum/p2p".rw.@"github.com/ethereum/go-ethereum/p2p".name }
	func (@"github.com/ethereum/go-ethereum/p2p".p·2 *@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x9") RemoteAddr () (? @"net".Addr)
	func (@"github.com/ethereum/go-ethereum/p2p".p·2 *@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x9") String () (? string)
	func (@"github.com/ethereum/go-ethereum/p2p".p·3 *@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x32") @"github.com/ethereum/go-ethereum/p2p".getProto (@"github.com/ethereum/go-ethereum/p2p".code·4 uint64) (? *@"github.com/ethereum/go-ethereum/p2p".protoRW, ? error)
	func (@"github.com/ethereum/go-ethereum/p2p".p·2 *@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x9") @"github.com/ethereum/go-ethereum/p2p".handle (@"github.com/ethereum/go-ethereum/p2p".msg·3 @"github.com/ethereum/go-ethereum/p2p".Msg) (? error)
	func (@"github.com/ethereum/go-ethereum/p2p".p·1 *@"github.com/ethereum/go-ethereum/p2p".Peer) @"github.com/ethereum/go-ethereum/p2p".pingLoop ()
	func (@"github.com/ethereum/go-ethereum/p2p".p·1 *@"github.com/ethereum/go-ethereum/p2p".Peer) @"github.com/ethereum/go-ethereum/p2p".readLoop (@"github.com/ethereum/go-ethereum/p2p".errc·2 chan<- error "esc:0x1")
	func (@"github.com/ethereum/go-ethereum/p2p".p·2 *@"github.com/ethereum/go-ethereum/p2p".Peer) @"github.com/ethereum/go-ethereum/p2p".run () (? @"github.com/ethereum/go-ethereum/p2p".DiscReason)
	func (@"github.com/ethereum/go-ethereum/p2p".p·1 *@"github.com/ethereum/go-ethereum/p2p".Peer) @"github.com/ethereum/go-ethereum/p2p".startProtocols (@"github.com/ethereum/go-ethereum/p2p".writeStart·2 <-chan struct {}, @"github.com/ethereum/go-ethereum/p2p".writeErr·3 chan<- error)
	type @"github.com/ethereum/go-ethereum/p2p".MsgReadWriter interface { ReadMsg() (? @"github.com/ethereum/go-ethereum/p2p".Msg, ? error); WriteMsg(? @"github.com/ethereum/go-ethereum/p2p".Msg) (? error) }
	type @"github.com/ethereum/go-ethereum/p2p".Protocol struct { Name string; Version uint; Length uint64; Run func(@"github.com/ethereum/go-ethereum/p2p".peer *@"github.com/ethereum/go-ethereum/p2p".Peer, @"github.com/ethereum/go-ethereum/p2p".rw @"github.com/ethereum/go-ethereum/p2p".MsgReadWriter) (? error); NodeInfo func() (? interface {}); PeerInfo func(@"github.com/ethereum/go-ethereum/p2p".id @"github.com/ethereum/go-ethereum/p2p/discover".NodeID) (? interface {}) }
	func (@"github.com/ethereum/go-ethereum/p2p".p·2 @"github.com/ethereum/go-ethereum/p2p".Protocol "esc:0x12") @"github.com/ethereum/go-ethereum/p2p".cap () (? @"github.com/ethereum/go-ethereum/p2p".Cap) { return (@"github.com/ethereum/go-ethereum/p2p".Cap{ Name:@"github.com/ethereum/go-ethereum/p2p".p·2.Name, Version:@"github.com/ethereum/go-ethereum/p2p".p·2.Version }) }
	import filter "github.com/ethereum/go-ethereum/event/filter" // indirect
	type @"github.com/ethereum/go-ethereum/event/filter".Filter interface { Compare(? @"github.com/ethereum/go-ethereum/event/filter".Filter) (? bool); Trigger(@"github.com/ethereum/go-ethereum/event/filter".data interface {}) }
	type @"github.com/ethereum/go-ethereum/event/filter".FilterEvent struct { @"github.com/ethereum/go-ethereum/event/filter".filter @"github.com/ethereum/go-ethereum/event/filter".Filter; @"github.com/ethereum/go-ethereum/event/filter".data interface {} }
	type @"github.com/ethereum/go-ethereum/event/filter".Filters struct { @"github.com/ethereum/go-ethereum/event/filter".id int; @"github.com/ethereum/go-ethereum/event/filter".watchers map[int]@"github.com/ethereum/go-ethereum/event/filter".Filter; @"github.com/ethereum/go-ethereum/event/filter".ch chan @"github.com/ethereum/go-ethereum/event/filter".FilterEvent; @"github.com/ethereum/go-ethereum/event/filter".quit chan struct {} }
	func (@"github.com/ethereum/go-ethereum/event/filter".self·2 *@"github.com/ethereum/go-ethereum/event/filter".Filters "esc:0x1") Get (@"github.com/ethereum/go-ethereum/event/filter".i·3 int) (? @"github.com/ethereum/go-ethereum/event/filter".Filter) { return @"github.com/ethereum/go-ethereum/event/filter".self·2.@"github.com/ethereum/go-ethereum/event/filter".watchers[@"github.com/ethereum/go-ethereum/event/filter".i·3] }
	func (@"github.com/ethereum/go-ethereum/event/filter".self·2 *@"github.com/ethereum/go-ethereum/event/filter".Filters "esc:0x1") Install (@"github.com/ethereum/go-ethereum/event/filter".watcher·3 @"github.com/ethereum/go-ethereum/event/filter".Filter) (? int) { @"github.com/ethereum/go-ethereum/event/filter".self·2.@"github.com/ethereum/go-ethereum/event/filter".watchers[@"github.com/ethereum/go-ethereum/event/filter".self·2.@"github.com/ethereum/go-ethereum/event/filter".id] = @"github.com/ethereum/go-ethereum/event/filter".watcher·3; @"github.com/ethereum/go-ethereum/event/filter".self·2.@"github.com/ethereum/go-ethereum/event/filter".id++; return @"github.com/ethereum/go-ethereum/event/filter".self·2.@"github.com/ethereum/go-ethereum/event/filter".id - 0x1 }
	func (@"github.com/ethereum/go-ethereum/event/filter".self·2 *@"github.com/ethereum/go-ethereum/event/filter".Filters "esc:0x1") Match (@"github.com/ethereum/go-ethereum/event/filter".a·3 @"github.com/ethereum/go-ethereum/event/filter".Filter, @"github.com/ethereum/go-ethereum/event/filter".b·4 @"github.com/ethereum/go-ethereum/event/filter".Filter) (? bool)
	func (@"github.com/ethereum/go-ethereum/event/filter".self·1 *@"github.com/ethereum/go-ethereum/event/filter".Filters "esc:0x1") Notify (@"github.com/ethereum/go-ethereum/event/filter".filter·2 @"github.com/ethereum/go-ethereum/event/filter".Filter, @"github.com/ethereum/go-ethereum/event/filter".data·3 interface {}) { @"github.com/ethereum/go-ethereum/event/filter".self·1.@"github.com/ethereum/go-ethereum/event/filter".ch <- (@"github.com/ethereum/go-ethereum/event/filter".FilterEvent{ @"github.com/ethereum/go-ethereum/event/filter".filter:@"github.com/ethereum/go-ethereum/event/filter".filter·2, @"github.com/ethereum/go-ethereum/event/filter".data:@"github.com/ethereum/go-ethereum/event/filter".data·3 }) }
	func (@"github.com/ethereum/go-ethereum/event/filter".self·1 *@"github.com/ethereum/go-ethereum/event/filter".Filters) Start ()
	func (@"github.com/ethereum/go-ethereum/event/filter".self·1 *@"github.com/ethereum/go-ethereum/event/filter".Filters "esc:0x1") Stop () { close(@"github.com/ethereum/go-ethereum/event/filter".self·1.@"github.com/ethereum/go-ethereum/event/filter".quit) }
	func (@"github.com/ethereum/go-ethereum/event/filter".self·1 *@"github.com/ethereum/go-ethereum/event/filter".Filters "esc:0x1") Uninstall (@"github.com/ethereum/go-ethereum/event/filter".id·2 int) { delete(@"github.com/ethereum/go-ethereum/event/filter".self·1.@"github.com/ethereum/go-ethereum/event/filter".watchers, @"github.com/ethereum/go-ethereum/event/filter".id·2) }
	func (@"github.com/ethereum/go-ethereum/event/filter".self·1 *@"github.com/ethereum/go-ethereum/event/filter".Filters "esc:0x9") @"github.com/ethereum/go-ethereum/event/filter".loop ()
	type @"github.com/ethereum/go-ethereum/whisper".Topic [4]byte
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Topic "esc:0x1") String () (? string) { return string(@"github.com/ethereum/go-ethereum/whisper".self·2[:]) }
	type @"github.com/ethereum/go-ethereum/whisper".Options struct { From *@"crypto/ecdsa".PrivateKey; To *@"crypto/ecdsa".PublicKey; TTL @"time".Duration; Topics []@"github.com/ethereum/go-ethereum/whisper".Topic }
	type @"github.com/ethereum/go-ethereum/whisper".Message struct { Flags byte; Signature []byte; Payload []byte; Sent @"time".Time; TTL @"time".Duration; To *@"crypto/ecdsa".PublicKey; Hash @"github.com/ethereum/go-ethereum/common".Hash }
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Message) Recover () (? *@"crypto/ecdsa".PublicKey)
	func (@"github.com/ethereum/go-ethereum/whisper".self·3 *@"github.com/ethereum/go-ethereum/whisper".Message) Wrap (@"github.com/ethereum/go-ethereum/whisper".pow·4 @"time".Duration, @"github.com/ethereum/go-ethereum/whisper".options·5 @"github.com/ethereum/go-ethereum/whisper".Options) (? *@"github.com/ethereum/go-ethereum/whisper".Envelope, ? error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Message "esc:0x1a") @"github.com/ethereum/go-ethereum/whisper".bytes () (? []byte) { return append(([]byte{ 0x0:@"github.com/ethereum/go-ethereum/whisper".self·2.Flags }), append(@"github.com/ethereum/go-ethereum/whisper".self·2.Signature, @"github.com/ethereum/go-ethereum/whisper".self·2.Payload...)...) }
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Message "esc:0x9") @"github.com/ethereum/go-ethereum/whisper".decrypt (@"github.com/ethereum/go-ethereum/whisper".key·3 *@"crypto/ecdsa".PrivateKey "esc:0x9") (? error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Message "esc:0x9") @"github.com/ethereum/go-ethereum/whisper".encrypt (@"github.com/ethereum/go-ethereum/whisper".key·3 *@"crypto/ecdsa".PublicKey "esc:0x9") (@"github.com/ethereum/go-ethereum/whisper".err·1 error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Message) @"github.com/ethereum/go-ethereum/whisper".hash () (? []byte)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Message) @"github.com/ethereum/go-ethereum/whisper".sign (@"github.com/ethereum/go-ethereum/whisper".key·3 *@"crypto/ecdsa".PrivateKey "esc:0x9") (@"github.com/ethereum/go-ethereum/whisper".err·1 error)
	type @"github.com/ethereum/go-ethereum/whisper".Envelope struct { Expiry uint32; TTL uint32; Topics []@"github.com/ethereum/go-ethereum/whisper".Topic; Data []byte; Nonce uint32; @"github.com/ethereum/go-ethereum/whisper".hash @"github.com/ethereum/go-ethereum/common".Hash }
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Envelope) DecodeRLP (@"github.com/ethereum/go-ethereum/whisper".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream) (? error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Envelope) Hash () (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/whisper".self·3 *@"github.com/ethereum/go-ethereum/whisper".Envelope) Open (@"github.com/ethereum/go-ethereum/whisper".key·4 *@"crypto/ecdsa".PrivateKey "esc:0x9") (@"github.com/ethereum/go-ethereum/whisper".msg·1 *@"github.com/ethereum/go-ethereum/whisper".Message, @"github.com/ethereum/go-ethereum/whisper".err·2 error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·1 *@"github.com/ethereum/go-ethereum/whisper".Envelope "esc:0x9") Seal (@"github.com/ethereum/go-ethereum/whisper".pow·2 @"time".Duration)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Envelope "esc:0x9") @"github.com/ethereum/go-ethereum/whisper".rlpWithoutNonce () (? []byte)
	import set "gopkg.in/fatih/set.v0" // indirect
	type @"gopkg.in/fatih/set.v0".Interface interface { Add(@"gopkg.in/fatih/set.v0".items ...interface {}); Clear(); Copy() (? @"gopkg.in/fatih/set.v0".Interface); Each(? func(? interface {}) (? bool)); Has(@"gopkg.in/fatih/set.v0".items ...interface {}) (? bool); IsEmpty() (? bool); IsEqual(@"gopkg.in/fatih/set.v0".s @"gopkg.in/fatih/set.v0".Interface) (? bool); IsSubset(@"gopkg.in/fatih/set.v0".s @"gopkg.in/fatih/set.v0".Interface) (? bool); IsSuperset(@"gopkg.in/fatih/set.v0".s @"gopkg.in/fatih/set.v0".Interface) (? bool); List() (? []interface {}); Merge(@"gopkg.in/fatih/set.v0".s @"gopkg.in/fatih/set.v0".Interface); New(@"gopkg.in/fatih/set.v0".items ...interface {}) (? @"gopkg.in/fatih/set.v0".Interface); Pop() (? interface {}); Remove(@"gopkg.in/fatih/set.v0".items ...interface {}); Separate(@"gopkg.in/fatih/set.v0".s @"gopkg.in/fatih/set.v0".Interface); Size() (? int); String() (? string) }
	type @"gopkg.in/fatih/set.v0".set struct { @"gopkg.in/fatih/set.v0".m map[interface {}]struct {} }
	func (@"gopkg.in/fatih/set.v0".s·1 *@"gopkg.in/fatih/set.v0".set "esc:0x1") Add (@"gopkg.in/fatih/set.v0".items·2 ...interface {} "esc:0x9")
	func (@"gopkg.in/fatih/set.v0".s·1 *@"gopkg.in/fatih/set.v0".set "esc:0x1") Clear () { @"gopkg.in/fatih/set.v0".s·1.@"gopkg.in/fatih/set.v0".m = make(map[interface {}]struct {}) }
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".set "esc:0x1") Copy () (? @"gopkg.in/fatih/set.v0".Interface)
	func (@"gopkg.in/fatih/set.v0".s·1 *@"gopkg.in/fatih/set.v0".set "esc:0x1") Each (@"gopkg.in/fatih/set.v0".f·2 func(@"gopkg.in/fatih/set.v0".item interface {}) (? bool) "esc:0x1")
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".set "esc:0x1") Has (@"gopkg.in/fatih/set.v0".items·3 ...interface {} "esc:0x1") (? bool)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".set "esc:0x1") IsEmpty () (? bool) { return @"gopkg.in/fatih/set.v0".s·2.Size() == 0x0 }
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".set) IsEqual (@"gopkg.in/fatih/set.v0".t·3 @"gopkg.in/fatih/set.v0".Interface) (? bool)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".set) IsSubset (@"gopkg.in/fatih/set.v0".t·3 @"gopkg.in/fatih/set.v0".Interface) (@"gopkg.in/fatih/set.v0".subset·1 bool)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".set) IsSuperset (@"gopkg.in/fatih/set.v0".t·3 @"gopkg.in/fatih/set.v0".Interface) (? bool)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".set "esc:0x1") List () (? []interface {})
	func (@"gopkg.in/fatih/set.v0".s·1 *@"gopkg.in/fatih/set.v0".set) Merge (@"gopkg.in/fatih/set.v0".t·2 @"gopkg.in/fatih/set.v0".Interface)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".set "esc:0x1") New (@"gopkg.in/fatih/set.v0".items·3 ...interface {} "esc:0x9") (? @"gopkg.in/fatih/set.v0".Interface)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".set "esc:0x1") Pop () (? interface {})
	func (@"gopkg.in/fatih/set.v0".s·1 *@"gopkg.in/fatih/set.v0".set "esc:0x1") Remove (@"gopkg.in/fatih/set.v0".items·2 ...interface {} "esc:0x1")
	func (@"gopkg.in/fatih/set.v0".s·1 *@"gopkg.in/fatih/set.v0".set "esc:0x1") Separate (@"gopkg.in/fatih/set.v0".t·2 @"gopkg.in/fatih/set.v0".Interface)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".set "esc:0x1") Size () (? int) { return len(@"gopkg.in/fatih/set.v0".s·2.@"gopkg.in/fatih/set.v0".m) }
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".set "esc:0x1") String () (? string)
	type @"gopkg.in/fatih/set.v0".SetNonTS struct { @"gopkg.in/fatih/set.v0".? @"gopkg.in/fatih/set.v0".set }
	type @"gopkg.in/fatih/set.v0".Set struct { @"gopkg.in/fatih/set.v0".? @"gopkg.in/fatih/set.v0".set; @"gopkg.in/fatih/set.v0".l @"sync".RWMutex }
	func (@"gopkg.in/fatih/set.v0".s·1 *@"gopkg.in/fatih/set.v0".Set) Add (@"gopkg.in/fatih/set.v0".items·2 ...interface {} "esc:0x9")
	func (@"gopkg.in/fatih/set.v0".s·1 *@"gopkg.in/fatih/set.v0".Set) Clear ()
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".Set) Copy () (? @"gopkg.in/fatih/set.v0".Interface)
	func (@"gopkg.in/fatih/set.v0".s·1 *@"gopkg.in/fatih/set.v0".Set) Each (@"gopkg.in/fatih/set.v0".f·2 func(@"gopkg.in/fatih/set.v0".item interface {}) (? bool) "esc:0x1")
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".Set) Has (@"gopkg.in/fatih/set.v0".items·3 ...interface {} "esc:0x1") (? bool)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".Set) IsEqual (@"gopkg.in/fatih/set.v0".t·3 @"gopkg.in/fatih/set.v0".Interface) (? bool)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".Set) IsSubset (@"gopkg.in/fatih/set.v0".t·3 @"gopkg.in/fatih/set.v0".Interface) (@"gopkg.in/fatih/set.v0".subset·1 bool)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".Set) List () (? []interface {})
	func (@"gopkg.in/fatih/set.v0".s·1 *@"gopkg.in/fatih/set.v0".Set) Merge (@"gopkg.in/fatih/set.v0".t·2 @"gopkg.in/fatih/set.v0".Interface)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".Set "esc:0x1") New (@"gopkg.in/fatih/set.v0".items·3 ...interface {} "esc:0x9") (? @"gopkg.in/fatih/set.v0".Interface)
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".Set) Pop () (? interface {})
	func (@"gopkg.in/fatih/set.v0".s·1 *@"gopkg.in/fatih/set.v0".Set) Remove (@"gopkg.in/fatih/set.v0".items·2 ...interface {} "esc:0x1")
	func (@"gopkg.in/fatih/set.v0".s·2 *@"gopkg.in/fatih/set.v0".Set) Size () (? int)
	type @"github.com/ethereum/go-ethereum/whisper".peer struct { @"github.com/ethereum/go-ethereum/whisper".host *@"github.com/ethereum/go-ethereum/whisper".Whisper; @"github.com/ethereum/go-ethereum/whisper".peer *@"github.com/ethereum/go-ethereum/p2p".Peer; @"github.com/ethereum/go-ethereum/whisper".ws @"github.com/ethereum/go-ethereum/p2p".MsgReadWriter; @"github.com/ethereum/go-ethereum/whisper".known *@"gopkg.in/fatih/set.v0".Set; @"github.com/ethereum/go-ethereum/whisper".quit chan struct {} }
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".peer "esc:0x9") @"github.com/ethereum/go-ethereum/whisper".broadcast () (? error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·1 *@"github.com/ethereum/go-ethereum/whisper".peer "esc:0x9") @"github.com/ethereum/go-ethereum/whisper".expire ()
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".peer) @"github.com/ethereum/go-ethereum/whisper".handshake () (? error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·1 *@"github.com/ethereum/go-ethereum/whisper".peer "esc:0x9") @"github.com/ethereum/go-ethereum/whisper".mark (@"github.com/ethereum/go-ethereum/whisper".envelope·2 *@"github.com/ethereum/go-ethereum/whisper".Envelope)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".peer "esc:0x9") @"github.com/ethereum/go-ethereum/whisper".marked (@"github.com/ethereum/go-ethereum/whisper".envelope·3 *@"github.com/ethereum/go-ethereum/whisper".Envelope) (? bool)
	func (@"github.com/ethereum/go-ethereum/whisper".self·1 *@"github.com/ethereum/go-ethereum/whisper".peer) @"github.com/ethereum/go-ethereum/whisper".start ()
	func (@"github.com/ethereum/go-ethereum/whisper".self·1 *@"github.com/ethereum/go-ethereum/whisper".peer "esc:0x9") @"github.com/ethereum/go-ethereum/whisper".stop ()
	func (@"github.com/ethereum/go-ethereum/whisper".self·1 *@"github.com/ethereum/go-ethereum/whisper".peer "esc:0x9") @"github.com/ethereum/go-ethereum/whisper".update ()
	import nat "github.com/ethereum/go-ethereum/p2p/nat" // indirect
	type @"github.com/ethereum/go-ethereum/p2p/nat".Interface interface { AddMapping(@"github.com/ethereum/go-ethereum/p2p/nat".protocol string, @"github.com/ethereum/go-ethereum/p2p/nat".extport int, @"github.com/ethereum/go-ethereum/p2p/nat".intport int, @"github.com/ethereum/go-ethereum/p2p/nat".name string, @"github.com/ethereum/go-ethereum/p2p/nat".lifetime @"time".Duration) (? error); DeleteMapping(@"github.com/ethereum/go-ethereum/p2p/nat".protocol string, @"github.com/ethereum/go-ethereum/p2p/nat".extport int, @"github.com/ethereum/go-ethereum/p2p/nat".intport int) (? error); ExternalIP() (? @"net".IP, ? error); String() (? string) }
	type @"net".dnsMsgHdr struct { @"net".id uint16; @"net".response bool; @"net".opcode int; @"net".authoritative bool; @"net".truncated bool; @"net".recursion_desired bool; @"net".recursion_available bool; @"net".rcode int }
	func (@"net".h·2 *@"net".dnsMsgHdr) Walk (@"net".f·3 func(@"net".v interface {}, @"net".name string, @"net".tag string) (? bool) "esc:0x1") (? bool)
	type @"net".dnsQuestion struct { Name string "net:\"domain-name\""; Qtype uint16; Qclass uint16 }
	func (@"net".q·2 *@"net".dnsQuestion) Walk (@"net".f·3 func(@"net".v interface {}, @"net".name string, @"net".tag string) (? bool) "esc:0x1") (? bool)
	type @"net".dnsRR_Header struct { Name string "net:\"domain-name\""; Rrtype uint16; Class uint16; Ttl uint32; Rdlength uint16 }
	func (@"net".h·2 *@"net".dnsRR_Header "esc:0x12") Header () (? *@"net".dnsRR_Header) { return @"net".h·2 }
	func (@"net".h·2 *@"net".dnsRR_Header) Walk (@"net".f·3 func(@"net".v interface {}, @"net".name string, @"net".tag string) (? bool) "esc:0x1") (? bool)
	type @"net".dnsRR interface { Header() (? *@"net".dnsRR_Header); Walk(@"net".f func(@"net".v interface {}, @"net".name string, @"net".tag string) (@"net".ok bool)) (@"net".ok bool) }
	type @"net".dnsMsg struct { @"net".? @"net".dnsMsgHdr; @"net".question []@"net".dnsQuestion; @"net".answer []@"net".dnsRR; @"net".ns []@"net".dnsRR; @"net".extra []@"net".dnsRR }
	func (@"net".dns·3 *@"net".dnsMsg "esc:0x9") Pack () (@"net".msg·1 []byte, @"net".ok·2 bool)
	func (@"net".dns·2 *@"net".dnsMsg) String () (? string)
	func (@"net".dns·2 *@"net".dnsMsg "esc:0x9") Unpack (@"net".msg·3 []byte) (? bool)
	type @"net".dnsConn interface { Close() (? error); LocalAddr() (? @"net".Addr); Read(@"net".b []byte) (@"net".n int, @"net".err error); RemoteAddr() (? @"net".Addr); SetDeadline(@"net".t @"time".Time) (? error); SetReadDeadline(@"net".t @"time".Time) (? error); SetWriteDeadline(@"net".t @"time".Time) (? error); Write(@"net".b []byte) (@"net".n int, @"net".err error); @"net".readDNSResponse() (? *@"net".dnsMsg, ? error); @"net".writeDNSQuery(? *@"net".dnsMsg) (? error) }
	type @"net".Dialer struct { Timeout @"time".Duration; Deadline @"time".Time; LocalAddr @"net".Addr; DualStack bool; FallbackDelay @"time".Duration; KeepAlive @"time".Duration }
	func (@"net".d·3 *@"net".Dialer "esc:0x9") Dial (@"net".network·4 string, @"net".address·5 string) (? @"net".Conn, ? error)
	func (@"net".d·2 *@"net".Dialer "esc:0x22") @"net".deadline (@"net".now·3 @"time".Time "esc:0x12") (? @"time".Time) { if @"net".d·2.Timeout == @"time".Duration(0x0) { return @"net".d·2.Deadline }; var @"net".timeoutDeadline·4 @"time".Time; ; @"net".timeoutDeadline·4 = @"net".now·3.Add(@"net".d·2.Timeout); if @"net".d·2.Deadline.IsZero() || @"net".timeoutDeadline·4.Before(@"net".d·2.Deadline) { return @"net".timeoutDeadline·4 } else { return @"net".d·2.Deadline } }
	func (@"net".d·3 *@"net".Dialer "esc:0x9") @"net".dialDNS (@"net".network·4 string, @"net".server·5 string) (? @"net".dnsConn, ? error)
	func (@"net".d·2 *@"net".Dialer "esc:0x1") @"net".fallbackDelay () (? @"time".Duration) { if @"net".d·2.FallbackDelay > @"time".Duration(0x0) { return @"net".d·2.FallbackDelay } else { return @"time".Duration(0x11e1a300) } }
	type @"github.com/ethereum/go-ethereum/p2p".discoverTable interface { Bootstrap(? []*@"github.com/ethereum/go-ethereum/p2p/discover".Node); Close(); Lookup(@"github.com/ethereum/go-ethereum/p2p".target @"github.com/ethereum/go-ethereum/p2p/discover".NodeID) (? []*@"github.com/ethereum/go-ethereum/p2p/discover".Node); ReadRandomNodes(? []*@"github.com/ethereum/go-ethereum/p2p/discover".Node) (? int); Self() (? *@"github.com/ethereum/go-ethereum/p2p/discover".Node) }
	type @"net".Listener interface { Accept() (@"net".c @"net".Conn, @"net".err error); Addr() (? @"net".Addr); Close() (? error) }
	type @"github.com/ethereum/go-ethereum/p2p".peerOpFunc func(? map[@"github.com/ethereum/go-ethereum/p2p/discover".NodeID]*@"github.com/ethereum/go-ethereum/p2p".Peer)
	type @"github.com/ethereum/go-ethereum/p2p".NodeInfo struct { ID string "json:\"id\""; Name string "json:\"name\""; Enode string "json:\"enode\""; IP string "json:\"ip\""; Ports struct { Discovery int "json:\"discovery\""; Listener int "json:\"listener\"" } "json:\"ports\""; ListenAddr string "json:\"listenAddr\""; Protocols map[string]interface {} "json:\"protocols\"" }
	type @"github.com/ethereum/go-ethereum/p2p".task interface { Do(? *@"github.com/ethereum/go-ethereum/p2p".Server) }
	type @"github.com/ethereum/go-ethereum/p2p".dialer interface { @"github.com/ethereum/go-ethereum/p2p".addStatic(? *@"github.com/ethereum/go-ethereum/p2p/discover".Node); @"github.com/ethereum/go-ethereum/p2p".newTasks(@"github.com/ethereum/go-ethereum/p2p".running int, @"github.com/ethereum/go-ethereum/p2p".peers map[@"github.com/ethereum/go-ethereum/p2p/discover".NodeID]*@"github.com/ethereum/go-ethereum/p2p".Peer, @"github.com/ethereum/go-ethereum/p2p".now @"time".Time) (? []@"github.com/ethereum/go-ethereum/p2p".task); @"github.com/ethereum/go-ethereum/p2p".taskDone(? @"github.com/ethereum/go-ethereum/p2p".task, ? @"time".Time) }
	type @"github.com/ethereum/go-ethereum/p2p".Server struct { PrivateKey *@"crypto/ecdsa".PrivateKey; MaxPeers int; MaxPendingPeers int; Discovery bool; Name string; BootstrapNodes []*@"github.com/ethereum/go-ethereum/p2p/discover".Node; StaticNodes []*@"github.com/ethereum/go-ethereum/p2p/discover".Node; TrustedNodes []*@"github.com/ethereum/go-ethereum/p2p/discover".Node; NodeDatabase string; Protocols []@"github.com/ethereum/go-ethereum/p2p".Protocol; ListenAddr string; NAT @"github.com/ethereum/go-ethereum/p2p/nat".Interface; Dialer *@"net".Dialer; NoDial bool; @"github.com/ethereum/go-ethereum/p2p".newTransport func(? @"net".Conn) (? @"github.com/ethereum/go-ethereum/p2p".transport); @"github.com/ethereum/go-ethereum/p2p".newPeerHook func(? *@"github.com/ethereum/go-ethereum/p2p".Peer); @"github.com/ethereum/go-ethereum/p2p".lock @"sync".Mutex; @"github.com/ethereum/go-ethereum/p2p".running bool; @"github.com/ethereum/go-ethereum/p2p".ntab @"github.com/ethereum/go-ethereum/p2p".discoverTable; @"github.com/ethereum/go-ethereum/p2p".listener @"net".Listener; @"github.com/ethereum/go-ethereum/p2p".ourHandshake *@"github.com/ethereum/go-ethereum/p2p".protoHandshake; @"github.com/ethereum/go-ethereum/p2p".lastLookup @"time".Time; @"github.com/ethereum/go-ethereum/p2p".peerOp chan @"github.com/ethereum/go-ethereum/p2p".peerOpFunc; @"github.com/ethereum/go-ethereum/p2p".peerOpDone chan struct {}; @"github.com/ethereum/go-ethereum/p2p".quit chan struct {}; @"github.com/ethereum/go-ethereum/p2p".addstatic chan *@"github.com/ethereum/go-ethereum/p2p/discover".Node; @"github.com/ethereum/go-ethereum/p2p".posthandshake chan *@"github.com/ethereum/go-ethereum/p2p".conn; @"github.com/ethereum/go-ethereum/p2p".addpeer chan *@"github.com/ethereum/go-ethereum/p2p".conn; @"github.com/ethereum/go-ethereum/p2p".delpeer chan *@"github.com/ethereum/go-ethereum/p2p".Peer; @"github.com/ethereum/go-ethereum/p2p".loopWG @"sync".WaitGroup }
	func (@"github.com/ethereum/go-ethereum/p2p".srv·1 *@"github.com/ethereum/go-ethereum/p2p".Server "esc:0x1") AddPeer (@"github.com/ethereum/go-ethereum/p2p".node·2 *@"github.com/ethereum/go-ethereum/p2p/discover".Node)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·2 *@"github.com/ethereum/go-ethereum/p2p".Server) NodeInfo () (? *@"github.com/ethereum/go-ethereum/p2p".NodeInfo)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·2 *@"github.com/ethereum/go-ethereum/p2p".Server "esc:0x1") PeerCount () (? int)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·2 *@"github.com/ethereum/go-ethereum/p2p".Server "esc:0x1") Peers () (? []*@"github.com/ethereum/go-ethereum/p2p".Peer)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·2 *@"github.com/ethereum/go-ethereum/p2p".Server "esc:0x1") PeersInfo () (? []*@"github.com/ethereum/go-ethereum/p2p".PeerInfo)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·2 *@"github.com/ethereum/go-ethereum/p2p".Server) Self () (? *@"github.com/ethereum/go-ethereum/p2p/discover".Node)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·2 *@"github.com/ethereum/go-ethereum/p2p".Server) Start () (@"github.com/ethereum/go-ethereum/p2p".err·1 error)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·1 *@"github.com/ethereum/go-ethereum/p2p".Server) Stop ()
	func (@"github.com/ethereum/go-ethereum/p2p".srv·2 *@"github.com/ethereum/go-ethereum/p2p".Server "esc:0x1") @"github.com/ethereum/go-ethereum/p2p".checkpoint (@"github.com/ethereum/go-ethereum/p2p".c·3 *@"github.com/ethereum/go-ethereum/p2p".conn, @"github.com/ethereum/go-ethereum/p2p".stage·4 chan<- *@"github.com/ethereum/go-ethereum/p2p".conn "esc:0x1") (? error)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·2 *@"github.com/ethereum/go-ethereum/p2p".Server) @"github.com/ethereum/go-ethereum/p2p".encHandshakeChecks (@"github.com/ethereum/go-ethereum/p2p".peers·3 map[@"github.com/ethereum/go-ethereum/p2p/discover".NodeID]*@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x1", @"github.com/ethereum/go-ethereum/p2p".c·4 *@"github.com/ethereum/go-ethereum/p2p".conn "esc:0x1") (? error)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·1 *@"github.com/ethereum/go-ethereum/p2p".Server) @"github.com/ethereum/go-ethereum/p2p".listenLoop ()
	func (@"github.com/ethereum/go-ethereum/p2p".srv·2 *@"github.com/ethereum/go-ethereum/p2p".Server) @"github.com/ethereum/go-ethereum/p2p".protoHandshakeChecks (@"github.com/ethereum/go-ethereum/p2p".peers·3 map[@"github.com/ethereum/go-ethereum/p2p/discover".NodeID]*@"github.com/ethereum/go-ethereum/p2p".Peer "esc:0x1", @"github.com/ethereum/go-ethereum/p2p".c·4 *@"github.com/ethereum/go-ethereum/p2p".conn "esc:0x1") (? error)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·1 *@"github.com/ethereum/go-ethereum/p2p".Server) @"github.com/ethereum/go-ethereum/p2p".run (@"github.com/ethereum/go-ethereum/p2p".dialstate·2 @"github.com/ethereum/go-ethereum/p2p".dialer)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·1 *@"github.com/ethereum/go-ethereum/p2p".Server "esc:0x1") @"github.com/ethereum/go-ethereum/p2p".runPeer (@"github.com/ethereum/go-ethereum/p2p".p·2 *@"github.com/ethereum/go-ethereum/p2p".Peer)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·1 *@"github.com/ethereum/go-ethereum/p2p".Server) @"github.com/ethereum/go-ethereum/p2p".setupConn (@"github.com/ethereum/go-ethereum/p2p".fd·2 @"net".Conn, @"github.com/ethereum/go-ethereum/p2p".flags·3 @"github.com/ethereum/go-ethereum/p2p".connFlag, @"github.com/ethereum/go-ethereum/p2p".dialDest·4 *@"github.com/ethereum/go-ethereum/p2p/discover".Node)
	func (@"github.com/ethereum/go-ethereum/p2p".srv·2 *@"github.com/ethereum/go-ethereum/p2p".Server) @"github.com/ethereum/go-ethereum/p2p".startListening () (? error)
	type @"github.com/ethereum/go-ethereum/whisper".Filter struct { To *@"crypto/ecdsa".PublicKey; From *@"crypto/ecdsa".PublicKey; Topics [][]@"github.com/ethereum/go-ethereum/whisper".Topic; Fn func(@"github.com/ethereum/go-ethereum/whisper".msg *@"github.com/ethereum/go-ethereum/whisper".Message) }
	type @"github.com/ethereum/go-ethereum/whisper".Whisper struct { @"github.com/ethereum/go-ethereum/whisper".protocol @"github.com/ethereum/go-ethereum/p2p".Protocol; @"github.com/ethereum/go-ethereum/whisper".filters *@"github.com/ethereum/go-ethereum/event/filter".Filters; @"github.com/ethereum/go-ethereum/whisper".keys map[string]*@"crypto/ecdsa".PrivateKey; @"github.com/ethereum/go-ethereum/whisper".messages map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/whisper".Envelope; @"github.com/ethereum/go-ethereum/whisper".expirations map[uint32]*@"gopkg.in/fatih/set.v0".SetNonTS; @"github.com/ethereum/go-ethereum/whisper".poolMu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/whisper".peers map[*@"github.com/ethereum/go-ethereum/whisper".peer]struct {}; @"github.com/ethereum/go-ethereum/whisper".peerMu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/whisper".quit chan struct {} }
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper "esc:0x1") GetIdentity (@"github.com/ethereum/go-ethereum/whisper".key·3 *@"crypto/ecdsa".PublicKey "esc:0x1") (? *@"crypto/ecdsa".PrivateKey)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper "esc:0x1") HasIdentity (@"github.com/ethereum/go-ethereum/whisper".key·3 *@"crypto/ecdsa".PublicKey "esc:0x1") (? bool)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper "esc:0x9") Messages (@"github.com/ethereum/go-ethereum/whisper".id·3 int) (? []*@"github.com/ethereum/go-ethereum/whisper".Message)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper "esc:0x1") NewIdentity () (? *@"crypto/ecdsa".PrivateKey)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper "esc:0x12") Protocols () (? []@"github.com/ethereum/go-ethereum/p2p".Protocol) { return ([]@"github.com/ethereum/go-ethereum/p2p".Protocol{ 0x0:@"github.com/ethereum/go-ethereum/whisper".self·2.@"github.com/ethereum/go-ethereum/whisper".protocol }) }
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper) Send (@"github.com/ethereum/go-ethereum/whisper".envelope·3 *@"github.com/ethereum/go-ethereum/whisper".Envelope) (? error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper) Start (? *@"github.com/ethereum/go-ethereum/p2p".Server) (? error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper "esc:0x1") Stop () (? error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·1 *@"github.com/ethereum/go-ethereum/whisper".Whisper "esc:0x1") Unwatch (@"github.com/ethereum/go-ethereum/whisper".id·2 int) { @"github.com/ethereum/go-ethereum/whisper".self·1.@"github.com/ethereum/go-ethereum/whisper".filters.Uninstall(@"github.com/ethereum/go-ethereum/whisper".id·2) }
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper "esc:0x1") Version () (? uint) { return @"github.com/ethereum/go-ethereum/whisper".self·2.@"github.com/ethereum/go-ethereum/whisper".protocol.Version }
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper "esc:0x1") Watch (@"github.com/ethereum/go-ethereum/whisper".options·3 @"github.com/ethereum/go-ethereum/whisper".Filter) (? int)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper) @"github.com/ethereum/go-ethereum/whisper".add (@"github.com/ethereum/go-ethereum/whisper".envelope·3 *@"github.com/ethereum/go-ethereum/whisper".Envelope) (? error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper) @"github.com/ethereum/go-ethereum/whisper".envelopes () (? []*@"github.com/ethereum/go-ethereum/whisper".Envelope)
	func (@"github.com/ethereum/go-ethereum/whisper".self·1 *@"github.com/ethereum/go-ethereum/whisper".Whisper) @"github.com/ethereum/go-ethereum/whisper".expire ()
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper) @"github.com/ethereum/go-ethereum/whisper".handlePeer (@"github.com/ethereum/go-ethereum/whisper".peer·3 *@"github.com/ethereum/go-ethereum/p2p".Peer, @"github.com/ethereum/go-ethereum/whisper".rw·4 @"github.com/ethereum/go-ethereum/p2p".MsgReadWriter) (? error)
	func (@"github.com/ethereum/go-ethereum/whisper".self·2 *@"github.com/ethereum/go-ethereum/whisper".Whisper "esc:0x9") @"github.com/ethereum/go-ethereum/whisper".open (@"github.com/ethereum/go-ethereum/whisper".envelope·3 *@"github.com/ethereum/go-ethereum/whisper".Envelope) (? *@"github.com/ethereum/go-ethereum/whisper".Message)
	func (@"github.com/ethereum/go-ethereum/whisper".self·1 *@"github.com/ethereum/go-ethereum/whisper".Whisper "esc:0x9") @"github.com/ethereum/go-ethereum/whisper".postEvent (@"github.com/ethereum/go-ethereum/whisper".envelope·2 *@"github.com/ethereum/go-ethereum/whisper".Envelope)
	func (@"github.com/ethereum/go-ethereum/whisper".self·1 *@"github.com/ethereum/go-ethereum/whisper".Whisper) @"github.com/ethereum/go-ethereum/whisper".update ()
	type @"github.com/ethereum/go-ethereum/xeth".WhisperMessage struct { @"github.com/ethereum/go-ethereum/xeth".ref *@"github.com/ethereum/go-ethereum/whisper".Message; Payload string "json:\"payload\""; To string "json:\"to\""; From string "json:\"from\""; Sent int64 "json:\"sent\""; TTL int64 "json:\"ttl\""; Hash string "json:\"hash\"" }
	type @"github.com/ethereum/go-ethereum/xeth".Whisper struct { ? *@"github.com/ethereum/go-ethereum/whisper".Whisper }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Whisper "esc:0x1") HasIdentity (@"github.com/ethereum/go-ethereum/xeth".key·3 string "esc:0x1") (? bool)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Whisper "esc:0x9") Messages (@"github.com/ethereum/go-ethereum/xeth".id·3 int) (? []@"github.com/ethereum/go-ethereum/xeth".WhisperMessage)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Whisper "esc:0x1") NewIdentity () (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Whisper "esc:0x9") Post (@"github.com/ethereum/go-ethereum/xeth".payload·3 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".to·4 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".from·5 string, @"github.com/ethereum/go-ethereum/xeth".topics·6 []string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".priority·7 uint32, @"github.com/ethereum/go-ethereum/xeth".ttl·8 uint32) (? error)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Whisper "esc:0x1") Watch (@"github.com/ethereum/go-ethereum/xeth".to·3 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".from·4 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".topics·5 [][]string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".fn·6 func(? @"github.com/ethereum/go-ethereum/xeth".WhisperMessage)) (? int)
	type @"github.com/ethereum/go-ethereum/xeth".whisperFilter struct { @"github.com/ethereum/go-ethereum/xeth".id int; @"github.com/ethereum/go-ethereum/xeth".ref *@"github.com/ethereum/go-ethereum/xeth".Whisper; @"github.com/ethereum/go-ethereum/xeth".cache []@"github.com/ethereum/go-ethereum/xeth".WhisperMessage; @"github.com/ethereum/go-ethereum/xeth".skip map[@"github.com/ethereum/go-ethereum/common".Hash]struct {}; @"github.com/ethereum/go-ethereum/xeth".update @"time".Time; @"github.com/ethereum/go-ethereum/xeth".lock @"sync".RWMutex }
	func (@"github.com/ethereum/go-ethereum/xeth".w·2 *@"github.com/ethereum/go-ethereum/xeth".whisperFilter) @"github.com/ethereum/go-ethereum/xeth".activity () (? @"time".Time)
	func (@"github.com/ethereum/go-ethereum/xeth".w·1 *@"github.com/ethereum/go-ethereum/xeth".whisperFilter) @"github.com/ethereum/go-ethereum/xeth".insert (@"github.com/ethereum/go-ethereum/xeth".messages·2 ...@"github.com/ethereum/go-ethereum/xeth".WhisperMessage "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/xeth".w·2 *@"github.com/ethereum/go-ethereum/xeth".whisperFilter) @"github.com/ethereum/go-ethereum/xeth".messages () (? []@"github.com/ethereum/go-ethereum/xeth".WhisperMessage)
	func (@"github.com/ethereum/go-ethereum/xeth".w·2 *@"github.com/ethereum/go-ethereum/xeth".whisperFilter) @"github.com/ethereum/go-ethereum/xeth".retrieve () (@"github.com/ethereum/go-ethereum/xeth".messages·1 []@"github.com/ethereum/go-ethereum/xeth".WhisperMessage)
	import node "github.com/ethereum/go-ethereum/node" // indirect
	import event "github.com/ethereum/go-ethereum/event" // indirect
	type @"github.com/ethereum/go-ethereum/event".Event struct { Time @"time".Time; Data interface {} }
	type @"github.com/ethereum/go-ethereum/event".muxsub struct { @"github.com/ethereum/go-ethereum/event".mux *@"github.com/ethereum/go-ethereum/event".TypeMux; @"github.com/ethereum/go-ethereum/event".created @"time".Time; @"github.com/ethereum/go-ethereum/event".closeMu @"sync".Mutex; @"github.com/ethereum/go-ethereum/event".closing chan struct {}; @"github.com/ethereum/go-ethereum/event".closed bool; @"github.com/ethereum/go-ethereum/event".postMu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/event".readC <-chan *@"github.com/ethereum/go-ethereum/event".Event; @"github.com/ethereum/go-ethereum/event".postC chan<- *@"github.com/ethereum/go-ethereum/event".Event }
	func (@"github.com/ethereum/go-ethereum/event".s·2 *@"github.com/ethereum/go-ethereum/event".muxsub "esc:0x22") Chan () (? <-chan *@"github.com/ethereum/go-ethereum/event".Event) { return @"github.com/ethereum/go-ethereum/event".s·2.@"github.com/ethereum/go-ethereum/event".readC }
	func (@"github.com/ethereum/go-ethereum/event".s·1 *@"github.com/ethereum/go-ethereum/event".muxsub) Unsubscribe ()
	func (@"github.com/ethereum/go-ethereum/event".s·1 *@"github.com/ethereum/go-ethereum/event".muxsub) @"github.com/ethereum/go-ethereum/event".closewait ()
	func (@"github.com/ethereum/go-ethereum/event".s·1 *@"github.com/ethereum/go-ethereum/event".muxsub) @"github.com/ethereum/go-ethereum/event".deliver (@"github.com/ethereum/go-ethereum/event".event·2 *@"github.com/ethereum/go-ethereum/event".Event)
	type @"github.com/ethereum/go-ethereum/event".Subscription interface { Chan() (? <-chan *@"github.com/ethereum/go-ethereum/event".Event); Unsubscribe() }
	type @"github.com/ethereum/go-ethereum/event".TypeMux struct { @"github.com/ethereum/go-ethereum/event".mutex @"sync".RWMutex; @"github.com/ethereum/go-ethereum/event".subm map[@"reflect".Type][]*@"github.com/ethereum/go-ethereum/event".muxsub; @"github.com/ethereum/go-ethereum/event".stopped bool }
	func (@"github.com/ethereum/go-ethereum/event".mux·2 *@"github.com/ethereum/go-ethereum/event".TypeMux) Post (@"github.com/ethereum/go-ethereum/event".ev·3 interface {}) (? error)
	func (@"github.com/ethereum/go-ethereum/event".mux·1 *@"github.com/ethereum/go-ethereum/event".TypeMux) Stop ()
	func (@"github.com/ethereum/go-ethereum/event".mux·2 *@"github.com/ethereum/go-ethereum/event".TypeMux) Subscribe (@"github.com/ethereum/go-ethereum/event".types·3 ...interface {} "esc:0x9") (? @"github.com/ethereum/go-ethereum/event".Subscription)
	func (@"github.com/ethereum/go-ethereum/event".mux·1 *@"github.com/ethereum/go-ethereum/event".TypeMux) @"github.com/ethereum/go-ethereum/event".del (@"github.com/ethereum/go-ethereum/event".s·2 *@"github.com/ethereum/go-ethereum/event".muxsub "esc:0x9")
	type @"github.com/ethereum/go-ethereum/node".Service interface { Protocols() (? []@"github.com/ethereum/go-ethereum/p2p".Protocol); Start(@"github.com/ethereum/go-ethereum/node".server *@"github.com/ethereum/go-ethereum/p2p".Server) (? error); Stop() (? error) }
	import ethdb "github.com/ethereum/go-ethereum/ethdb" // indirect
	type @"github.com/ethereum/go-ethereum/ethdb".Batch interface { Put(@"github.com/ethereum/go-ethereum/ethdb".key []byte, @"github.com/ethereum/go-ethereum/ethdb".value []byte) (? error); Write() (? error) }
	type @"github.com/ethereum/go-ethereum/ethdb".Database interface { Close(); Delete(@"github.com/ethereum/go-ethereum/ethdb".key []byte) (? error); Get(@"github.com/ethereum/go-ethereum/ethdb".key []byte) (? []byte, ? error); NewBatch() (? @"github.com/ethereum/go-ethereum/ethdb".Batch); Put(@"github.com/ethereum/go-ethereum/ethdb".key []byte, @"github.com/ethereum/go-ethereum/ethdb".value []byte) (? error) }
	type @"github.com/ethereum/go-ethereum/node".ServiceContext struct { @"github.com/ethereum/go-ethereum/node".datadir string; @"github.com/ethereum/go-ethereum/node".services map[@"reflect".Type]@"github.com/ethereum/go-ethereum/node".Service; EventMux *@"github.com/ethereum/go-ethereum/event".TypeMux }
	func (@"github.com/ethereum/go-ethereum/node".ctx·3 *@"github.com/ethereum/go-ethereum/node".ServiceContext "esc:0x9") OpenDatabase (@"github.com/ethereum/go-ethereum/node".name·4 string, @"github.com/ethereum/go-ethereum/node".cache·5 int) (? @"github.com/ethereum/go-ethereum/ethdb".Database, ? error)
	func (@"github.com/ethereum/go-ethereum/node".ctx·2 *@"github.com/ethereum/go-ethereum/node".ServiceContext "esc:0x1") Service (@"github.com/ethereum/go-ethereum/node".service·3 interface {}) (? error)
	type @"github.com/ethereum/go-ethereum/node".ServiceConstructor func(@"github.com/ethereum/go-ethereum/node".ctx *@"github.com/ethereum/go-ethereum/node".ServiceContext) (? @"github.com/ethereum/go-ethereum/node".Service, ? error)
	type @"github.com/ethereum/go-ethereum/node".Node struct { @"github.com/ethereum/go-ethereum/node".datadir string; @"github.com/ethereum/go-ethereum/node".eventmux *@"github.com/ethereum/go-ethereum/event".TypeMux; @"github.com/ethereum/go-ethereum/node".serverConfig *@"github.com/ethereum/go-ethereum/p2p".Server; @"github.com/ethereum/go-ethereum/node".server *@"github.com/ethereum/go-ethereum/p2p".Server; @"github.com/ethereum/go-ethereum/node".serviceFuncs []@"github.com/ethereum/go-ethereum/node".ServiceConstructor; @"github.com/ethereum/go-ethereum/node".services map[@"reflect".Type]@"github.com/ethereum/go-ethereum/node".Service; @"github.com/ethereum/go-ethereum/node".stop chan struct {}; @"github.com/ethereum/go-ethereum/node".lock @"sync".RWMutex }
	func (@"github.com/ethereum/go-ethereum/node".n·2 *@"github.com/ethereum/go-ethereum/node".Node "esc:0x22") DataDir () (? string) { return @"github.com/ethereum/go-ethereum/node".n·2.@"github.com/ethereum/go-ethereum/node".datadir }
	func (@"github.com/ethereum/go-ethereum/node".n·2 *@"github.com/ethereum/go-ethereum/node".Node "esc:0x22") EventMux () (? *@"github.com/ethereum/go-ethereum/event".TypeMux) { return @"github.com/ethereum/go-ethereum/node".n·2.@"github.com/ethereum/go-ethereum/node".eventmux }
	func (@"github.com/ethereum/go-ethereum/node".n·2 *@"github.com/ethereum/go-ethereum/node".Node) Register (@"github.com/ethereum/go-ethereum/node".constructor·3 @"github.com/ethereum/go-ethereum/node".ServiceConstructor) (? error)
	func (@"github.com/ethereum/go-ethereum/node".n·2 *@"github.com/ethereum/go-ethereum/node".Node) Restart () (? error)
	func (@"github.com/ethereum/go-ethereum/node".n·2 *@"github.com/ethereum/go-ethereum/node".Node) Server () (? *@"github.com/ethereum/go-ethereum/p2p".Server)
	func (@"github.com/ethereum/go-ethereum/node".n·2 *@"github.com/ethereum/go-ethereum/node".Node) Service (@"github.com/ethereum/go-ethereum/node".service·3 interface {}) (? error)
	func (@"github.com/ethereum/go-ethereum/node".n·2 *@"github.com/ethereum/go-ethereum/node".Node) Start () (? error)
	func (@"github.com/ethereum/go-ethereum/node".n·2 *@"github.com/ethereum/go-ethereum/node".Node) Stop () (? error)
	func (@"github.com/ethereum/go-ethereum/node".n·1 *@"github.com/ethereum/go-ethereum/node".Node) Wait ()
	type @"github.com/ethereum/go-ethereum/xeth".Frontend interface { AskPassword() (? string, ? bool); ConfirmTransaction(@"github.com/ethereum/go-ethereum/xeth".tx string) (? bool); UnlockAccount(@"github.com/ethereum/go-ethereum/xeth".address []byte) (? bool) }
	import miner "github.com/ethereum/go-ethereum/miner" // indirect
	import state "github.com/ethereum/go-ethereum/core/state" // indirect
	import trie "github.com/ethereum/go-ethereum/trie" // indirect
	type @"github.com/ethereum/go-ethereum/trie".node interface { @"github.com/ethereum/go-ethereum/trie".fstring(? string) (? string) }
	type @"github.com/ethereum/go-ethereum/trie".Database interface { Get(@"github.com/ethereum/go-ethereum/trie".key []byte) (@"github.com/ethereum/go-ethereum/trie".value []byte, @"github.com/ethereum/go-ethereum/trie".err error); Put(@"github.com/ethereum/go-ethereum/trie".key []byte, @"github.com/ethereum/go-ethereum/trie".value []byte) (? error) }
	type @"bytes".readOp int
	type @"bytes".Buffer struct { @"bytes".buf []byte; @"bytes".off int; @"bytes".runeBytes [4]byte; @"bytes".bootstrap [64]byte; @"bytes".lastRead @"bytes".readOp }
	func (@"bytes".b·2 *@"bytes".Buffer "esc:0x22") Bytes () (? []byte) { return @"bytes".b·2.@"bytes".buf[@"bytes".b·2.@"bytes".off:] }
	func (@"bytes".b·2 *@"bytes".Buffer "esc:0x1") Cap () (? int) { return cap(@"bytes".b·2.@"bytes".buf) }
	func (@"bytes".b·1 *@"bytes".Buffer) Grow (@"bytes".n·2 int)
	func (@"bytes".b·2 *@"bytes".Buffer "esc:0x1") Len () (? int) { return len(@"bytes".b·2.@"bytes".buf) - @"bytes".b·2.@"bytes".off }
	func (@"bytes".b·2 *@"bytes".Buffer "esc:0x22") Next (@"bytes".n·3 int) (? []byte) { @"bytes".b·2.@"bytes".lastRead = @"bytes".readOp(0x0); var @"bytes".m·4 int; ; @"bytes".m·4 = @"bytes".b·2.Len(); if @"bytes".n·3 > @"bytes".m·4 { @"bytes".n·3 = @"bytes".m·4 }; var @"bytes".data·5 []byte; ; @"bytes".data·5 = @"bytes".b·2.@"bytes".buf[@"bytes".b·2.@"bytes".off:@"bytes".b·2.@"bytes".off + @"bytes".n·3]; @"bytes".b·2.@"bytes".off += @"bytes".n·3; if @"bytes".n·3 > 0x0 { @"bytes".b·2.@"bytes".lastRead = @"bytes".readOp(0x2) }; return @"bytes".data·5 }
	func (@"bytes".b·3 *@"bytes".Buffer "esc:0x9") Read (@"bytes".p·4 []byte "esc:0x1") (@"bytes".n·1 int, @"bytes".err·2 error)
	func (@"bytes".b·3 *@"bytes".Buffer "esc:0x1") ReadByte () (@"bytes".c·1 byte, @"bytes".err·2 error)
	func (@"bytes".b·3 *@"bytes".Buffer "esc:0x9") ReadBytes (@"bytes".delim·4 byte) (@"bytes".line·1 []byte, @"bytes".err·2 error)
	func (@"bytes".b·3 *@"bytes".Buffer "esc:0x9") ReadFrom (@"bytes".r·4 @"io".Reader) (@"bytes".n·1 int64, @"bytes".err·2 error)
	func (@"bytes".b·4 *@"bytes".Buffer "esc:0x1") ReadRune () (@"bytes".r·1 rune, @"bytes".size·2 int, @"bytes".err·3 error)
	func (@"bytes".b·3 *@"bytes".Buffer "esc:0x1") ReadString (@"bytes".delim·4 byte) (@"bytes".line·1 string, @"bytes".err·2 error)
	func (@"bytes".b·1 *@"bytes".Buffer "esc:0x1") Reset ()
	func (@"bytes".b·2 *@"bytes".Buffer "esc:0x1") String () (? string) { if @"bytes".b·2 == nil { return "<nil>" }; return string(@"bytes".b·2.@"bytes".buf[@"bytes".b·2.@"bytes".off:]) }
	func (@"bytes".b·1 *@"bytes".Buffer "esc:0x1") Truncate (@"bytes".n·2 int)
	func (@"bytes".b·2 *@"bytes".Buffer "esc:0x1") UnreadByte () (? error) { if @"bytes".b·2.@"bytes".lastRead != @"bytes".readOp(0x1) && @"bytes".b·2.@"bytes".lastRead != @"bytes".readOp(0x2) { return @"errors".New("bytes.Buffer: UnreadByte: previous operation was not a read") }; @"bytes".b·2.@"bytes".lastRead = @"bytes".readOp(0x0); if @"bytes".b·2.@"bytes".off > 0x0 { @"bytes".b·2.@"bytes".off-- }; return nil }
	func (@"bytes".b·2 *@"bytes".Buffer "esc:0x1") UnreadRune () (? error)
	func (@"bytes".b·3 *@"bytes".Buffer) Write (@"bytes".p·4 []byte "esc:0x9") (@"bytes".n·1 int, @"bytes".err·2 error)
	func (@"bytes".b·2 *@"bytes".Buffer) WriteByte (@"bytes".c·3 byte) (? error)
	func (@"bytes".b·3 *@"bytes".Buffer) WriteRune (@"bytes".r·4 rune) (@"bytes".n·1 int, @"bytes".err·2 error)
	func (@"bytes".b·3 *@"bytes".Buffer) WriteString (@"bytes".s·4 string "esc:0x9") (@"bytes".n·1 int, @"bytes".err·2 error)
	func (@"bytes".b·3 *@"bytes".Buffer "esc:0x9") WriteTo (@"bytes".w·4 @"io".Writer) (@"bytes".n·1 int64, @"bytes".err·2 error)
	func (@"bytes".b·2 *@"bytes".Buffer) @"bytes".grow (@"bytes".n·3 int) (? int)
	func (@"bytes".b·3 *@"bytes".Buffer "esc:0x22") @"bytes".readSlice (@"bytes".delim·4 byte) (@"bytes".line·1 []byte, @"bytes".err·2 error)
	type @"github.com/ethereum/go-ethereum/trie".DatabaseWriter interface { Put(@"github.com/ethereum/go-ethereum/trie".key []byte, @"github.com/ethereum/go-ethereum/trie".value []byte) (? error) }
	type @"github.com/ethereum/go-ethereum/trie".hasher struct { @"github.com/ethereum/go-ethereum/trie".tmp *@"bytes".Buffer; @"github.com/ethereum/go-ethereum/trie".sha @"hash".Hash }
	func (@"github.com/ethereum/go-ethereum/trie".h·3 *@"github.com/ethereum/go-ethereum/trie".hasher "esc:0x9") @"github.com/ethereum/go-ethereum/trie".hash (@"github.com/ethereum/go-ethereum/trie".n·4 @"github.com/ethereum/go-ethereum/trie".node, @"github.com/ethereum/go-ethereum/trie".db·5 @"github.com/ethereum/go-ethereum/trie".DatabaseWriter, @"github.com/ethereum/go-ethereum/trie".force·6 bool) (? @"github.com/ethereum/go-ethereum/trie".node, ? error)
	func (@"github.com/ethereum/go-ethereum/trie".h·3 *@"github.com/ethereum/go-ethereum/trie".hasher "esc:0x9") @"github.com/ethereum/go-ethereum/trie".replaceChildren (@"github.com/ethereum/go-ethereum/trie".n·4 @"github.com/ethereum/go-ethereum/trie".node, @"github.com/ethereum/go-ethereum/trie".db·5 @"github.com/ethereum/go-ethereum/trie".DatabaseWriter) (? @"github.com/ethereum/go-ethereum/trie".node, ? error)
	func (@"github.com/ethereum/go-ethereum/trie".h·3 *@"github.com/ethereum/go-ethereum/trie".hasher "esc:0x9") @"github.com/ethereum/go-ethereum/trie".store (@"github.com/ethereum/go-ethereum/trie".n·4 @"github.com/ethereum/go-ethereum/trie".node, @"github.com/ethereum/go-ethereum/trie".db·5 @"github.com/ethereum/go-ethereum/trie".DatabaseWriter, @"github.com/ethereum/go-ethereum/trie".force·6 bool) (? @"github.com/ethereum/go-ethereum/trie".node, ? error)
	type @"github.com/ethereum/go-ethereum/trie".Iterator struct { @"github.com/ethereum/go-ethereum/trie".trie *@"github.com/ethereum/go-ethereum/trie".Trie; Key []byte; Value []byte }
	func (@"github.com/ethereum/go-ethereum/trie".self·2 *@"github.com/ethereum/go-ethereum/trie".Iterator "esc:0x9") Next () (? bool)
	func (@"github.com/ethereum/go-ethereum/trie".self·2 *@"github.com/ethereum/go-ethereum/trie".Iterator "esc:0x9") @"github.com/ethereum/go-ethereum/trie".key (@"github.com/ethereum/go-ethereum/trie".node·3 interface {}) (? []byte)
	func (@"github.com/ethereum/go-ethereum/trie".self·2 *@"github.com/ethereum/go-ethereum/trie".Iterator "esc:0x9") @"github.com/ethereum/go-ethereum/trie".next (@"github.com/ethereum/go-ethereum/trie".node·3 interface {}, @"github.com/ethereum/go-ethereum/trie".key·4 []byte, @"github.com/ethereum/go-ethereum/trie".isIterStart·5 bool) (? []byte)
	type @"github.com/ethereum/go-ethereum/rlp".RawValue []byte
	type @"github.com/ethereum/go-ethereum/trie".hashNode []byte
	func (@"github.com/ethereum/go-ethereum/trie".n·2 @"github.com/ethereum/go-ethereum/trie".hashNode) String () (? string)
	func (@"github.com/ethereum/go-ethereum/trie".n·2 @"github.com/ethereum/go-ethereum/trie".hashNode) @"github.com/ethereum/go-ethereum/trie".fstring (@"github.com/ethereum/go-ethereum/trie".ind·3 string "esc:0x1") (? string)
	type @"github.com/ethereum/go-ethereum/trie".Trie struct { @"github.com/ethereum/go-ethereum/trie".root @"github.com/ethereum/go-ethereum/trie".node; @"github.com/ethereum/go-ethereum/trie".db @"github.com/ethereum/go-ethereum/trie".Database; @"github.com/ethereum/go-ethereum/trie".originalRoot @"github.com/ethereum/go-ethereum/common".Hash; @"github.com/ethereum/go-ethereum/trie".? *@"github.com/ethereum/go-ethereum/trie".hasher }
	func (@"github.com/ethereum/go-ethereum/trie".t·3 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") Commit () (@"github.com/ethereum/go-ethereum/trie".root·1 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/trie".err·2 error)
	func (@"github.com/ethereum/go-ethereum/trie".t·3 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") CommitTo (@"github.com/ethereum/go-ethereum/trie".db·4 @"github.com/ethereum/go-ethereum/trie".DatabaseWriter) (@"github.com/ethereum/go-ethereum/trie".root·1 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/trie".err·2 error)
	func (@"github.com/ethereum/go-ethereum/trie".t·1 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") Delete (@"github.com/ethereum/go-ethereum/trie".key·2 []byte "esc:0x1")
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x2a") Get (@"github.com/ethereum/go-ethereum/trie".key·3 []byte) (? []byte)
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") Hash () (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".Trie) Iterator () (? *@"github.com/ethereum/go-ethereum/trie".Iterator) { return @"github.com/ethereum/go-ethereum/trie".NewIterator(@"github.com/ethereum/go-ethereum/trie".t·2) }
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") Prove (@"github.com/ethereum/go-ethereum/trie".key·3 []byte "esc:0x1") (? []@"github.com/ethereum/go-ethereum/rlp".RawValue)
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") Root () (? []byte)
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") TryDelete (@"github.com/ethereum/go-ethereum/trie".key·3 []byte "esc:0x1") (? error)
	func (@"github.com/ethereum/go-ethereum/trie".t·3 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x2a") TryGet (@"github.com/ethereum/go-ethereum/trie".key·4 []byte) (? []byte, ? error)
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") TryUpdate (@"github.com/ethereum/go-ethereum/trie".key·3 []byte "esc:0x1", @"github.com/ethereum/go-ethereum/trie".value·4 []byte) (? error)
	func (@"github.com/ethereum/go-ethereum/trie".t·1 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") Update (@"github.com/ethereum/go-ethereum/trie".key·2 []byte "esc:0x1", @"github.com/ethereum/go-ethereum/trie".value·3 []byte)
	func (@"github.com/ethereum/go-ethereum/trie".t·3 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") @"github.com/ethereum/go-ethereum/trie".delete (@"github.com/ethereum/go-ethereum/trie".n·4 @"github.com/ethereum/go-ethereum/trie".node, @"github.com/ethereum/go-ethereum/trie".prefix·5 []byte, @"github.com/ethereum/go-ethereum/trie".key·6 []byte) (? @"github.com/ethereum/go-ethereum/trie".node, ? error)
	func (@"github.com/ethereum/go-ethereum/trie".t·3 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") @"github.com/ethereum/go-ethereum/trie".hashRoot (@"github.com/ethereum/go-ethereum/trie".db·4 @"github.com/ethereum/go-ethereum/trie".DatabaseWriter) (? @"github.com/ethereum/go-ethereum/trie".node, ? error)
	func (@"github.com/ethereum/go-ethereum/trie".t·3 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") @"github.com/ethereum/go-ethereum/trie".insert (@"github.com/ethereum/go-ethereum/trie".n·4 @"github.com/ethereum/go-ethereum/trie".node, @"github.com/ethereum/go-ethereum/trie".prefix·5 []byte, @"github.com/ethereum/go-ethereum/trie".key·6 []byte, @"github.com/ethereum/go-ethereum/trie".value·7 @"github.com/ethereum/go-ethereum/trie".node) (? @"github.com/ethereum/go-ethereum/trie".node, ? error)
	func (@"github.com/ethereum/go-ethereum/trie".t·3 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") @"github.com/ethereum/go-ethereum/trie".resolve (@"github.com/ethereum/go-ethereum/trie".n·4 @"github.com/ethereum/go-ethereum/trie".node, @"github.com/ethereum/go-ethereum/trie".prefix·5 []byte, @"github.com/ethereum/go-ethereum/trie".suffix·6 []byte) (? @"github.com/ethereum/go-ethereum/trie".node, ? error)
	func (@"github.com/ethereum/go-ethereum/trie".t·3 *@"github.com/ethereum/go-ethereum/trie".Trie "esc:0x9") @"github.com/ethereum/go-ethereum/trie".resolveHash (@"github.com/ethereum/go-ethereum/trie".n·4 @"github.com/ethereum/go-ethereum/trie".hashNode, @"github.com/ethereum/go-ethereum/trie".prefix·5 []byte, @"github.com/ethereum/go-ethereum/trie".suffix·6 []byte) (? @"github.com/ethereum/go-ethereum/trie".node, ? error)
	type @"github.com/ethereum/go-ethereum/trie".SecureTrie struct { ? *@"github.com/ethereum/go-ethereum/trie".Trie; @"github.com/ethereum/go-ethereum/trie".hash @"hash".Hash; @"github.com/ethereum/go-ethereum/trie".secKeyBuf []byte; @"github.com/ethereum/go-ethereum/trie".hashKeyBuf []byte }
	func (@"github.com/ethereum/go-ethereum/trie".t·1 *@"github.com/ethereum/go-ethereum/trie".SecureTrie "esc:0x9") Delete (@"github.com/ethereum/go-ethereum/trie".key·2 []byte)
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".SecureTrie "esc:0x3a") Get (@"github.com/ethereum/go-ethereum/trie".key·3 []byte) (? []byte)
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".SecureTrie "esc:0x9") GetKey (@"github.com/ethereum/go-ethereum/trie".shaKey·3 []byte "esc:0x9") (? []byte)
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".SecureTrie "esc:0x9") TryDelete (@"github.com/ethereum/go-ethereum/trie".key·3 []byte) (? error)
	func (@"github.com/ethereum/go-ethereum/trie".t·3 *@"github.com/ethereum/go-ethereum/trie".SecureTrie "esc:0x3a") TryGet (@"github.com/ethereum/go-ethereum/trie".key·4 []byte) (? []byte, ? error)
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".SecureTrie "esc:0x9") TryUpdate (@"github.com/ethereum/go-ethereum/trie".key·3 []byte, @"github.com/ethereum/go-ethereum/trie".value·4 []byte) (? error)
	func (@"github.com/ethereum/go-ethereum/trie".t·1 *@"github.com/ethereum/go-ethereum/trie".SecureTrie "esc:0x9") Update (@"github.com/ethereum/go-ethereum/trie".key·2 []byte, @"github.com/ethereum/go-ethereum/trie".value·3 []byte)
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".SecureTrie "esc:0x2a") @"github.com/ethereum/go-ethereum/trie".hashKey (@"github.com/ethereum/go-ethereum/trie".key·3 []byte) (? []byte)
	func (@"github.com/ethereum/go-ethereum/trie".t·2 *@"github.com/ethereum/go-ethereum/trie".SecureTrie "esc:0x2a") @"github.com/ethereum/go-ethereum/trie".secKey (@"github.com/ethereum/go-ethereum/trie".key·3 []byte "esc:0x9") (? []byte) { @"github.com/ethereum/go-ethereum/trie".t·2.@"github.com/ethereum/go-ethereum/trie".secKeyBuf = append(@"github.com/ethereum/go-ethereum/trie".t·2.@"github.com/ethereum/go-ethereum/trie".secKeyBuf[:0x0], @"github.com/ethereum/go-ethereum/trie".secureKeyPrefix...); @"github.com/ethereum/go-ethereum/trie".t·2.@"github.com/ethereum/go-ethereum/trie".secKeyBuf = append(@"github.com/ethereum/go-ethereum/trie".t·2.@"github.com/ethereum/go-ethereum/trie".secKeyBuf, @"github.com/ethereum/go-ethereum/trie".key·3...); return @"github.com/ethereum/go-ethereum/trie".t·2.@"github.com/ethereum/go-ethereum/trie".secKeyBuf }
	type @"github.com/ethereum/go-ethereum/core/state".Code []byte
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 @"github.com/ethereum/go-ethereum/core/state".Code "esc:0x1") String () (? string) { return string(@"github.com/ethereum/go-ethereum/core/state".self·2) }
	type @"github.com/ethereum/go-ethereum/core/state".Storage map[string]@"github.com/ethereum/go-ethereum/common".Hash
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 @"github.com/ethereum/go-ethereum/core/state".Storage "esc:0x1") Copy () (? @"github.com/ethereum/go-ethereum/core/state".Storage)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 @"github.com/ethereum/go-ethereum/core/state".Storage "esc:0x1") String () (@"github.com/ethereum/go-ethereum/core/state".str·1 string)
	type @"github.com/ethereum/go-ethereum/common".Bytes []byte
	func (@"github.com/ethereum/go-ethereum/common".self·2 @"github.com/ethereum/go-ethereum/common".Bytes "esc:0x1") String () (? string) { return string(@"github.com/ethereum/go-ethereum/common".self·2) }
	type @"github.com/ethereum/go-ethereum/core/state".StateObject struct { @"github.com/ethereum/go-ethereum/core/state".db @"github.com/ethereum/go-ethereum/ethdb".Database; @"github.com/ethereum/go-ethereum/core/state".trie *@"github.com/ethereum/go-ethereum/trie".SecureTrie; @"github.com/ethereum/go-ethereum/core/state".address @"github.com/ethereum/go-ethereum/common".Address; @"github.com/ethereum/go-ethereum/core/state".balance *@"math/big".Int; @"github.com/ethereum/go-ethereum/core/state".nonce uint64; @"github.com/ethereum/go-ethereum/core/state".codeHash []byte; @"github.com/ethereum/go-ethereum/core/state".code @"github.com/ethereum/go-ethereum/core/state".Code; @"github.com/ethereum/go-ethereum/core/state".initCode @"github.com/ethereum/go-ethereum/core/state".Code; @"github.com/ethereum/go-ethereum/core/state".storage @"github.com/ethereum/go-ethereum/core/state".Storage; @"github.com/ethereum/go-ethereum/core/state".remove bool; @"github.com/ethereum/go-ethereum/core/state".deleted bool; @"github.com/ethereum/go-ethereum/core/state".dirty bool }
	func (@"github.com/ethereum/go-ethereum/core/state".c·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") AddBalance (@"github.com/ethereum/go-ethereum/core/state".amount·2 *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/state".c·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x1") Address () (? @"github.com/ethereum/go-ethereum/common".Address) { return @"github.com/ethereum/go-ethereum/core/state".c·2.@"github.com/ethereum/go-ethereum/core/state".address }
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x22") Balance () (? *@"math/big".Int) { return @"github.com/ethereum/go-ethereum/core/state".self·2.@"github.com/ethereum/go-ethereum/core/state".balance }
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x22") Code () (? []byte) { return @"github.com/ethereum/go-ethereum/core/state".self·2.@"github.com/ethereum/go-ethereum/core/state".code }
	func (@"github.com/ethereum/go-ethereum/core/state".c·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") CodeHash () (? @"github.com/ethereum/go-ethereum/common".Bytes)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") Copy () (? *@"github.com/ethereum/go-ethereum/core/state".StateObject)
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") CreateOutputForDiff ()
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") EachStorage (@"github.com/ethereum/go-ethereum/core/state".cb·2 func(@"github.com/ethereum/go-ethereum/core/state".key []byte, @"github.com/ethereum/go-ethereum/core/state".value []byte) "esc:0x1")
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") GetState (@"github.com/ethereum/go-ethereum/core/state".key·3 @"github.com/ethereum/go-ethereum/common".Hash) (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") MarkForDeletion ()
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x1") Nonce () (? uint64) { return @"github.com/ethereum/go-ethereum/core/state".self·2.@"github.com/ethereum/go-ethereum/core/state".nonce }
	func (@"github.com/ethereum/go-ethereum/core/state".c·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x1") ReturnGas (@"github.com/ethereum/go-ethereum/core/state".gas·2 *@"math/big".Int "esc:0x1", @"github.com/ethereum/go-ethereum/core/state".price·3 *@"math/big".Int "esc:0x1") {  }
	func (@"github.com/ethereum/go-ethereum/core/state".c·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") RlpEncode () (? []byte)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") Root () (? []byte)
	func (@"github.com/ethereum/go-ethereum/core/state".c·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x1") SetBalance (@"github.com/ethereum/go-ethereum/core/state".amount·2 *@"math/big".Int) { @"github.com/ethereum/go-ethereum/core/state".c·1.@"github.com/ethereum/go-ethereum/core/state".balance = @"github.com/ethereum/go-ethereum/core/state".amount·2; @"github.com/ethereum/go-ethereum/core/state".c·1.@"github.com/ethereum/go-ethereum/core/state".dirty = true }
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x1") SetCode (@"github.com/ethereum/go-ethereum/core/state".code·2 []byte) { @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".code = @"github.com/ethereum/go-ethereum/core/state".code·2; @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".dirty = true }
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x1") SetNonce (@"github.com/ethereum/go-ethereum/core/state".nonce·2 uint64) { @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".nonce = @"github.com/ethereum/go-ethereum/core/state".nonce·2; @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".dirty = true }
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x1") SetState (@"github.com/ethereum/go-ethereum/core/state".k·2 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/core/state".value·3 @"github.com/ethereum/go-ethereum/common".Hash) { @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".storage[@"github.com/ethereum/go-ethereum/core/state".k·2.Str()] = @"github.com/ethereum/go-ethereum/core/state".value·3; @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".dirty = true }
	func (@"github.com/ethereum/go-ethereum/core/state".c·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x22") St () (? @"github.com/ethereum/go-ethereum/core/state".Storage) { return @"github.com/ethereum/go-ethereum/core/state".c·2.@"github.com/ethereum/go-ethereum/core/state".storage }
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x22") Storage () (? @"github.com/ethereum/go-ethereum/core/state".Storage) { return @"github.com/ethereum/go-ethereum/core/state".self·2.@"github.com/ethereum/go-ethereum/core/state".storage }
	func (@"github.com/ethereum/go-ethereum/core/state".c·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") SubBalance (@"github.com/ethereum/go-ethereum/core/state".amount·2 *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x22") Trie () (? *@"github.com/ethereum/go-ethereum/trie".SecureTrie) { return @"github.com/ethereum/go-ethereum/core/state".self·2.@"github.com/ethereum/go-ethereum/core/state".trie }
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") Update ()
	func (@"github.com/ethereum/go-ethereum/core/state".c·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") @"github.com/ethereum/go-ethereum/core/state".getAddr (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Hash) (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/state".c·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9") @"github.com/ethereum/go-ethereum/core/state".setAddr (@"github.com/ethereum/go-ethereum/core/state".addr·2 []byte, @"github.com/ethereum/go-ethereum/core/state".value·3 @"github.com/ethereum/go-ethereum/common".Hash)
	type @"github.com/ethereum/go-ethereum/core/vm".Account interface { AddBalance(@"github.com/ethereum/go-ethereum/core/vm".amount *@"math/big".Int); Address() (? @"github.com/ethereum/go-ethereum/common".Address); Balance() (? *@"math/big".Int); ReturnGas(? *@"math/big".Int, ? *@"math/big".Int); SetBalance(? *@"math/big".Int); SetCode(? []byte); SetNonce(? uint64); SubBalance(@"github.com/ethereum/go-ethereum/core/vm".amount *@"math/big".Int) }
	type @"github.com/ethereum/go-ethereum/core/state".Account struct { Balance string "json:\"balance\""; Nonce uint64 "json:\"nonce\""; Root string "json:\"root\""; CodeHash string "json:\"codeHash\""; Storage map[string]string "json:\"storage\"" }
	type @"github.com/ethereum/go-ethereum/core/state".World struct { Root string "json:\"root\""; Accounts map[string]@"github.com/ethereum/go-ethereum/core/state".Account "json:\"accounts\"" }
	type @"github.com/ethereum/go-ethereum/core/state".StateDB struct { @"github.com/ethereum/go-ethereum/core/state".db @"github.com/ethereum/go-ethereum/ethdb".Database; @"github.com/ethereum/go-ethereum/core/state".trie *@"github.com/ethereum/go-ethereum/trie".SecureTrie; @"github.com/ethereum/go-ethereum/core/state".stateObjects map[string]*@"github.com/ethereum/go-ethereum/core/state".StateObject; @"github.com/ethereum/go-ethereum/core/state".refund *@"math/big".Int; @"github.com/ethereum/go-ethereum/core/state".thash @"github.com/ethereum/go-ethereum/common".Hash; @"github.com/ethereum/go-ethereum/core/state".bhash @"github.com/ethereum/go-ethereum/common".Hash; @"github.com/ethereum/go-ethereum/core/state".txIndex int; @"github.com/ethereum/go-ethereum/core/state".logs map[@"github.com/ethereum/go-ethereum/common".Hash]@"github.com/ethereum/go-ethereum/core/vm".Logs; @"github.com/ethereum/go-ethereum/core/state".logSize uint }
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") AddBalance (@"github.com/ethereum/go-ethereum/core/state".addr·2 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/core/state".amount·3 *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") AddLog (@"github.com/ethereum/go-ethereum/core/state".log·2 *@"github.com/ethereum/go-ethereum/core/vm".Log) { @"github.com/ethereum/go-ethereum/core/state".log·2.TxHash = @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".thash; @"github.com/ethereum/go-ethereum/core/state".log·2.BlockHash = @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".bhash; @"github.com/ethereum/go-ethereum/core/state".log·2.TxIndex = uint(@"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".txIndex); @"github.com/ethereum/go-ethereum/core/state".log·2.Index = @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".logSize; @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".logs[@"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".thash] = append(@"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".logs[@"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".thash], @"github.com/ethereum/go-ethereum/core/state".log·2); @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".logSize++ }
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") AddRefund (@"github.com/ethereum/go-ethereum/core/state".gas·2 *@"math/big".Int "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/core/state".s·3 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") Commit () (@"github.com/ethereum/go-ethereum/core/state".root·1 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/core/state".err·2 error)
	func (@"github.com/ethereum/go-ethereum/core/state".s·3 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") CommitBatch () (@"github.com/ethereum/go-ethereum/core/state".root·1 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/core/state".batch·2 @"github.com/ethereum/go-ethereum/ethdb".Batch)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") Copy () (? *@"github.com/ethereum/go-ethereum/core/state".StateDB)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") CreateAccount (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? @"github.com/ethereum/go-ethereum/core/vm".Account)
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") CreateOutputForDiff ()
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") CreateStateObject (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? *@"github.com/ethereum/go-ethereum/core/state".StateObject)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") Delete (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? bool)
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") DeleteStateObject (@"github.com/ethereum/go-ethereum/core/state".stateObject·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x1")
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") Dump () (? []byte)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") Exist (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? bool)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") GetAccount (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? @"github.com/ethereum/go-ethereum/core/vm".Account)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") GetBalance (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") GetCode (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? []byte)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x1") GetLogs (@"github.com/ethereum/go-ethereum/core/state".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? @"github.com/ethereum/go-ethereum/core/vm".Logs) { return @"github.com/ethereum/go-ethereum/core/state".self·2.@"github.com/ethereum/go-ethereum/core/state".logs[@"github.com/ethereum/go-ethereum/core/state".hash·3] }
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") GetNonce (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? uint64)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") GetOrNewStateObject (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? *@"github.com/ethereum/go-ethereum/core/state".StateObject)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x22") GetRefund () (? *@"math/big".Int) { return @"github.com/ethereum/go-ethereum/core/state".self·2.@"github.com/ethereum/go-ethereum/core/state".refund }
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") GetState (@"github.com/ethereum/go-ethereum/core/state".a·3 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/core/state".b·4 @"github.com/ethereum/go-ethereum/common".Hash) (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") GetStateObject (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (@"github.com/ethereum/go-ethereum/core/state".stateObject·1 *@"github.com/ethereum/go-ethereum/core/state".StateObject)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") HasAccount (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? bool)
	func (@"github.com/ethereum/go-ethereum/core/state".s·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") IntermediateRoot () (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") IsDeleted (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? bool)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") Logs () (? @"github.com/ethereum/go-ethereum/core/vm".Logs)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") RawDump () (? @"github.com/ethereum/go-ethereum/core/state".World)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x22") Refunds () (? *@"math/big".Int) { return @"github.com/ethereum/go-ethereum/core/state".self·2.@"github.com/ethereum/go-ethereum/core/state".refund }
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x1") Set (@"github.com/ethereum/go-ethereum/core/state".state·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") { @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".trie = @"github.com/ethereum/go-ethereum/core/state".state·2.@"github.com/ethereum/go-ethereum/core/state".trie; @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".stateObjects = @"github.com/ethereum/go-ethereum/core/state".state·2.@"github.com/ethereum/go-ethereum/core/state".stateObjects; @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".refund = @"github.com/ethereum/go-ethereum/core/state".state·2.@"github.com/ethereum/go-ethereum/core/state".refund; @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".logs = @"github.com/ethereum/go-ethereum/core/state".state·2.@"github.com/ethereum/go-ethereum/core/state".logs; @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".logSize = @"github.com/ethereum/go-ethereum/core/state".state·2.@"github.com/ethereum/go-ethereum/core/state".logSize }
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") SetCode (@"github.com/ethereum/go-ethereum/core/state".addr·2 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/core/state".code·3 []byte)
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") SetNonce (@"github.com/ethereum/go-ethereum/core/state".addr·2 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/core/state".nonce·3 uint64)
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") SetState (@"github.com/ethereum/go-ethereum/core/state".addr·2 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/core/state".key·3 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/core/state".value·4 @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x1") SetStateObject (@"github.com/ethereum/go-ethereum/core/state".object·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject) { @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".stateObjects[@"github.com/ethereum/go-ethereum/core/state".object·2.Address().Str()] = @"github.com/ethereum/go-ethereum/core/state".object·2 }
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x1") StartRecord (@"github.com/ethereum/go-ethereum/core/state".thash·2 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/core/state".bhash·3 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/core/state".ti·4 int) { @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".thash = @"github.com/ethereum/go-ethereum/core/state".thash·2; @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".bhash = @"github.com/ethereum/go-ethereum/core/state".bhash·3; @"github.com/ethereum/go-ethereum/core/state".self·1.@"github.com/ethereum/go-ethereum/core/state".txIndex = @"github.com/ethereum/go-ethereum/core/state".ti·4 }
	func (@"github.com/ethereum/go-ethereum/core/state".self·1 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") UpdateStateObject (@"github.com/ethereum/go-ethereum/core/state".stateObject·2 *@"github.com/ethereum/go-ethereum/core/state".StateObject "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/core/state".s·3 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") @"github.com/ethereum/go-ethereum/core/state".commit (@"github.com/ethereum/go-ethereum/core/state".db·4 @"github.com/ethereum/go-ethereum/trie".DatabaseWriter) (? @"github.com/ethereum/go-ethereum/common".Hash, ? error)
	func (@"github.com/ethereum/go-ethereum/core/state".self·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB "esc:0x9") @"github.com/ethereum/go-ethereum/core/state".newStateObject (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? *@"github.com/ethereum/go-ethereum/core/state".StateObject)
	import types "github.com/ethereum/go-ethereum/core/types" // indirect
	type @"github.com/ethereum/go-ethereum/core/types".txdata struct { AccountNonce uint64; Price *@"math/big".Int; GasLimit *@"math/big".Int; Recipient *@"github.com/ethereum/go-ethereum/common".Address "rlp:\"nil\""; Amount *@"math/big".Int; Payload []byte; V byte; R *@"math/big".Int; S *@"math/big".Int }
	import atomic "sync/atomic" // indirect
	type @"sync/atomic".Value struct { @"sync/atomic".v interface {} }
	func (@"sync/atomic".v·2 *@"sync/atomic".Value) Load () (@"sync/atomic".x·1 interface {})
	func (@"sync/atomic".v·1 *@"sync/atomic".Value) Store (@"sync/atomic".x·2 interface {})
	type @"github.com/ethereum/go-ethereum/common".StorageSize float64
	func (@"github.com/ethereum/go-ethereum/common".self·2 @"github.com/ethereum/go-ethereum/common".StorageSize) Int64 () (? int64) { return int64(@"github.com/ethereum/go-ethereum/common".self·2) }
	func (@"github.com/ethereum/go-ethereum/common".self·2 @"github.com/ethereum/go-ethereum/common".StorageSize) String () (? string)
	type @"github.com/ethereum/go-ethereum/core/types".Transaction struct { @"github.com/ethereum/go-ethereum/core/types".data @"github.com/ethereum/go-ethereum/core/types".txdata; @"github.com/ethereum/go-ethereum/core/types".hash @"sync/atomic".Value; @"github.com/ethereum/go-ethereum/core/types".size @"sync/atomic".Value; @"github.com/ethereum/go-ethereum/core/types".from @"sync/atomic".Value }
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9") Cost () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9") Data () (? []byte) { return @"github.com/ethereum/go-ethereum/common".CopyBytes(@"github.com/ethereum/go-ethereum/core/types".tx·2.@"github.com/ethereum/go-ethereum/core/types".data.Payload) }
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction) DecodeRLP (@"github.com/ethereum/go-ethereum/core/types".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream) (? error)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction) EncodeRLP (@"github.com/ethereum/go-ethereum/core/types".w·3 @"io".Writer) (? error)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·3 *@"github.com/ethereum/go-ethereum/core/types".Transaction) From () (? @"github.com/ethereum/go-ethereum/common".Address, ? error)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9") Gas () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9") GasPrice () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction) Hash () (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x1") Nonce () (? uint64) { return @"github.com/ethereum/go-ethereum/core/types".tx·2.@"github.com/ethereum/go-ethereum/core/types".data.AccountNonce }
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9") SigHash () (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·3 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9") SignECDSA (@"github.com/ethereum/go-ethereum/core/types".prv·4 *@"crypto/ecdsa".PrivateKey "esc:0x9") (? *@"github.com/ethereum/go-ethereum/core/types".Transaction, ? error)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·4 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9") SignatureValues () (@"github.com/ethereum/go-ethereum/core/types".v·1 byte, @"github.com/ethereum/go-ethereum/core/types".r·2 *@"math/big".Int, @"github.com/ethereum/go-ethereum/core/types".s·3 *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction) Size () (? @"github.com/ethereum/go-ethereum/common".StorageSize)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction) String () (? string)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x1") To () (? *@"github.com/ethereum/go-ethereum/common".Address) { if @"github.com/ethereum/go-ethereum/core/types".tx·2.@"github.com/ethereum/go-ethereum/core/types".data.Recipient == nil { return nil } else { var @"github.com/ethereum/go-ethereum/core/types".to·3 @"github.com/ethereum/go-ethereum/common".Address; ; @"github.com/ethereum/go-ethereum/core/types".to·3 = *@"github.com/ethereum/go-ethereum/core/types".tx·2.@"github.com/ethereum/go-ethereum/core/types".data.Recipient; return &@"github.com/ethereum/go-ethereum/core/types".to·3 } }
	func (@"github.com/ethereum/go-ethereum/core/types".tx·2 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9") Value () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·3 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0xa") WithSignature (@"github.com/ethereum/go-ethereum/core/types".sig·4 []byte "esc:0x1") (? *@"github.com/ethereum/go-ethereum/core/types".Transaction, ? error)
	func (@"github.com/ethereum/go-ethereum/core/types".tx·3 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9") @"github.com/ethereum/go-ethereum/core/types".publicKey () (? []byte, ? error)
	type @"github.com/ethereum/go-ethereum/core/types".Transactions []*@"github.com/ethereum/go-ethereum/core/types".Transaction
	func (@"github.com/ethereum/go-ethereum/core/types".s·2 @"github.com/ethereum/go-ethereum/core/types".Transactions "esc:0x9") GetRlp (@"github.com/ethereum/go-ethereum/core/types".i·3 int) (? []byte)
	func (@"github.com/ethereum/go-ethereum/core/types".s·2 @"github.com/ethereum/go-ethereum/core/types".Transactions "esc:0x1") Len () (? int) { return len(@"github.com/ethereum/go-ethereum/core/types".s·2) }
	func (@"github.com/ethereum/go-ethereum/core/types".s·1 @"github.com/ethereum/go-ethereum/core/types".Transactions "esc:0x9") Swap (@"github.com/ethereum/go-ethereum/core/types".i·2 int, @"github.com/ethereum/go-ethereum/core/types".j·3 int) { @"github.com/ethereum/go-ethereum/core/types".s·1[@"github.com/ethereum/go-ethereum/core/types".i·2], @"github.com/ethereum/go-ethereum/core/types".s·1[@"github.com/ethereum/go-ethereum/core/types".j·3] = @"github.com/ethereum/go-ethereum/core/types".s·1[@"github.com/ethereum/go-ethereum/core/types".j·3], @"github.com/ethereum/go-ethereum/core/types".s·1[@"github.com/ethereum/go-ethereum/core/types".i·2] }
	type @"github.com/ethereum/go-ethereum/miner".uint64RingBuffer struct { @"github.com/ethereum/go-ethereum/miner".ints []uint64; @"github.com/ethereum/go-ethereum/miner".next int }
	type @"github.com/ethereum/go-ethereum/core/types".Bloom [256]byte
	func (@"github.com/ethereum/go-ethereum/core/types".b·1 *@"github.com/ethereum/go-ethereum/core/types".Bloom "esc:0x1") Add (@"github.com/ethereum/go-ethereum/core/types".d·2 *@"math/big".Int "esc:0x1")
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 @"github.com/ethereum/go-ethereum/core/types".Bloom) Big () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 @"github.com/ethereum/go-ethereum/core/types".Bloom) Bytes () (? []byte) { return @"github.com/ethereum/go-ethereum/core/types".b·2[:] }
	func (@"github.com/ethereum/go-ethereum/core/types".b·1 *@"github.com/ethereum/go-ethereum/core/types".Bloom "esc:0x1") SetBytes (@"github.com/ethereum/go-ethereum/core/types".d·2 []byte "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 @"github.com/ethereum/go-ethereum/core/types".Bloom) Test (@"github.com/ethereum/go-ethereum/core/types".test·3 *@"math/big".Int) (? bool)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 @"github.com/ethereum/go-ethereum/core/types".Bloom) TestBytes (@"github.com/ethereum/go-ethereum/core/types".test·3 []byte "esc:0x1") (? bool)
	type @"github.com/ethereum/go-ethereum/core/types".BlockNonce [8]byte
	func (@"github.com/ethereum/go-ethereum/core/types".n·2 @"github.com/ethereum/go-ethereum/core/types".BlockNonce) Uint64 () (? uint64) { return @"encoding/binary".BigEndian.Uint64(@"github.com/ethereum/go-ethereum/core/types".n·2[:]) }
	type @"github.com/ethereum/go-ethereum/core/types".Header struct { ParentHash @"github.com/ethereum/go-ethereum/common".Hash; UncleHash @"github.com/ethereum/go-ethereum/common".Hash; Coinbase @"github.com/ethereum/go-ethereum/common".Address; Root @"github.com/ethereum/go-ethereum/common".Hash; TxHash @"github.com/ethereum/go-ethereum/common".Hash; ReceiptHash @"github.com/ethereum/go-ethereum/common".Hash; Bloom @"github.com/ethereum/go-ethereum/core/types".Bloom; Difficulty *@"math/big".Int; Number *@"math/big".Int; GasLimit *@"math/big".Int; GasUsed *@"math/big".Int; Time *@"math/big".Int; Extra []byte; MixDigest @"github.com/ethereum/go-ethereum/common".Hash; Nonce @"github.com/ethereum/go-ethereum/core/types".BlockNonce }
	func (@"github.com/ethereum/go-ethereum/core/types".h·2 *@"github.com/ethereum/go-ethereum/core/types".Header) Hash () (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/types".h·2 *@"github.com/ethereum/go-ethereum/core/types".Header "esc:0x9") HashNoNonce () (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/types".h·2 *@"github.com/ethereum/go-ethereum/core/types".Header) String () (? string)
	func (@"github.com/ethereum/go-ethereum/core/types".h·2 *@"github.com/ethereum/go-ethereum/core/types".Header "esc:0x1") UnmarshalJSON (@"github.com/ethereum/go-ethereum/core/types".data·3 []byte) (? error)
	type @"github.com/ethereum/go-ethereum/core/types".Block struct { @"github.com/ethereum/go-ethereum/core/types".header *@"github.com/ethereum/go-ethereum/core/types".Header; @"github.com/ethereum/go-ethereum/core/types".uncles []*@"github.com/ethereum/go-ethereum/core/types".Header; @"github.com/ethereum/go-ethereum/core/types".transactions @"github.com/ethereum/go-ethereum/core/types".Transactions; @"github.com/ethereum/go-ethereum/core/types".hash @"sync/atomic".Value; @"github.com/ethereum/go-ethereum/core/types".size @"sync/atomic".Value; @"github.com/ethereum/go-ethereum/core/types".td *@"math/big".Int; ReceivedAt @"time".Time }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") Bloom () (? @"github.com/ethereum/go-ethereum/core/types".Bloom) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header.Bloom }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") Coinbase () (? @"github.com/ethereum/go-ethereum/common".Address) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header.Coinbase }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block) DecodeRLP (@"github.com/ethereum/go-ethereum/core/types".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream) (? error)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x22") DeprecatedTd () (? *@"math/big".Int) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".td }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9") Difficulty () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9") EncodeRLP (@"github.com/ethereum/go-ethereum/core/types".w·3 @"io".Writer) (? error)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9") Extra () (? []byte) { return @"github.com/ethereum/go-ethereum/common".CopyBytes(@"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header.Extra) }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9") GasLimit () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9") GasUsed () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block) Hash () (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9") HashNoNonce () (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9") Header () (? *@"github.com/ethereum/go-ethereum/core/types".Header)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") MixDigest () (? @"github.com/ethereum/go-ethereum/common".Hash) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header.MixDigest }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") Nonce () (? uint64) { return @"encoding/binary".BigEndian.Uint64(@"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header.Nonce[:]) }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9") Number () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") NumberU64 () (? uint64) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header.Number.Uint64() }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") ParentHash () (? @"github.com/ethereum/go-ethereum/common".Hash) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header.ParentHash }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") ReceiptHash () (? @"github.com/ethereum/go-ethereum/common".Hash) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header.ReceiptHash }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") Root () (? @"github.com/ethereum/go-ethereum/common".Hash) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header.Root }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block) Size () (? @"github.com/ethereum/go-ethereum/common".StorageSize)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block) String () (? string)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9") Time () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x3a") Transaction (@"github.com/ethereum/go-ethereum/core/types".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? *@"github.com/ethereum/go-ethereum/core/types".Transaction)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x22") Transactions () (? @"github.com/ethereum/go-ethereum/core/types".Transactions) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".transactions }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") TxHash () (? @"github.com/ethereum/go-ethereum/common".Hash) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header.TxHash }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") UncleHash () (? @"github.com/ethereum/go-ethereum/common".Hash) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header.UncleHash }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x22") Uncles () (? []*@"github.com/ethereum/go-ethereum/core/types".Header) { return @"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".uncles }
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") ValidateFields () (? error)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9") WithBody (@"github.com/ethereum/go-ethereum/core/types".transactions·3 []*@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9", @"github.com/ethereum/go-ethereum/core/types".uncles·4 []*@"github.com/ethereum/go-ethereum/core/types".Header "esc:0x9") (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/core/types".b·2 *@"github.com/ethereum/go-ethereum/core/types".Block) WithMiningResult (@"github.com/ethereum/go-ethereum/core/types".nonce·3 uint64, @"github.com/ethereum/go-ethereum/core/types".mixDigest·4 @"github.com/ethereum/go-ethereum/common".Hash) (? *@"github.com/ethereum/go-ethereum/core/types".Block) { var @"github.com/ethereum/go-ethereum/core/types".cpy·5 @"github.com/ethereum/go-ethereum/core/types".Header; ; @"github.com/ethereum/go-ethereum/core/types".cpy·5 = *@"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".header; @"encoding/binary".BigEndian.PutUint64(@"github.com/ethereum/go-ethereum/core/types".cpy·5.Nonce[:], @"github.com/ethereum/go-ethereum/core/types".nonce·3); @"github.com/ethereum/go-ethereum/core/types".cpy·5.MixDigest = @"github.com/ethereum/go-ethereum/core/types".mixDigest·4; return (&@"github.com/ethereum/go-ethereum/core/types".Block{ @"github.com/ethereum/go-ethereum/core/types".header:&@"github.com/ethereum/go-ethereum/core/types".cpy·5, @"github.com/ethereum/go-ethereum/core/types".transactions:@"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".transactions, @"github.com/ethereum/go-ethereum/core/types".uncles:@"github.com/ethereum/go-ethereum/core/types".b·2.@"github.com/ethereum/go-ethereum/core/types".uncles }) }
	type @"github.com/ethereum/go-ethereum/core/types".Receipt struct { PostState []byte; CumulativeGasUsed *@"math/big".Int; Bloom @"github.com/ethereum/go-ethereum/core/types".Bloom; Logs @"github.com/ethereum/go-ethereum/core/vm".Logs; TxHash @"github.com/ethereum/go-ethereum/common".Hash; ContractAddress @"github.com/ethereum/go-ethereum/common".Address; GasUsed *@"math/big".Int }
	func (@"github.com/ethereum/go-ethereum/core/types".r·2 *@"github.com/ethereum/go-ethereum/core/types".Receipt "esc:0x1") DecodeRLP (@"github.com/ethereum/go-ethereum/core/types".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream) (? error)
	func (@"github.com/ethereum/go-ethereum/core/types".r·2 *@"github.com/ethereum/go-ethereum/core/types".Receipt "esc:0x9") EncodeRLP (@"github.com/ethereum/go-ethereum/core/types".w·3 @"io".Writer) (? error)
	func (@"github.com/ethereum/go-ethereum/core/types".r·2 *@"github.com/ethereum/go-ethereum/core/types".Receipt) RlpEncode () (? []byte)
	func (@"github.com/ethereum/go-ethereum/core/types".r·2 *@"github.com/ethereum/go-ethereum/core/types".Receipt "esc:0x9") String () (? string)
	import core "github.com/ethereum/go-ethereum/core" // indirect
	import lru "github.com/hashicorp/golang-lru" // indirect
	import list "container/list" // indirect
	type @"container/list".Element struct { @"container/list".next *@"container/list".Element; @"container/list".prev *@"container/list".Element; @"container/list".list *@"container/list".List; Value interface {} }
	func (@"container/list".e·2 *@"container/list".Element "esc:0x22") Next () (? *@"container/list".Element) { var @"container/list".p·3 *@"container/list".Element; ; @"container/list".p·3 = @"container/list".e·2.@"container/list".next; if @"container/list".e·2.@"container/list".list != nil && @"container/list".p·3 != &@"container/list".e·2.@"container/list".list.@"container/list".root { return @"container/list".p·3 }; return nil }
	func (@"container/list".e·2 *@"container/list".Element "esc:0x22") Prev () (? *@"container/list".Element) { var @"container/list".p·3 *@"container/list".Element; ; @"container/list".p·3 = @"container/list".e·2.@"container/list".prev; if @"container/list".e·2.@"container/list".list != nil && @"container/list".p·3 != &@"container/list".e·2.@"container/list".list.@"container/list".root { return @"container/list".p·3 }; return nil }
	type @"container/list".List struct { @"container/list".root @"container/list".Element; @"container/list".len int }
	func (@"container/list".l·2 *@"container/list".List "esc:0x22") Back () (? *@"container/list".Element) { if @"container/list".l·2.@"container/list".len == 0x0 { return nil }; return @"container/list".l·2.@"container/list".root.@"container/list".prev }
	func (@"container/list".l·2 *@"container/list".List "esc:0x22") Front () (? *@"container/list".Element) { if @"container/list".l·2.@"container/list".len == 0x0 { return nil }; return @"container/list".l·2.@"container/list".root.@"container/list".next }
	func (@"container/list".l·2 *@"container/list".List) Init () (? *@"container/list".List) { @"container/list".l·2.@"container/list".root.@"container/list".next = &@"container/list".l·2.@"container/list".root; @"container/list".l·2.@"container/list".root.@"container/list".prev = &@"container/list".l·2.@"container/list".root; @"container/list".l·2.@"container/list".len = 0x0; return @"container/list".l·2 }
	func (@"container/list".l·2 *@"container/list".List) InsertAfter (@"container/list".v·3 interface {}, @"container/list".mark·4 *@"container/list".Element) (? *@"container/list".Element) { if @"container/list".mark·4.@"container/list".list != @"container/list".l·2 { return nil }; return @"container/list".l·2.@"container/list".insertValue(@"container/list".v·3, @"container/list".mark·4) }
	func (@"container/list".l·2 *@"container/list".List) InsertBefore (@"container/list".v·3 interface {}, @"container/list".mark·4 *@"container/list".Element "esc:0x9") (? *@"container/list".Element) { if @"container/list".mark·4.@"container/list".list != @"container/list".l·2 { return nil }; return @"container/list".l·2.@"container/list".insertValue(@"container/list".v·3, @"container/list".mark·4.@"container/list".prev) }
	func (@"container/list".l·2 *@"container/list".List "esc:0x1") Len () (? int) { return @"container/list".l·2.@"container/list".len }
	func (@"container/list".l·1 *@"container/list".List) MoveAfter (@"container/list".e·2 *@"container/list".Element, @"container/list".mark·3 *@"container/list".Element)
	func (@"container/list".l·1 *@"container/list".List) MoveBefore (@"container/list".e·2 *@"container/list".Element, @"container/list".mark·3 *@"container/list".Element "esc:0x9")
	func (@"container/list".l·1 *@"container/list".List) MoveToBack (@"container/list".e·2 *@"container/list".Element)
	func (@"container/list".l·1 *@"container/list".List) MoveToFront (@"container/list".e·2 *@"container/list".Element)
	func (@"container/list".l·2 *@"container/list".List) PushBack (@"container/list".v·3 interface {}) (? *@"container/list".Element)
	func (@"container/list".l·1 *@"container/list".List) PushBackList (@"container/list".other·2 *@"container/list".List "esc:0x9")
	func (@"container/list".l·2 *@"container/list".List) PushFront (@"container/list".v·3 interface {}) (? *@"container/list".Element)
	func (@"container/list".l·1 *@"container/list".List) PushFrontList (@"container/list".other·2 *@"container/list".List "esc:0x9")
	func (@"container/list".l·2 *@"container/list".List "esc:0x1") Remove (@"container/list".e·3 *@"container/list".Element "esc:0x2a") (? interface {}) { if @"container/list".e·3.@"container/list".list == @"container/list".l·2 { @"container/list".l·2.@"container/list".remove(@"container/list".e·3) }; return @"container/list".e·3.Value }
	func (@"container/list".l·2 *@"container/list".List) @"container/list".insert (@"container/list".e·3 *@"container/list".Element, @"container/list".at·4 *@"container/list".Element) (? *@"container/list".Element) { var @"container/list".n·5 *@"container/list".Element; ; @"container/list".n·5 = @"container/list".at·4.@"container/list".next; @"container/list".at·4.@"container/list".next = @"container/list".e·3; @"container/list".e·3.@"container/list".prev = @"container/list".at·4; @"container/list".e·3.@"container/list".next = @"container/list".n·5; @"container/list".n·5.@"container/list".prev = @"container/list".e·3; @"container/list".e·3.@"container/list".list = @"container/list".l·2; @"container/list".l·2.@"container/list".len++; return @"container/list".e·3 }
	func (@"container/list".l·2 *@"container/list".List) @"container/list".insertValue (@"container/list".v·3 interface {}, @"container/list".at·4 *@"container/list".Element) (? *@"container/list".Element) { return @"container/list".l·2.@"container/list".insert((&@"container/list".Element{ Value:@"container/list".v·3 }), @"container/list".at·4) }
	func (@"container/list".l·1 *@"container/list".List) @"container/list".lazyInit () { if @"container/list".l·1.@"container/list".root.@"container/list".next == nil { @"container/list".l·1.Init() } }
	func (@"container/list".l·2 *@"container/list".List "esc:0x1") @"container/list".remove (@"container/list".e·3 *@"container/list".Element "esc:0x1a") (? *@"container/list".Element) { @"container/list".e·3.@"container/list".prev.@"container/list".next = @"container/list".e·3.@"container/list".next; @"container/list".e·3.@"container/list".next.@"container/list".prev = @"container/list".e·3.@"container/list".prev; @"container/list".e·3.@"container/list".next = nil; @"container/list".e·3.@"container/list".prev = nil; @"container/list".e·3.@"container/list".list = nil; @"container/list".l·2.@"container/list".len--; return @"container/list".e·3 }
	type @"github.com/hashicorp/golang-lru".Cache struct { @"github.com/hashicorp/golang-lru".size int; @"github.com/hashicorp/golang-lru".evictList *@"container/list".List; @"github.com/hashicorp/golang-lru".items map[interface {}]*@"container/list".Element; @"github.com/hashicorp/golang-lru".lock @"sync".RWMutex; @"github.com/hashicorp/golang-lru".onEvicted func(@"github.com/hashicorp/golang-lru".key interface {}, @"github.com/hashicorp/golang-lru".value interface {}) }
	func (@"github.com/hashicorp/golang-lru".c·2 *@"github.com/hashicorp/golang-lru".Cache) Add (@"github.com/hashicorp/golang-lru".key·3 interface {}, @"github.com/hashicorp/golang-lru".value·4 interface {}) (? bool)
	func (@"github.com/hashicorp/golang-lru".c·2 *@"github.com/hashicorp/golang-lru".Cache) Contains (@"github.com/hashicorp/golang-lru".key·3 interface {} "esc:0x1") (@"github.com/hashicorp/golang-lru".ok·1 bool)
	func (@"github.com/hashicorp/golang-lru".c·3 *@"github.com/hashicorp/golang-lru".Cache) Get (@"github.com/hashicorp/golang-lru".key·4 interface {} "esc:0x1") (@"github.com/hashicorp/golang-lru".value·1 interface {}, @"github.com/hashicorp/golang-lru".ok·2 bool)
	func (@"github.com/hashicorp/golang-lru".c·2 *@"github.com/hashicorp/golang-lru".Cache) Keys () (? []interface {})
	func (@"github.com/hashicorp/golang-lru".c·2 *@"github.com/hashicorp/golang-lru".Cache) Len () (? int)
	func (@"github.com/hashicorp/golang-lru".c·3 *@"github.com/hashicorp/golang-lru".Cache) Peek (@"github.com/hashicorp/golang-lru".key·4 interface {} "esc:0x1") (@"github.com/hashicorp/golang-lru".value·1 interface {}, @"github.com/hashicorp/golang-lru".ok·2 bool)
	func (@"github.com/hashicorp/golang-lru".c·1 *@"github.com/hashicorp/golang-lru".Cache) Purge ()
	func (@"github.com/hashicorp/golang-lru".c·1 *@"github.com/hashicorp/golang-lru".Cache) Remove (@"github.com/hashicorp/golang-lru".key·2 interface {} "esc:0x1")
	func (@"github.com/hashicorp/golang-lru".c·1 *@"github.com/hashicorp/golang-lru".Cache) RemoveOldest ()
	func (@"github.com/hashicorp/golang-lru".c·1 *@"github.com/hashicorp/golang-lru".Cache "esc:0x1") @"github.com/hashicorp/golang-lru".removeElement (@"github.com/hashicorp/golang-lru".e·2 *@"container/list".Element "esc:0x9")
	func (@"github.com/hashicorp/golang-lru".c·1 *@"github.com/hashicorp/golang-lru".Cache "esc:0x9") @"github.com/hashicorp/golang-lru".removeOldest ()
	import pow "github.com/ethereum/go-ethereum/pow" // indirect
	type @"github.com/ethereum/go-ethereum/pow".Block interface { Difficulty() (? *@"math/big".Int); HashNoNonce() (? @"github.com/ethereum/go-ethereum/common".Hash); MixDigest() (? @"github.com/ethereum/go-ethereum/common".Hash); Nonce() (? uint64); NumberU64() (? uint64) }
	type @"github.com/ethereum/go-ethereum/pow".PoW interface { GetHashrate() (? int64); Search(@"github.com/ethereum/go-ethereum/pow".block @"github.com/ethereum/go-ethereum/pow".Block, @"github.com/ethereum/go-ethereum/pow".stop <-chan struct {}, @"github.com/ethereum/go-ethereum/pow".index int) (? uint64, ? []byte); Turbo(? bool); Verify(@"github.com/ethereum/go-ethereum/pow".block @"github.com/ethereum/go-ethereum/pow".Block) (? bool) }
	type @"github.com/ethereum/go-ethereum/core/types".Receipts []*@"github.com/ethereum/go-ethereum/core/types".Receipt
	func (@"github.com/ethereum/go-ethereum/core/types".r·2 @"github.com/ethereum/go-ethereum/core/types".Receipts "esc:0x9") GetRlp (@"github.com/ethereum/go-ethereum/core/types".i·3 int) (? []byte)
	func (@"github.com/ethereum/go-ethereum/core/types".r·2 @"github.com/ethereum/go-ethereum/core/types".Receipts "esc:0x1") Len () (? int) { return len(@"github.com/ethereum/go-ethereum/core/types".r·2) }
	func (@"github.com/ethereum/go-ethereum/core/types".r·2 @"github.com/ethereum/go-ethereum/core/types".Receipts) RlpEncode () (? []byte)
	type @"github.com/ethereum/go-ethereum/core".Processor interface { Process(@"github.com/ethereum/go-ethereum/core".block *@"github.com/ethereum/go-ethereum/core/types".Block, @"github.com/ethereum/go-ethereum/core".statedb *@"github.com/ethereum/go-ethereum/core/state".StateDB) (? @"github.com/ethereum/go-ethereum/core/types".Receipts, ? @"github.com/ethereum/go-ethereum/core/vm".Logs, ? *@"math/big".Int, ? error) }
	type @"github.com/ethereum/go-ethereum/core".Validator interface { ValidateBlock(@"github.com/ethereum/go-ethereum/core".block *@"github.com/ethereum/go-ethereum/core/types".Block) (? error); ValidateHeader(@"github.com/ethereum/go-ethereum/core".header *@"github.com/ethereum/go-ethereum/core/types".Header, @"github.com/ethereum/go-ethereum/core".parent *@"github.com/ethereum/go-ethereum/core/types".Header, @"github.com/ethereum/go-ethereum/core".checkPow bool) (? error); ValidateState(@"github.com/ethereum/go-ethereum/core".block *@"github.com/ethereum/go-ethereum/core/types".Block, @"github.com/ethereum/go-ethereum/core".parent *@"github.com/ethereum/go-ethereum/core/types".Block, @"github.com/ethereum/go-ethereum/core".state *@"github.com/ethereum/go-ethereum/core/state".StateDB, @"github.com/ethereum/go-ethereum/core".receipts @"github.com/ethereum/go-ethereum/core/types".Receipts, @"github.com/ethereum/go-ethereum/core".usedGas *@"math/big".Int) (? error) }
	type @"github.com/ethereum/go-ethereum/core/types".Body struct { Transactions []*@"github.com/ethereum/go-ethereum/core/types".Transaction; Uncles []*@"github.com/ethereum/go-ethereum/core/types".Header }
	type @"github.com/ethereum/go-ethereum/core/types".Blocks []*@"github.com/ethereum/go-ethereum/core/types".Block
	type @"github.com/ethereum/go-ethereum/core".writeStatus uint8
	type @"github.com/ethereum/go-ethereum/core".BlockChain struct { @"github.com/ethereum/go-ethereum/core".chainDb @"github.com/ethereum/go-ethereum/ethdb".Database; @"github.com/ethereum/go-ethereum/core".eventMux *@"github.com/ethereum/go-ethereum/event".TypeMux; @"github.com/ethereum/go-ethereum/core".genesisBlock *@"github.com/ethereum/go-ethereum/core/types".Block; @"github.com/ethereum/go-ethereum/core".mu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/core".chainmu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/core".tsmu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/core".procmu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/core".checkpoint int; @"github.com/ethereum/go-ethereum/core".currentHeader *@"github.com/ethereum/go-ethereum/core/types".Header; @"github.com/ethereum/go-ethereum/core".currentBlock *@"github.com/ethereum/go-ethereum/core/types".Block; @"github.com/ethereum/go-ethereum/core".currentFastBlock *@"github.com/ethereum/go-ethereum/core/types".Block; @"github.com/ethereum/go-ethereum/core".headerCache *@"github.com/hashicorp/golang-lru".Cache; @"github.com/ethereum/go-ethereum/core".bodyCache *@"github.com/hashicorp/golang-lru".Cache; @"github.com/ethereum/go-ethereum/core".bodyRLPCache *@"github.com/hashicorp/golang-lru".Cache; @"github.com/ethereum/go-ethereum/core".tdCache *@"github.com/hashicorp/golang-lru".Cache; @"github.com/ethereum/go-ethereum/core".blockCache *@"github.com/hashicorp/golang-lru".Cache; @"github.com/ethereum/go-ethereum/core".futureBlocks *@"github.com/hashicorp/golang-lru".Cache; @"github.com/ethereum/go-ethereum/core".quit chan struct {}; @"github.com/ethereum/go-ethereum/core".running int32; @"github.com/ethereum/go-ethereum/core".procInterrupt int32; @"github.com/ethereum/go-ethereum/core".wg @"sync".WaitGroup; @"github.com/ethereum/go-ethereum/core".pow @"github.com/ethereum/go-ethereum/pow".PoW; @"github.com/ethereum/go-ethereum/core".rand *@"math/rand".Rand; @"github.com/ethereum/go-ethereum/core".processor @"github.com/ethereum/go-ethereum/core".Processor; @"github.com/ethereum/go-ethereum/core".validator @"github.com/ethereum/go-ethereum/core".Validator }
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x22") AuxValidator () (? @"github.com/ethereum/go-ethereum/pow".PoW) { return @"github.com/ethereum/go-ethereum/core".self·2.@"github.com/ethereum/go-ethereum/core".pow }
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) CurrentBlock () (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) CurrentFastBlock () (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) CurrentHeader () (? *@"github.com/ethereum/go-ethereum/core/types".Header)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) Export (@"github.com/ethereum/go-ethereum/core".w·3 @"io".Writer) (? error)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) ExportN (@"github.com/ethereum/go-ethereum/core".w·3 @"io".Writer, @"github.com/ethereum/go-ethereum/core".first·4 uint64, @"github.com/ethereum/go-ethereum/core".last·5 uint64) (? error)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) FastSyncCommitHead (@"github.com/ethereum/go-ethereum/core".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? error)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) GasLimit () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core".bc·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x22") Genesis () (? *@"github.com/ethereum/go-ethereum/core/types".Block) { return @"github.com/ethereum/go-ethereum/core".bc·2.@"github.com/ethereum/go-ethereum/core".genesisBlock }
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") GetBlock (@"github.com/ethereum/go-ethereum/core".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") GetBlockByNumber (@"github.com/ethereum/go-ethereum/core".number·3 uint64) (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") GetBlockHashesFromHash (@"github.com/ethereum/go-ethereum/core".hash·3 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/core".max·4 uint64) (? []@"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") GetBlocksFromHash (@"github.com/ethereum/go-ethereum/core".hash·3 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/core".n·4 int) (@"github.com/ethereum/go-ethereum/core".blocks·1 []*@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") GetBody (@"github.com/ethereum/go-ethereum/core".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? *@"github.com/ethereum/go-ethereum/core/types".Body)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") GetBodyRLP (@"github.com/ethereum/go-ethereum/core".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? @"github.com/ethereum/go-ethereum/rlp".RawValue)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") GetHeader (@"github.com/ethereum/go-ethereum/core".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? *@"github.com/ethereum/go-ethereum/core/types".Header)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") GetHeaderByNumber (@"github.com/ethereum/go-ethereum/core".number·3 uint64) (? *@"github.com/ethereum/go-ethereum/core/types".Header)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") GetTd (@"github.com/ethereum/go-ethereum/core".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") GetUnclesInChain (@"github.com/ethereum/go-ethereum/core".block·3 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9", @"github.com/ethereum/go-ethereum/core".length·4 int) (? []*@"github.com/ethereum/go-ethereum/core/types".Header)
	func (@"github.com/ethereum/go-ethereum/core".bc·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") HasBlock (@"github.com/ethereum/go-ethereum/core".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? bool)
	func (@"github.com/ethereum/go-ethereum/core".bc·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") HasHeader (@"github.com/ethereum/go-ethereum/core".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? bool)
	func (@"github.com/ethereum/go-ethereum/core".self·3 *@"github.com/ethereum/go-ethereum/core".BlockChain) InsertChain (@"github.com/ethereum/go-ethereum/core".chain·4 @"github.com/ethereum/go-ethereum/core/types".Blocks "esc:0x9") (? int, ? error)
	func (@"github.com/ethereum/go-ethereum/core".self·3 *@"github.com/ethereum/go-ethereum/core".BlockChain) InsertHeaderChain (@"github.com/ethereum/go-ethereum/core".chain·4 []*@"github.com/ethereum/go-ethereum/core/types".Header, @"github.com/ethereum/go-ethereum/core".checkFreq·5 int) (? int, ? error)
	func (@"github.com/ethereum/go-ethereum/core".self·3 *@"github.com/ethereum/go-ethereum/core".BlockChain) InsertReceiptChain (@"github.com/ethereum/go-ethereum/core".blockChain·4 @"github.com/ethereum/go-ethereum/core/types".Blocks, @"github.com/ethereum/go-ethereum/core".receiptChain·5 []@"github.com/ethereum/go-ethereum/core/types".Receipts) (? int, ? error)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) LastBlockHash () (? @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) Processor () (? @"github.com/ethereum/go-ethereum/core".Processor)
	func (@"github.com/ethereum/go-ethereum/core".bc·1 *@"github.com/ethereum/go-ethereum/core".BlockChain) Reset ()
	func (@"github.com/ethereum/go-ethereum/core".bc·1 *@"github.com/ethereum/go-ethereum/core".BlockChain) ResetWithGenesisBlock (@"github.com/ethereum/go-ethereum/core".genesis·2 *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/core".self·1 *@"github.com/ethereum/go-ethereum/core".BlockChain) Rollback (@"github.com/ethereum/go-ethereum/core".chain·2 []@"github.com/ethereum/go-ethereum/common".Hash "esc:0x1")
	func (@"github.com/ethereum/go-ethereum/core".bc·1 *@"github.com/ethereum/go-ethereum/core".BlockChain) SetHead (@"github.com/ethereum/go-ethereum/core".head·2 uint64)
	func (@"github.com/ethereum/go-ethereum/core".self·1 *@"github.com/ethereum/go-ethereum/core".BlockChain) SetProcessor (@"github.com/ethereum/go-ethereum/core".processor·2 @"github.com/ethereum/go-ethereum/core".Processor)
	func (@"github.com/ethereum/go-ethereum/core".self·1 *@"github.com/ethereum/go-ethereum/core".BlockChain) SetValidator (@"github.com/ethereum/go-ethereum/core".validator·2 @"github.com/ethereum/go-ethereum/core".Validator)
	func (@"github.com/ethereum/go-ethereum/core".self·3 *@"github.com/ethereum/go-ethereum/core".BlockChain) State () (? *@"github.com/ethereum/go-ethereum/core/state".StateDB, ? error)
	func (@"github.com/ethereum/go-ethereum/core".self·4 *@"github.com/ethereum/go-ethereum/core".BlockChain) Status () (@"github.com/ethereum/go-ethereum/core".td·1 *@"math/big".Int, @"github.com/ethereum/go-ethereum/core".currentBlock·2 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/core".genesisBlock·3 @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core".bc·1 *@"github.com/ethereum/go-ethereum/core".BlockChain) Stop ()
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) Validator () (? @"github.com/ethereum/go-ethereum/core".Validator)
	func (@"github.com/ethereum/go-ethereum/core".self·3 *@"github.com/ethereum/go-ethereum/core".BlockChain) WriteBlock (@"github.com/ethereum/go-ethereum/core".block·4 *@"github.com/ethereum/go-ethereum/core/types".Block) (@"github.com/ethereum/go-ethereum/core".status·1 @"github.com/ethereum/go-ethereum/core".writeStatus, @"github.com/ethereum/go-ethereum/core".err·2 error)
	func (@"github.com/ethereum/go-ethereum/core".bc·1 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") @"github.com/ethereum/go-ethereum/core".insert (@"github.com/ethereum/go-ethereum/core".block·2 *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) @"github.com/ethereum/go-ethereum/core".loadLastState () (? error)
	func (@"github.com/ethereum/go-ethereum/core".self·1 *@"github.com/ethereum/go-ethereum/core".BlockChain) @"github.com/ethereum/go-ethereum/core".postChainEvents (@"github.com/ethereum/go-ethereum/core".events·2 []interface {} "esc:0x9", @"github.com/ethereum/go-ethereum/core".logs·3 @"github.com/ethereum/go-ethereum/core/vm".Logs)
	func (@"github.com/ethereum/go-ethereum/core".self·1 *@"github.com/ethereum/go-ethereum/core".BlockChain) @"github.com/ethereum/go-ethereum/core".procFutureBlocks ()
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain "esc:0x9") @"github.com/ethereum/go-ethereum/core".reorg (@"github.com/ethereum/go-ethereum/core".oldBlock·3 *@"github.com/ethereum/go-ethereum/core/types".Block, @"github.com/ethereum/go-ethereum/core".newBlock·4 *@"github.com/ethereum/go-ethereum/core/types".Block) (? error)
	func (@"github.com/ethereum/go-ethereum/core".self·1 *@"github.com/ethereum/go-ethereum/core".BlockChain) @"github.com/ethereum/go-ethereum/core".update ()
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".BlockChain) @"github.com/ethereum/go-ethereum/core".writeHeader (@"github.com/ethereum/go-ethereum/core".header·3 *@"github.com/ethereum/go-ethereum/core/types".Header) (? error)
	type @"github.com/ethereum/go-ethereum/core".GasPool struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
	func (@"github.com/ethereum/go-ethereum/core".gp·2 *@"github.com/ethereum/go-ethereum/core".GasPool "esc:0x1a") AddGas (@"github.com/ethereum/go-ethereum/core".amount·3 *@"math/big".Int "esc:0x9") (? *@"github.com/ethereum/go-ethereum/core".GasPool)
	func (@"github.com/ethereum/go-ethereum/core".gp·2 *@"github.com/ethereum/go-ethereum/core".GasPool "esc:0x9") String () (? string)
	func (@"github.com/ethereum/go-ethereum/core".gp·2 *@"github.com/ethereum/go-ethereum/core".GasPool "esc:0x9") SubGas (@"github.com/ethereum/go-ethereum/core".amount·3 *@"math/big".Int) (? error)
	type @"github.com/ethereum/go-ethereum/miner".Work struct { @"github.com/ethereum/go-ethereum/miner".state *@"github.com/ethereum/go-ethereum/core/state".StateDB; @"github.com/ethereum/go-ethereum/miner".ancestors *@"gopkg.in/fatih/set.v0".Set; @"github.com/ethereum/go-ethereum/miner".family *@"gopkg.in/fatih/set.v0".Set; @"github.com/ethereum/go-ethereum/miner".uncles *@"gopkg.in/fatih/set.v0".Set; @"github.com/ethereum/go-ethereum/miner".remove *@"gopkg.in/fatih/set.v0".Set; @"github.com/ethereum/go-ethereum/miner".tcount int; @"github.com/ethereum/go-ethereum/miner".ignoredTransactors *@"gopkg.in/fatih/set.v0".Set; @"github.com/ethereum/go-ethereum/miner".lowGasTransactors *@"gopkg.in/fatih/set.v0".Set; @"github.com/ethereum/go-ethereum/miner".ownedAccounts *@"gopkg.in/fatih/set.v0".Set; @"github.com/ethereum/go-ethereum/miner".lowGasTxs @"github.com/ethereum/go-ethereum/core/types".Transactions; @"github.com/ethereum/go-ethereum/miner".localMinedBlocks *@"github.com/ethereum/go-ethereum/miner".uint64RingBuffer; Block *@"github.com/ethereum/go-ethereum/core/types".Block; @"github.com/ethereum/go-ethereum/miner".header *@"github.com/ethereum/go-ethereum/core/types".Header; @"github.com/ethereum/go-ethereum/miner".txs []*@"github.com/ethereum/go-ethereum/core/types".Transaction; @"github.com/ethereum/go-ethereum/miner".receipts []*@"github.com/ethereum/go-ethereum/core/types".Receipt; @"github.com/ethereum/go-ethereum/miner".createdAt @"time".Time }
	func (@"github.com/ethereum/go-ethereum/miner".env·2 *@"github.com/ethereum/go-ethereum/miner".Work "esc:0x9") @"github.com/ethereum/go-ethereum/miner".commitTransaction (@"github.com/ethereum/go-ethereum/miner".tx·3 *@"github.com/ethereum/go-ethereum/core/types".Transaction, @"github.com/ethereum/go-ethereum/miner".bc·4 *@"github.com/ethereum/go-ethereum/core".BlockChain, @"github.com/ethereum/go-ethereum/miner".gp·5 *@"github.com/ethereum/go-ethereum/core".GasPool) (? error)
	func (@"github.com/ethereum/go-ethereum/miner".env·1 *@"github.com/ethereum/go-ethereum/miner".Work "esc:0x9") @"github.com/ethereum/go-ethereum/miner".commitTransactions (@"github.com/ethereum/go-ethereum/miner".transactions·2 @"github.com/ethereum/go-ethereum/core/types".Transactions "esc:0x9", @"github.com/ethereum/go-ethereum/miner".gasPrice·3 *@"math/big".Int, @"github.com/ethereum/go-ethereum/miner".bc·4 *@"github.com/ethereum/go-ethereum/core".BlockChain)
	type @"github.com/ethereum/go-ethereum/miner".Result struct { Work *@"github.com/ethereum/go-ethereum/miner".Work; Block *@"github.com/ethereum/go-ethereum/core/types".Block }
	type @"github.com/ethereum/go-ethereum/miner".hashrate struct { @"github.com/ethereum/go-ethereum/miner".ping @"time".Time; @"github.com/ethereum/go-ethereum/miner".rate uint64 }
	type @"github.com/ethereum/go-ethereum/miner".RemoteAgent struct { @"github.com/ethereum/go-ethereum/miner".mu @"sync".Mutex; @"github.com/ethereum/go-ethereum/miner".quit chan struct {}; @"github.com/ethereum/go-ethereum/miner".workCh chan *@"github.com/ethereum/go-ethereum/miner".Work; @"github.com/ethereum/go-ethereum/miner".returnCh chan<- *@"github.com/ethereum/go-ethereum/miner".Result; @"github.com/ethereum/go-ethereum/miner".currentWork *@"github.com/ethereum/go-ethereum/miner".Work; @"github.com/ethereum/go-ethereum/miner".work map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/miner".Work; @"github.com/ethereum/go-ethereum/miner".hashrateMu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/miner".hashrate map[@"github.com/ethereum/go-ethereum/common".Hash]@"github.com/ethereum/go-ethereum/miner".hashrate; @"github.com/ethereum/go-ethereum/miner".running int32 }
	func (@"github.com/ethereum/go-ethereum/miner".a·2 *@"github.com/ethereum/go-ethereum/miner".RemoteAgent) GetHashRate () (@"github.com/ethereum/go-ethereum/miner".tot·1 int64)
	func (@"github.com/ethereum/go-ethereum/miner".a·3 *@"github.com/ethereum/go-ethereum/miner".RemoteAgent) GetWork () (? [3]string, ? error)
	func (@"github.com/ethereum/go-ethereum/miner".a·1 *@"github.com/ethereum/go-ethereum/miner".RemoteAgent "esc:0x1") SetReturnCh (@"github.com/ethereum/go-ethereum/miner".returnCh·2 chan<- *@"github.com/ethereum/go-ethereum/miner".Result) { @"github.com/ethereum/go-ethereum/miner".a·1.@"github.com/ethereum/go-ethereum/miner".returnCh = @"github.com/ethereum/go-ethereum/miner".returnCh·2 }
	func (@"github.com/ethereum/go-ethereum/miner".a·1 *@"github.com/ethereum/go-ethereum/miner".RemoteAgent) Start ()
	func (@"github.com/ethereum/go-ethereum/miner".a·1 *@"github.com/ethereum/go-ethereum/miner".RemoteAgent) Stop ()
	func (@"github.com/ethereum/go-ethereum/miner".a·1 *@"github.com/ethereum/go-ethereum/miner".RemoteAgent) SubmitHashrate (@"github.com/ethereum/go-ethereum/miner".id·2 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/miner".rate·3 uint64)
	func (@"github.com/ethereum/go-ethereum/miner".a·2 *@"github.com/ethereum/go-ethereum/miner".RemoteAgent) SubmitWork (@"github.com/ethereum/go-ethereum/miner".nonce·3 uint64, @"github.com/ethereum/go-ethereum/miner".mixDigest·4 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/miner".hash·5 @"github.com/ethereum/go-ethereum/common".Hash) (? bool)
	func (@"github.com/ethereum/go-ethereum/miner".a·2 *@"github.com/ethereum/go-ethereum/miner".RemoteAgent "esc:0x22") Work () (? chan<- *@"github.com/ethereum/go-ethereum/miner".Work) { return @"github.com/ethereum/go-ethereum/miner".a·2.@"github.com/ethereum/go-ethereum/miner".workCh }
	func (@"github.com/ethereum/go-ethereum/miner".a·1 *@"github.com/ethereum/go-ethereum/miner".RemoteAgent) @"github.com/ethereum/go-ethereum/miner".maintainLoop ()
	import eth "github.com/ethereum/go-ethereum/eth" // indirect
	type @"github.com/ethereum/go-ethereum/core".stateFn func() (? *@"github.com/ethereum/go-ethereum/core/state".StateDB, ? error)
	type @"github.com/ethereum/go-ethereum/core/state".account struct { @"github.com/ethereum/go-ethereum/core/state".stateObject *@"github.com/ethereum/go-ethereum/core/state".StateObject; @"github.com/ethereum/go-ethereum/core/state".nstart uint64; @"github.com/ethereum/go-ethereum/core/state".nonces []bool }
	type @"github.com/ethereum/go-ethereum/core/state".ManagedState struct { ? *@"github.com/ethereum/go-ethereum/core/state".StateDB; @"github.com/ethereum/go-ethereum/core/state".mu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/core/state".accounts map[string]*@"github.com/ethereum/go-ethereum/core/state".account }
	func (@"github.com/ethereum/go-ethereum/core/state".ms·2 *@"github.com/ethereum/go-ethereum/core/state".ManagedState) GetNonce (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? uint64)
	func (@"github.com/ethereum/go-ethereum/core/state".ms·2 *@"github.com/ethereum/go-ethereum/core/state".ManagedState) HasAccount (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? bool)
	func (@"github.com/ethereum/go-ethereum/core/state".ms·2 *@"github.com/ethereum/go-ethereum/core/state".ManagedState) NewNonce (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? uint64)
	func (@"github.com/ethereum/go-ethereum/core/state".ms·1 *@"github.com/ethereum/go-ethereum/core/state".ManagedState) RemoveNonce (@"github.com/ethereum/go-ethereum/core/state".addr·2 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/core/state".n·3 uint64)
	func (@"github.com/ethereum/go-ethereum/core/state".ms·1 *@"github.com/ethereum/go-ethereum/core/state".ManagedState) SetNonce (@"github.com/ethereum/go-ethereum/core/state".addr·2 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/core/state".nonce·3 uint64)
	func (@"github.com/ethereum/go-ethereum/core/state".ms·1 *@"github.com/ethereum/go-ethereum/core/state".ManagedState) SetState (@"github.com/ethereum/go-ethereum/core/state".statedb·2 *@"github.com/ethereum/go-ethereum/core/state".StateDB)
	func (@"github.com/ethereum/go-ethereum/core/state".ms·2 *@"github.com/ethereum/go-ethereum/core/state".ManagedState "esc:0x9") @"github.com/ethereum/go-ethereum/core/state".getAccount (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? *@"github.com/ethereum/go-ethereum/core/state".account)
	func (@"github.com/ethereum/go-ethereum/core/state".ms·2 *@"github.com/ethereum/go-ethereum/core/state".ManagedState "esc:0x1") @"github.com/ethereum/go-ethereum/core/state".hasAccount (@"github.com/ethereum/go-ethereum/core/state".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? bool) { var @"github.com/ethereum/go-ethereum/core/state".ok·4 bool; ; _, @"github.com/ethereum/go-ethereum/core/state".ok·4 = @"github.com/ethereum/go-ethereum/core/state".ms·2.@"github.com/ethereum/go-ethereum/core/state".accounts[@"github.com/ethereum/go-ethereum/core/state".addr·3.Str()]; return @"github.com/ethereum/go-ethereum/core/state".ok·4 }
	type @"github.com/ethereum/go-ethereum/core".TxPool struct { @"github.com/ethereum/go-ethereum/core".quit chan bool; @"github.com/ethereum/go-ethereum/core".currentState @"github.com/ethereum/go-ethereum/core".stateFn; @"github.com/ethereum/go-ethereum/core".pendingState *@"github.com/ethereum/go-ethereum/core/state".ManagedState; @"github.com/ethereum/go-ethereum/core".gasLimit func() (? *@"math/big".Int); @"github.com/ethereum/go-ethereum/core".minGasPrice *@"math/big".Int; @"github.com/ethereum/go-ethereum/core".eventMux *@"github.com/ethereum/go-ethereum/event".TypeMux; @"github.com/ethereum/go-ethereum/core".events @"github.com/ethereum/go-ethereum/event".Subscription; @"github.com/ethereum/go-ethereum/core".mu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/core".pending map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/core/types".Transaction; @"github.com/ethereum/go-ethereum/core".queue map[@"github.com/ethereum/go-ethereum/common".Address]map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/core/types".Transaction }
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".TxPool) Add (@"github.com/ethereum/go-ethereum/core".tx·3 *@"github.com/ethereum/go-ethereum/core/types".Transaction) (@"github.com/ethereum/go-ethereum/core".err·1 error)
	func (@"github.com/ethereum/go-ethereum/core".self·1 *@"github.com/ethereum/go-ethereum/core".TxPool) AddTransactions (@"github.com/ethereum/go-ethereum/core".txs·2 []*@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".TxPool) GetQueuedTransactions () (? @"github.com/ethereum/go-ethereum/core/types".Transactions)
	func (@"github.com/ethereum/go-ethereum/core".tp·2 *@"github.com/ethereum/go-ethereum/core".TxPool "esc:0x1") GetTransaction (@"github.com/ethereum/go-ethereum/core".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? *@"github.com/ethereum/go-ethereum/core/types".Transaction)
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".TxPool) GetTransactions () (@"github.com/ethereum/go-ethereum/core".txs·1 @"github.com/ethereum/go-ethereum/core/types".Transactions)
	func (@"github.com/ethereum/go-ethereum/core".self·1 *@"github.com/ethereum/go-ethereum/core".TxPool) RemoveTransactions (@"github.com/ethereum/go-ethereum/core".txs·2 @"github.com/ethereum/go-ethereum/core/types".Transactions "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/core".pool·1 *@"github.com/ethereum/go-ethereum/core".TxPool "esc:0x1") RemoveTx (@"github.com/ethereum/go-ethereum/core".hash·2 @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core".pool·2 *@"github.com/ethereum/go-ethereum/core".TxPool) State () (? *@"github.com/ethereum/go-ethereum/core/state".ManagedState)
	func (@"github.com/ethereum/go-ethereum/core".pool·3 *@"github.com/ethereum/go-ethereum/core".TxPool) Stats () (@"github.com/ethereum/go-ethereum/core".pending·1 int, @"github.com/ethereum/go-ethereum/core".queued·2 int)
	func (@"github.com/ethereum/go-ethereum/core".pool·1 *@"github.com/ethereum/go-ethereum/core".TxPool "esc:0x9") Stop ()
	func (@"github.com/ethereum/go-ethereum/core".self·2 *@"github.com/ethereum/go-ethereum/core".TxPool "esc:0x1") @"github.com/ethereum/go-ethereum/core".add (@"github.com/ethereum/go-ethereum/core".tx·3 *@"github.com/ethereum/go-ethereum/core/types".Transaction) (? error)
	func (@"github.com/ethereum/go-ethereum/core".pool·1 *@"github.com/ethereum/go-ethereum/core".TxPool "esc:0x9") @"github.com/ethereum/go-ethereum/core".addTx (@"github.com/ethereum/go-ethereum/core".hash·2 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/core".addr·3 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/core".tx·4 *@"github.com/ethereum/go-ethereum/core/types".Transaction)
	func (@"github.com/ethereum/go-ethereum/core".pool·1 *@"github.com/ethereum/go-ethereum/core".TxPool "esc:0x9") @"github.com/ethereum/go-ethereum/core".checkQueue ()
	func (@"github.com/ethereum/go-ethereum/core".pool·1 *@"github.com/ethereum/go-ethereum/core".TxPool) @"github.com/ethereum/go-ethereum/core".eventLoop ()
	func (@"github.com/ethereum/go-ethereum/core".self·1 *@"github.com/ethereum/go-ethereum/core".TxPool "esc:0x1") @"github.com/ethereum/go-ethereum/core".queueTx (@"github.com/ethereum/go-ethereum/core".hash·2 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/core".tx·3 *@"github.com/ethereum/go-ethereum/core/types".Transaction)
	func (@"github.com/ethereum/go-ethereum/core".pool·1 *@"github.com/ethereum/go-ethereum/core".TxPool "esc:0x9") @"github.com/ethereum/go-ethereum/core".resetState ()
	func (@"github.com/ethereum/go-ethereum/core".pool·1 *@"github.com/ethereum/go-ethereum/core".TxPool "esc:0x9") @"github.com/ethereum/go-ethereum/core".validatePool ()
	func (@"github.com/ethereum/go-ethereum/core".pool·2 *@"github.com/ethereum/go-ethereum/core".TxPool "esc:0x1") @"github.com/ethereum/go-ethereum/core".validateTx (@"github.com/ethereum/go-ethereum/core".tx·3 *@"github.com/ethereum/go-ethereum/core/types".Transaction) (? error)
	import accounts "github.com/ethereum/go-ethereum/accounts" // indirect
	import uuid "github.com/pborman/uuid" // indirect
	type @"github.com/pborman/uuid".Domain uint8
	func (@"github.com/pborman/uuid".d·2 @"github.com/pborman/uuid".Domain) String () (? string)
	type @"github.com/pborman/uuid".Time int64
	func (@"github.com/pborman/uuid".t·3 @"github.com/pborman/uuid".Time) UnixTime () (@"github.com/pborman/uuid".sec·1 int64, @"github.com/pborman/uuid".nsec·2 int64) { @"github.com/pborman/uuid".sec·1 = int64(@"github.com/pborman/uuid".t·3 - @"github.com/pborman/uuid".Time(0x1b21dd213814000)); @"github.com/pborman/uuid".nsec·2 = @"github.com/pborman/uuid".sec·1 % 0x989680 * 0x64; @"github.com/pborman/uuid".sec·1 /= 0x989680; return @"github.com/pborman/uuid".sec·1, @"github.com/pborman/uuid".nsec·2 }
	type @"github.com/pborman/uuid".Variant uint8
	func (@"github.com/pborman/uuid".v·2 @"github.com/pborman/uuid".Variant) String () (? string)
	type @"github.com/pborman/uuid".Version uint8
	func (@"github.com/pborman/uuid".v·2 @"github.com/pborman/uuid".Version) String () (? string)
	type @"github.com/pborman/uuid".UUID []byte
	func (@"github.com/pborman/uuid".uuid·3 @"github.com/pborman/uuid".UUID "esc:0x1") ClockSequence () (? int, ? bool) { if len(@"github.com/pborman/uuid".uuid·3) != 0x10 { return 0x0, false }; return int(@"encoding/binary".BigEndian.Uint16(@"github.com/pborman/uuid".uuid·3[0x8:0xa])) & 0x3fff, true }
	func (@"github.com/pborman/uuid".uuid·3 @"github.com/pborman/uuid".UUID "esc:0x1") Domain () (? @"github.com/pborman/uuid".Domain, ? bool) { var @"github.com/pborman/uuid".v·4 @"github.com/pborman/uuid".Version; ; @"github.com/pborman/uuid".v·4, _ = @"github.com/pborman/uuid".uuid·3.Version(); if @"github.com/pborman/uuid".v·4 != @"github.com/pborman/uuid".Version(0x2) { return @"github.com/pborman/uuid".Domain(0x0), false }; return @"github.com/pborman/uuid".Domain(@"github.com/pborman/uuid".uuid·3[0x9]), true }
	func (@"github.com/pborman/uuid".uuid·3 @"github.com/pborman/uuid".UUID "esc:0x1") Id () (? uint32, ? bool) { var @"github.com/pborman/uuid".v·4 @"github.com/pborman/uuid".Version; ; @"github.com/pborman/uuid".v·4, _ = @"github.com/pborman/uuid".uuid·3.Version(); if @"github.com/pborman/uuid".v·4 != @"github.com/pborman/uuid".Version(0x2) { return 0x0, false }; return @"encoding/binary".BigEndian.Uint32(@"github.com/pborman/uuid".uuid·3[0x0:0x4]), true }
	func (@"github.com/pborman/uuid".u·3 @"github.com/pborman/uuid".UUID) MarshalJSON () (? []byte, ? error)
	func (@"github.com/pborman/uuid".uuid·2 @"github.com/pborman/uuid".UUID "esc:0x9") NodeID () (? []byte) { if len(@"github.com/pborman/uuid".uuid·2) != 0x10 { return nil }; var @"github.com/pborman/uuid".node·3 []byte; ; @"github.com/pborman/uuid".node·3 = make([]byte, 0x6); copy(@"github.com/pborman/uuid".node·3, @"github.com/pborman/uuid".uuid·2[0xa:]); return @"github.com/pborman/uuid".node·3 }
	func (@"github.com/pborman/uuid".uuid·2 *@"github.com/pborman/uuid".UUID "esc:0x1") Scan (@"github.com/pborman/uuid".src·3 interface {}) (? error)
	func (@"github.com/pborman/uuid".uuid·2 @"github.com/pborman/uuid".UUID) String () (? string)
	func (@"github.com/pborman/uuid".uuid·3 @"github.com/pborman/uuid".UUID "esc:0x1") Time () (? @"github.com/pborman/uuid".Time, ? bool) { if len(@"github.com/pborman/uuid".uuid·3) != 0x10 { return @"github.com/pborman/uuid".Time(0x0), false }; var @"github.com/pborman/uuid".time·4 int64; ; @"github.com/pborman/uuid".time·4 = int64(@"encoding/binary".BigEndian.Uint32(@"github.com/pborman/uuid".uuid·3[0x0:0x4])); @"github.com/pborman/uuid".time·4 |= int64(@"encoding/binary".BigEndian.Uint16(@"github.com/pborman/uuid".uuid·3[0x4:0x6])) << 0x20; @"github.com/pborman/uuid".time·4 |= int64(@"encoding/binary".BigEndian.Uint16(@"github.com/pborman/uuid".uuid·3[0x6:0x8]) & 0xfff) << 0x30; return @"github.com/pborman/uuid".Time(@"github.com/pborman/uuid".time·4), true }
	func (@"github.com/pborman/uuid".uuid·2 @"github.com/pborman/uuid".UUID) URN () (? string)
	func (@"github.com/pborman/uuid".u·2 *@"github.com/pborman/uuid".UUID "esc:0x1") UnmarshalJSON (@"github.com/pborman/uuid".data·3 []byte "esc:0x1") (? error)
	func (@"github.com/pborman/uuid".uuid·2 @"github.com/pborman/uuid".UUID "esc:0x1") Variant () (? @"github.com/pborman/uuid".Variant)
	func (@"github.com/pborman/uuid".uuid·3 @"github.com/pborman/uuid".UUID "esc:0x1") Version () (? @"github.com/pborman/uuid".Version, ? bool) { if len(@"github.com/pborman/uuid".uuid·3) != 0x10 { return @"github.com/pborman/uuid".Version(0x0), false }; return @"github.com/pborman/uuid".Version(@"github.com/pborman/uuid".uuid·3[0x6] >> 0x4), true }
	type @"github.com/ethereum/go-ethereum/crypto".Key struct { Id @"github.com/pborman/uuid".UUID; Address @"github.com/ethereum/go-ethereum/common".Address; PrivateKey *@"crypto/ecdsa".PrivateKey }
	func (@"github.com/ethereum/go-ethereum/crypto".k·3 *@"github.com/ethereum/go-ethereum/crypto".Key "esc:0x9") MarshalJSON () (@"github.com/ethereum/go-ethereum/crypto".j·1 []byte, @"github.com/ethereum/go-ethereum/crypto".err·2 error)
	func (@"github.com/ethereum/go-ethereum/crypto".k·2 *@"github.com/ethereum/go-ethereum/crypto".Key "esc:0x1") UnmarshalJSON (@"github.com/ethereum/go-ethereum/crypto".j·3 []byte) (@"github.com/ethereum/go-ethereum/crypto".err·1 error)
	type @"github.com/ethereum/go-ethereum/crypto".KeyStore interface { Cleanup(@"github.com/ethereum/go-ethereum/crypto".keyAddr @"github.com/ethereum/go-ethereum/common".Address) (@"github.com/ethereum/go-ethereum/crypto".err error); DeleteKey(? @"github.com/ethereum/go-ethereum/common".Address, ? string) (? error); GenerateNewKey(? @"io".Reader, ? string) (? *@"github.com/ethereum/go-ethereum/crypto".Key, ? error); GetKey(? @"github.com/ethereum/go-ethereum/common".Address, ? string) (? *@"github.com/ethereum/go-ethereum/crypto".Key, ? error); GetKeyAddresses() (? []@"github.com/ethereum/go-ethereum/common".Address, ? error); StoreKey(? *@"github.com/ethereum/go-ethereum/crypto".Key, ? string) (? error) }
	type @"github.com/ethereum/go-ethereum/accounts".unlocked struct { ? *@"github.com/ethereum/go-ethereum/crypto".Key; @"github.com/ethereum/go-ethereum/accounts".abort chan struct {} }
	type @"github.com/ethereum/go-ethereum/accounts".Account struct { Address @"github.com/ethereum/go-ethereum/common".Address }
	type @"github.com/ethereum/go-ethereum/accounts".Manager struct { @"github.com/ethereum/go-ethereum/accounts".keyStore @"github.com/ethereum/go-ethereum/crypto".KeyStore; @"github.com/ethereum/go-ethereum/accounts".unlocked map[@"github.com/ethereum/go-ethereum/common".Address]*@"github.com/ethereum/go-ethereum/accounts".unlocked; @"github.com/ethereum/go-ethereum/accounts".mutex @"sync".RWMutex }
	func (@"github.com/ethereum/go-ethereum/accounts".am·3 *@"github.com/ethereum/go-ethereum/accounts".Manager "esc:0x9") Accounts () (? []@"github.com/ethereum/go-ethereum/accounts".Account, ? error)
	func (@"github.com/ethereum/go-ethereum/accounts".am·3 *@"github.com/ethereum/go-ethereum/accounts".Manager "esc:0x9") AddressByIndex (@"github.com/ethereum/go-ethereum/accounts".index·4 int) (@"github.com/ethereum/go-ethereum/accounts".addr·1 string, @"github.com/ethereum/go-ethereum/accounts".err·2 error)
	func (@"github.com/ethereum/go-ethereum/accounts".am·2 *@"github.com/ethereum/go-ethereum/accounts".Manager "esc:0x9") DeleteAccount (@"github.com/ethereum/go-ethereum/accounts".address·3 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/accounts".auth·4 string) (? error)
	func (@"github.com/ethereum/go-ethereum/accounts".am·2 *@"github.com/ethereum/go-ethereum/accounts".Manager "esc:0x9") Export (@"github.com/ethereum/go-ethereum/accounts".path·3 string, @"github.com/ethereum/go-ethereum/accounts".addr·4 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/accounts".keyAuth·5 string) (? error)
	func (@"github.com/ethereum/go-ethereum/accounts".am·2 *@"github.com/ethereum/go-ethereum/accounts".Manager "esc:0x9") HasAccount (@"github.com/ethereum/go-ethereum/accounts".addr·3 @"github.com/ethereum/go-ethereum/common".Address) (? bool)
	func (@"github.com/ethereum/go-ethereum/accounts".am·3 *@"github.com/ethereum/go-ethereum/accounts".Manager "esc:0x9") Import (@"github.com/ethereum/go-ethereum/accounts".path·4 string, @"github.com/ethereum/go-ethereum/accounts".keyAuth·5 string) (? @"github.com/ethereum/go-ethereum/accounts".Account, ? error)
	func (@"github.com/ethereum/go-ethereum/accounts".am·3 *@"github.com/ethereum/go-ethereum/accounts".Manager "esc:0x9") ImportPreSaleKey (@"github.com/ethereum/go-ethereum/accounts".keyJSON·4 []byte, @"github.com/ethereum/go-ethereum/accounts".password·5 string) (@"github.com/ethereum/go-ethereum/accounts".acc·1 @"github.com/ethereum/go-ethereum/accounts".Account, @"github.com/ethereum/go-ethereum/accounts".err·2 error)
	func (@"github.com/ethereum/go-ethereum/accounts".am·3 *@"github.com/ethereum/go-ethereum/accounts".Manager "esc:0x9") NewAccount (@"github.com/ethereum/go-ethereum/accounts".auth·4 string) (? @"github.com/ethereum/go-ethereum/accounts".Account, ? error)
	func (@"github.com/ethereum/go-ethereum/accounts".am·3 *@"github.com/ethereum/go-ethereum/accounts".Manager) Sign (@"github.com/ethereum/go-ethereum/accounts".a·4 @"github.com/ethereum/go-ethereum/accounts".Account, @"github.com/ethereum/go-ethereum/accounts".toSign·5 []byte) (@"github.com/ethereum/go-ethereum/accounts".signature·1 []byte, @"github.com/ethereum/go-ethereum/accounts".err·2 error)
	func (@"github.com/ethereum/go-ethereum/accounts".am·2 *@"github.com/ethereum/go-ethereum/accounts".Manager) TimedUnlock (@"github.com/ethereum/go-ethereum/accounts".addr·3 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/accounts".keyAuth·4 string, @"github.com/ethereum/go-ethereum/accounts".timeout·5 @"time".Duration) (? error)
	func (@"github.com/ethereum/go-ethereum/accounts".am·2 *@"github.com/ethereum/go-ethereum/accounts".Manager) Unlock (@"github.com/ethereum/go-ethereum/accounts".addr·3 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/accounts".keyAuth·4 string) (? error)
	func (@"github.com/ethereum/go-ethereum/accounts".am·2 *@"github.com/ethereum/go-ethereum/accounts".Manager "esc:0x9") Update (@"github.com/ethereum/go-ethereum/accounts".addr·3 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/accounts".authFrom·4 string, @"github.com/ethereum/go-ethereum/accounts".authTo·5 string) (@"github.com/ethereum/go-ethereum/accounts".err·1 error)
	func (@"github.com/ethereum/go-ethereum/accounts".am·1 *@"github.com/ethereum/go-ethereum/accounts".Manager) @"github.com/ethereum/go-ethereum/accounts".expire (@"github.com/ethereum/go-ethereum/accounts".addr·2 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/accounts".u·3 *@"github.com/ethereum/go-ethereum/accounts".unlocked "esc:0x1", @"github.com/ethereum/go-ethereum/accounts".timeout·4 @"time".Duration)
	import ethash "github.com/ethereum/ethash" // indirect
	type @"sync".Once struct { @"sync".m @"sync".Mutex; @"sync".done uint32 }
	func (@"sync".o·1 *@"sync".Once) Do (@"sync".f·2 func() "esc:0x1")
	type @"github.com/ethereum/ethash"._Ctype_uint64_t uint64
	type @"github.com/ethereum/ethash"._Ctype_struct_ethash_light struct { @"github.com/ethereum/ethash".cache @"unsafe".Pointer; @"github.com/ethereum/ethash".cache_size @"github.com/ethereum/ethash"._Ctype_uint64_t; @"github.com/ethereum/ethash".block_number @"github.com/ethereum/ethash"._Ctype_uint64_t }
	type @"github.com/ethereum/ethash".cache struct { @"github.com/ethereum/ethash".epoch uint64; @"github.com/ethereum/ethash".test bool; @"github.com/ethereum/ethash".gen @"sync".Once; @"github.com/ethereum/ethash".ptr *@"github.com/ethereum/ethash"._Ctype_struct_ethash_light }
	func (@"github.com/ethereum/ethash".cache·1 *@"github.com/ethereum/ethash".cache) @"github.com/ethereum/ethash".generate ()
	type @"github.com/ethereum/ethash".Light struct { @"github.com/ethereum/ethash".test bool; @"github.com/ethereum/ethash".mu @"sync".Mutex; @"github.com/ethereum/ethash".current *@"github.com/ethereum/ethash".cache }
	func (@"github.com/ethereum/ethash".l·2 *@"github.com/ethereum/ethash".Light) Verify (@"github.com/ethereum/ethash".block·3 @"github.com/ethereum/go-ethereum/pow".Block) (? bool)
	func (@"github.com/ethereum/ethash".l·2 *@"github.com/ethereum/ethash".Light) @"github.com/ethereum/ethash".getCache (@"github.com/ethereum/ethash".blockNum·3 uint64) (? *@"github.com/ethereum/ethash".cache)
	type @"github.com/ethereum/ethash"._Ctype_unsignedchar uint8
	type @"github.com/ethereum/ethash"._Ctype_int int32
	type @"github.com/ethereum/ethash"._Ctype_short int16
	type @"github.com/ethereum/ethash"._Ctype_struct___sbuf struct { @"github.com/ethereum/ethash"._base *@"github.com/ethereum/ethash"._Ctype_unsignedchar; @"github.com/ethereum/ethash"._size @"github.com/ethereum/ethash"._Ctype_int; _ [4]byte }
	type @"github.com/ethereum/ethash"._Ctype_struct___sFILEX struct {}
	type @"github.com/ethereum/ethash"._Ctype_fpos_t int64
	type @"github.com/ethereum/ethash"._Ctype_struct___sFILE struct { @"github.com/ethereum/ethash"._p *@"github.com/ethereum/ethash"._Ctype_unsignedchar; @"github.com/ethereum/ethash"._r @"github.com/ethereum/ethash"._Ctype_int; @"github.com/ethereum/ethash"._w @"github.com/ethereum/ethash"._Ctype_int; @"github.com/ethereum/ethash"._flags @"github.com/ethereum/ethash"._Ctype_short; @"github.com/ethereum/ethash"._file @"github.com/ethereum/ethash"._Ctype_short; _ [4]byte; @"github.com/ethereum/ethash"._bf @"github.com/ethereum/ethash"._Ctype_struct___sbuf; @"github.com/ethereum/ethash"._lbfsize @"github.com/ethereum/ethash"._Ctype_int; _ [4]byte; @"github.com/ethereum/ethash"._cookie @"unsafe".Pointer; @"github.com/ethereum/ethash"._close *[0]byte; @"github.com/ethereum/ethash"._read *[0]byte; @"github.com/ethereum/ethash"._seek *[0]byte; @"github.com/ethereum/ethash"._write *[0]byte; @"github.com/ethereum/ethash"._ub @"github.com/ethereum/ethash"._Ctype_struct___sbuf; @"github.com/ethereum/ethash"._extra *@"github.com/ethereum/ethash"._Ctype_struct___sFILEX; @"github.com/ethereum/ethash"._ur @"github.com/ethereum/ethash"._Ctype_int; @"github.com/ethereum/ethash"._ubuf [3]@"github.com/ethereum/ethash"._Ctype_unsignedchar; @"github.com/ethereum/ethash"._nbuf [1]@"github.com/ethereum/ethash"._Ctype_unsignedchar; @"github.com/ethereum/ethash"._lb @"github.com/ethereum/ethash"._Ctype_struct___sbuf; @"github.com/ethereum/ethash"._blksize @"github.com/ethereum/ethash"._Ctype_int; _ [4]byte; @"github.com/ethereum/ethash"._offset @"github.com/ethereum/ethash"._Ctype_fpos_t }
	type @"github.com/ethereum/ethash"._Ctype_node [64]byte
	type @"github.com/ethereum/ethash"._Ctype_struct_ethash_full struct { @"github.com/ethereum/ethash".file *@"github.com/ethereum/ethash"._Ctype_struct___sFILE; @"github.com/ethereum/ethash".file_size @"github.com/ethereum/ethash"._Ctype_uint64_t; @"github.com/ethereum/ethash".data *@"github.com/ethereum/ethash"._Ctype_node }
	type @"github.com/ethereum/ethash".dag struct { @"github.com/ethereum/ethash".epoch uint64; @"github.com/ethereum/ethash".test bool; @"github.com/ethereum/ethash".dir string; @"github.com/ethereum/ethash".gen @"sync".Once; @"github.com/ethereum/ethash".ptr *@"github.com/ethereum/ethash"._Ctype_struct_ethash_full }
	func (@"github.com/ethereum/ethash".d·2 *@"github.com/ethereum/ethash".dag "esc:0x32") Ptr () (? @"unsafe".Pointer) { return @"unsafe".Pointer(@"github.com/ethereum/ethash".d·2.@"github.com/ethereum/ethash".ptr.@"github.com/ethereum/ethash".data) }
	func (@"github.com/ethereum/ethash".d·1 *@"github.com/ethereum/ethash".dag) @"github.com/ethereum/ethash".generate ()
	type @"github.com/ethereum/ethash".Full struct { Dir string; @"github.com/ethereum/ethash".test bool; @"github.com/ethereum/ethash".turbo bool; @"github.com/ethereum/ethash".hashRate int32; @"github.com/ethereum/ethash".mu @"sync".Mutex; @"github.com/ethereum/ethash".current *@"github.com/ethereum/ethash".dag }
	func (@"github.com/ethereum/ethash".pow·2 *@"github.com/ethereum/ethash".Full) GetHashrate () (? int64)
	func (@"github.com/ethereum/ethash".pow·3 *@"github.com/ethereum/ethash".Full) Search (@"github.com/ethereum/ethash".block·4 @"github.com/ethereum/go-ethereum/pow".Block, @"github.com/ethereum/ethash".stop·5 <-chan struct {} "esc:0x1", @"github.com/ethereum/ethash".index·6 int) (@"github.com/ethereum/ethash".nonce·1 uint64, @"github.com/ethereum/ethash".mixDigest·2 []byte)
	func (@"github.com/ethereum/ethash".pow·1 *@"github.com/ethereum/ethash".Full "esc:0x1") Turbo (@"github.com/ethereum/ethash".on·2 bool) { @"github.com/ethereum/ethash".pow·1.@"github.com/ethereum/ethash".turbo = @"github.com/ethereum/ethash".on·2 }
	func (@"github.com/ethereum/ethash".pow·2 *@"github.com/ethereum/ethash".Full) @"github.com/ethereum/ethash".getDAG (@"github.com/ethereum/ethash".blockNum·3 uint64) (@"github.com/ethereum/ethash".d·1 *@"github.com/ethereum/ethash".dag)
	type @"github.com/ethereum/ethash".Ethash struct { ? *@"github.com/ethereum/ethash".Light; ? *@"github.com/ethereum/ethash".Full }
	type @"github.com/ethereum/go-ethereum/eth".txPool interface { AddTransactions(? []*@"github.com/ethereum/go-ethereum/core/types".Transaction); GetTransactions() (? @"github.com/ethereum/go-ethereum/core/types".Transactions) }
	import downloader "github.com/ethereum/go-ethereum/eth/downloader" // indirect
	type @"github.com/ethereum/go-ethereum/eth/downloader".SyncMode int
	import prque "gopkg.in/karalabe/cookiejar.v2/collections/prque" // indirect
	type @"gopkg.in/karalabe/cookiejar.v2/collections/prque".item struct { @"gopkg.in/karalabe/cookiejar.v2/collections/prque".value interface {}; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".priority float32 }
	type @"gopkg.in/karalabe/cookiejar.v2/collections/prque".sstack struct { @"gopkg.in/karalabe/cookiejar.v2/collections/prque".size int; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".capacity int; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".offset int; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks [][]*@"gopkg.in/karalabe/cookiejar.v2/collections/prque".item; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".active []*@"gopkg.in/karalabe/cookiejar.v2/collections/prque".item }
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".sstack "esc:0x1") Len () (? int) { return @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".size }
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".sstack "esc:0x1") Less (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".i·3 int, @"gopkg.in/karalabe/cookiejar.v2/collections/prque".j·4 int) (? bool) { return @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks[@"gopkg.in/karalabe/cookiejar.v2/collections/prque".i·3 / 0x1000][@"gopkg.in/karalabe/cookiejar.v2/collections/prque".i·3 % 0x1000].@"gopkg.in/karalabe/cookiejar.v2/collections/prque".priority > @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks[@"gopkg.in/karalabe/cookiejar.v2/collections/prque".j·4 / 0x1000][@"gopkg.in/karalabe/cookiejar.v2/collections/prque".j·4 % 0x1000].@"gopkg.in/karalabe/cookiejar.v2/collections/prque".priority }
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".sstack "esc:0x3a") Pop () (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".res·1 interface {}) { @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".size--; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".offset--; if @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".offset < 0x0 { @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".offset = 0xfff; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".active = @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks[@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".size / 0x1000] }; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".res·1, @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".active[@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".offset] = @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".active[@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".offset], nil; return  }
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".sstack "esc:0x9") Push (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".data·2 interface {}) { if @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".size == @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".capacity { @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".active = make([]*@"gopkg.in/karalabe/cookiejar.v2/collections/prque".item, 0x1000); @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks = append(@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks, @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".active); @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".capacity += 0x1000; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".offset = 0x0 } else { if @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".offset == 0x1000 { @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".active = @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks[@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".size / 0x1000]; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".offset = 0x0 } }; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".active[@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".offset] = @"gopkg.in/karalabe/cookiejar.v2/collections/prque".data·2.(*@"gopkg.in/karalabe/cookiejar.v2/collections/prque".item); @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".offset++; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".size++ }
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".sstack "esc:0x1") Reset () { *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1 = *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".newSstack() }
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".sstack "esc:0x9") Swap (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".i·2 int, @"gopkg.in/karalabe/cookiejar.v2/collections/prque".j·3 int) { var @"gopkg.in/karalabe/cookiejar.v2/collections/prque".ib·4 int; ; var @"gopkg.in/karalabe/cookiejar.v2/collections/prque".io·5 int; ; var @"gopkg.in/karalabe/cookiejar.v2/collections/prque".jb·6 int; ; var @"gopkg.in/karalabe/cookiejar.v2/collections/prque".jo·7 int; ; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".ib·4, @"gopkg.in/karalabe/cookiejar.v2/collections/prque".io·5, @"gopkg.in/karalabe/cookiejar.v2/collections/prque".jb·6, @"gopkg.in/karalabe/cookiejar.v2/collections/prque".jo·7 = @"gopkg.in/karalabe/cookiejar.v2/collections/prque".i·2 / 0x1000, @"gopkg.in/karalabe/cookiejar.v2/collections/prque".i·2 % 0x1000, @"gopkg.in/karalabe/cookiejar.v2/collections/prque".j·3 / 0x1000, @"gopkg.in/karalabe/cookiejar.v2/collections/prque".j·3 % 0x1000; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks[@"gopkg.in/karalabe/cookiejar.v2/collections/prque".ib·4][@"gopkg.in/karalabe/cookiejar.v2/collections/prque".io·5], @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks[@"gopkg.in/karalabe/cookiejar.v2/collections/prque".jb·6][@"gopkg.in/karalabe/cookiejar.v2/collections/prque".jo·7] = @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks[@"gopkg.in/karalabe/cookiejar.v2/collections/prque".jb·6][@"gopkg.in/karalabe/cookiejar.v2/collections/prque".jo·7], @"gopkg.in/karalabe/cookiejar.v2/collections/prque".s·1.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks[@"gopkg.in/karalabe/cookiejar.v2/collections/prque".ib·4][@"gopkg.in/karalabe/cookiejar.v2/collections/prque".io·5] }
	type @"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque struct { @"gopkg.in/karalabe/cookiejar.v2/collections/prque".cont *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".sstack }
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".p·2 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque "esc:0x1") Empty () (? bool) { return @"gopkg.in/karalabe/cookiejar.v2/collections/prque".p·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".cont.Len() == 0x0 }
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".p·3 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque "esc:0x9") Pop () (? interface {}, ? float32)
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".p·2 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque "esc:0x9") PopItem () (? interface {})
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".p·1 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque "esc:0x9") Push (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".data·2 interface {}, @"gopkg.in/karalabe/cookiejar.v2/collections/prque".priority·3 float32)
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".p·1 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque "esc:0x1") Reset () { *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".p·1 = *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".New() }
	func (@"gopkg.in/karalabe/cookiejar.v2/collections/prque".p·2 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque "esc:0x1") Size () (? int) { return @"gopkg.in/karalabe/cookiejar.v2/collections/prque".p·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".cont.Len() }
	type @"github.com/ethereum/go-ethereum/eth/downloader".relativeHashFetcherFn func(? @"github.com/ethereum/go-ethereum/common".Hash) (? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".absoluteHashFetcherFn func(? uint64, ? int) (? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".blockFetcherFn func(? []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".relativeHeaderFetcherFn func(? @"github.com/ethereum/go-ethereum/common".Hash, ? int, ? int, ? bool) (? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".absoluteHeaderFetcherFn func(? uint64, ? int, ? int, ? bool) (? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".blockBodyFetcherFn func(? []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".receiptFetcherFn func(? []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".stateFetcherFn func(? []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".peer struct { @"github.com/ethereum/go-ethereum/eth/downloader".id string; @"github.com/ethereum/go-ethereum/eth/downloader".head @"github.com/ethereum/go-ethereum/common".Hash; @"github.com/ethereum/go-ethereum/eth/downloader".blockIdle int32; @"github.com/ethereum/go-ethereum/eth/downloader".receiptIdle int32; @"github.com/ethereum/go-ethereum/eth/downloader".stateIdle int32; @"github.com/ethereum/go-ethereum/eth/downloader".blockThroughput float64; @"github.com/ethereum/go-ethereum/eth/downloader".receiptThroughput float64; @"github.com/ethereum/go-ethereum/eth/downloader".stateThroughput float64; @"github.com/ethereum/go-ethereum/eth/downloader".blockStarted @"time".Time; @"github.com/ethereum/go-ethereum/eth/downloader".receiptStarted @"time".Time; @"github.com/ethereum/go-ethereum/eth/downloader".stateStarted @"time".Time; @"github.com/ethereum/go-ethereum/eth/downloader".lacking map[@"github.com/ethereum/go-ethereum/common".Hash]struct {}; @"github.com/ethereum/go-ethereum/eth/downloader".getRelHashes @"github.com/ethereum/go-ethereum/eth/downloader".relativeHashFetcherFn; @"github.com/ethereum/go-ethereum/eth/downloader".getAbsHashes @"github.com/ethereum/go-ethereum/eth/downloader".absoluteHashFetcherFn; @"github.com/ethereum/go-ethereum/eth/downloader".getBlocks @"github.com/ethereum/go-ethereum/eth/downloader".blockFetcherFn; @"github.com/ethereum/go-ethereum/eth/downloader".getRelHeaders @"github.com/ethereum/go-ethereum/eth/downloader".relativeHeaderFetcherFn; @"github.com/ethereum/go-ethereum/eth/downloader".getAbsHeaders @"github.com/ethereum/go-ethereum/eth/downloader".absoluteHeaderFetcherFn; @"github.com/ethereum/go-ethereum/eth/downloader".getBlockBodies @"github.com/ethereum/go-ethereum/eth/downloader".blockBodyFetcherFn; @"github.com/ethereum/go-ethereum/eth/downloader".getReceipts @"github.com/ethereum/go-ethereum/eth/downloader".receiptFetcherFn; @"github.com/ethereum/go-ethereum/eth/downloader".getNodeData @"github.com/ethereum/go-ethereum/eth/downloader".stateFetcherFn; @"github.com/ethereum/go-ethereum/eth/downloader".version int; @"github.com/ethereum/go-ethereum/eth/downloader".lock @"sync".RWMutex }
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) BlockCapacity () (? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) Fetch61 (@"github.com/ethereum/go-ethereum/eth/downloader".request·3 *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x1") (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) FetchBodies (@"github.com/ethereum/go-ethereum/eth/downloader".request·3 *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x9") (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) FetchNodeData (@"github.com/ethereum/go-ethereum/eth/downloader".request·3 *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x1") (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) FetchReceipts (@"github.com/ethereum/go-ethereum/eth/downloader".request·3 *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x9") (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) Lacks (@"github.com/ethereum/go-ethereum/eth/downloader".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? bool)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·1 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) MarkLacking (@"github.com/ethereum/go-ethereum/eth/downloader".hash·2 @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) NodeDataCapacity () (? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) ReceiptCapacity () (? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·1 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) Reset ()
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·1 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) SetBlocksIdle (@"github.com/ethereum/go-ethereum/eth/downloader".delivered·2 int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·1 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) SetBodiesIdle (@"github.com/ethereum/go-ethereum/eth/downloader".delivered·2 int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·1 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) SetNodeDataIdle (@"github.com/ethereum/go-ethereum/eth/downloader".delivered·2 int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·1 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) SetReceiptsIdle (@"github.com/ethereum/go-ethereum/eth/downloader".delivered·2 int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) String () (? string)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".p·1 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) @"github.com/ethereum/go-ethereum/eth/downloader".setIdle (@"github.com/ethereum/go-ethereum/eth/downloader".started·2 @"time".Time "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".delivered·3 int, @"github.com/ethereum/go-ethereum/eth/downloader".throughput·4 *float64 "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".idle·5 *int32)
	type @"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest struct { Peer *@"github.com/ethereum/go-ethereum/eth/downloader".peer; Hashes map[@"github.com/ethereum/go-ethereum/common".Hash]int; Headers []*@"github.com/ethereum/go-ethereum/core/types".Header; Time @"time".Time }
	type @"github.com/ethereum/go-ethereum/trie".TrieSyncLeafCallback func(@"github.com/ethereum/go-ethereum/trie".leaf []byte, @"github.com/ethereum/go-ethereum/trie".parent @"github.com/ethereum/go-ethereum/common".Hash) (? error)
	type @"github.com/ethereum/go-ethereum/trie".request struct { @"github.com/ethereum/go-ethereum/trie".hash @"github.com/ethereum/go-ethereum/common".Hash; @"github.com/ethereum/go-ethereum/trie".data []byte; @"github.com/ethereum/go-ethereum/trie".object *@"github.com/ethereum/go-ethereum/trie".node; @"github.com/ethereum/go-ethereum/trie".parents []*@"github.com/ethereum/go-ethereum/trie".request; @"github.com/ethereum/go-ethereum/trie".depth int; @"github.com/ethereum/go-ethereum/trie".deps int; @"github.com/ethereum/go-ethereum/trie".callback @"github.com/ethereum/go-ethereum/trie".TrieSyncLeafCallback }
	type @"github.com/ethereum/go-ethereum/trie".SyncResult struct { Hash @"github.com/ethereum/go-ethereum/common".Hash; Data []byte }
	type @"github.com/ethereum/go-ethereum/core/state".StateSync struct { @"github.com/ethereum/go-ethereum/trie".database @"github.com/ethereum/go-ethereum/ethdb".Database; @"github.com/ethereum/go-ethereum/trie".requests map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/trie".request; @"github.com/ethereum/go-ethereum/trie".queue *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque }
	func (@"github.com/ethereum/go-ethereum/core/state".s·2 *@"github.com/ethereum/go-ethereum/core/state".StateSync "esc:0x9") Missing (@"github.com/ethereum/go-ethereum/core/state".max·3 int) (? []@"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/core/state".s·2 *@"github.com/ethereum/go-ethereum/core/state".StateSync "esc:0x1") Pending () (? int) { return (*@"github.com/ethereum/go-ethereum/trie".TrieSync)(@"github.com/ethereum/go-ethereum/core/state".s·2).Pending() }
	func (@"github.com/ethereum/go-ethereum/core/state".s·3 *@"github.com/ethereum/go-ethereum/core/state".StateSync "esc:0x9") Process (@"github.com/ethereum/go-ethereum/core/state".list·4 []@"github.com/ethereum/go-ethereum/trie".SyncResult "esc:0x9") (? int, ? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".fetchResult struct { Pending int; Header *@"github.com/ethereum/go-ethereum/core/types".Header; Uncles []*@"github.com/ethereum/go-ethereum/core/types".Header; Transactions @"github.com/ethereum/go-ethereum/core/types".Transactions; Receipts @"github.com/ethereum/go-ethereum/core/types".Receipts }
	type @"sync".syncSema struct { @"sync".lock uintptr; @"sync".head @"unsafe".Pointer; @"sync".tail @"unsafe".Pointer }
	type @"sync".copyChecker uintptr
	func (@"sync".c·1 *@"sync".copyChecker) @"sync".check ()
	type @"sync".Cond struct { L @"sync".Locker; @"sync".sema @"sync".syncSema; @"sync".waiters uint32; @"sync".checker @"sync".copyChecker }
	func (@"sync".c·1 *@"sync".Cond) Broadcast ()
	func (@"sync".c·1 *@"sync".Cond) Signal ()
	func (@"sync".c·1 *@"sync".Cond) Wait ()
	func (@"sync".c·1 *@"sync".Cond) @"sync".signalImpl (@"sync".all·2 bool)
	import metrics "github.com/rcrowley/go-metrics" // indirect
	type @"github.com/rcrowley/go-metrics".Timer interface { Count() (? int64); Max() (? int64); Mean() (? float64); Min() (? int64); Percentile(? float64) (? float64); Percentiles(? []float64) (? []float64); Rate1() (? float64); Rate15() (? float64); Rate5() (? float64); RateMean() (? float64); Snapshot() (? @"github.com/rcrowley/go-metrics".Timer); StdDev() (? float64); Sum() (? int64); Time(? func()); Update(? @"time".Duration); UpdateSince(? @"time".Time); Variance() (? float64) }
	type @"github.com/rcrowley/go-metrics".Meter interface { Count() (? int64); Mark(? int64); Rate1() (? float64); Rate15() (? float64); Rate5() (? float64); RateMean() (? float64); Snapshot() (? @"github.com/rcrowley/go-metrics".Meter) }
	type @"github.com/ethereum/go-ethereum/eth/downloader".queue struct { @"github.com/ethereum/go-ethereum/eth/downloader".mode @"github.com/ethereum/go-ethereum/eth/downloader".SyncMode; @"github.com/ethereum/go-ethereum/eth/downloader".fastSyncPivot uint64; @"github.com/ethereum/go-ethereum/eth/downloader".hashPool map[@"github.com/ethereum/go-ethereum/common".Hash]int; @"github.com/ethereum/go-ethereum/eth/downloader".hashQueue *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque; @"github.com/ethereum/go-ethereum/eth/downloader".hashCounter int; @"github.com/ethereum/go-ethereum/eth/downloader".headerHead @"github.com/ethereum/go-ethereum/common".Hash; @"github.com/ethereum/go-ethereum/eth/downloader".blockTaskPool map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/core/types".Header; @"github.com/ethereum/go-ethereum/eth/downloader".blockTaskQueue *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque; @"github.com/ethereum/go-ethereum/eth/downloader".blockPendPool map[string]*@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest; @"github.com/ethereum/go-ethereum/eth/downloader".blockDonePool map[@"github.com/ethereum/go-ethereum/common".Hash]struct {}; @"github.com/ethereum/go-ethereum/eth/downloader".receiptTaskPool map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/core/types".Header; @"github.com/ethereum/go-ethereum/eth/downloader".receiptTaskQueue *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque; @"github.com/ethereum/go-ethereum/eth/downloader".receiptPendPool map[string]*@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest; @"github.com/ethereum/go-ethereum/eth/downloader".receiptDonePool map[@"github.com/ethereum/go-ethereum/common".Hash]struct {}; @"github.com/ethereum/go-ethereum/eth/downloader".stateTaskIndex int; @"github.com/ethereum/go-ethereum/eth/downloader".stateTaskPool map[@"github.com/ethereum/go-ethereum/common".Hash]int; @"github.com/ethereum/go-ethereum/eth/downloader".stateTaskQueue *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque; @"github.com/ethereum/go-ethereum/eth/downloader".statePendPool map[string]*@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest; @"github.com/ethereum/go-ethereum/eth/downloader".stateDatabase @"github.com/ethereum/go-ethereum/ethdb".Database; @"github.com/ethereum/go-ethereum/eth/downloader".stateScheduler *@"github.com/ethereum/go-ethereum/core/state".StateSync; @"github.com/ethereum/go-ethereum/eth/downloader".stateProcessors int32; @"github.com/ethereum/go-ethereum/eth/downloader".stateSchedLock @"sync".RWMutex; @"github.com/ethereum/go-ethereum/eth/downloader".resultCache []*@"github.com/ethereum/go-ethereum/eth/downloader".fetchResult; @"github.com/ethereum/go-ethereum/eth/downloader".resultOffset uint64; @"github.com/ethereum/go-ethereum/eth/downloader".lock *@"sync".Mutex; @"github.com/ethereum/go-ethereum/eth/downloader".active *@"sync".Cond; @"github.com/ethereum/go-ethereum/eth/downloader".closed bool }
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·1 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") CancelBlocks (@"github.com/ethereum/go-ethereum/eth/downloader".request·2 *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·1 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") CancelBodies (@"github.com/ethereum/go-ethereum/eth/downloader".request·2 *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·1 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") CancelNodeData (@"github.com/ethereum/go-ethereum/eth/downloader".request·2 *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·1 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") CancelReceipts (@"github.com/ethereum/go-ethereum/eth/downloader".request·2 *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·1 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") Close ()
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·3 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") DeliverBlocks (@"github.com/ethereum/go-ethereum/eth/downloader".id·4 string "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".blocks·5 []*@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x9") (? int, ? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·3 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") DeliverBodies (@"github.com/ethereum/go-ethereum/eth/downloader".id·4 string "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".txLists·5 [][]*@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x9", @"github.com/ethereum/go-ethereum/eth/downloader".uncleLists·6 [][]*@"github.com/ethereum/go-ethereum/core/types".Header "esc:0x9") (? int, ? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·3 *@"github.com/ethereum/go-ethereum/eth/downloader".queue) DeliverNodeData (@"github.com/ethereum/go-ethereum/eth/downloader".id·4 string "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".data·5 [][]byte "esc:0x9", @"github.com/ethereum/go-ethereum/eth/downloader".callback·6 func(? error, ? int)) (? int, ? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·3 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") DeliverReceipts (@"github.com/ethereum/go-ethereum/eth/downloader".id·4 string "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".receiptList·5 [][]*@"github.com/ethereum/go-ethereum/core/types".Receipt "esc:0x9") (? int, ? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") ExpireBlocks (@"github.com/ethereum/go-ethereum/eth/downloader".timeout·3 @"time".Duration) (? map[string]int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") ExpireBodies (@"github.com/ethereum/go-ethereum/eth/downloader".timeout·3 @"time".Duration) (? map[string]int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") ExpireNodeData (@"github.com/ethereum/go-ethereum/eth/downloader".timeout·3 @"time".Duration) (? map[string]int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") ExpireReceipts (@"github.com/ethereum/go-ethereum/eth/downloader".timeout·3 @"time".Duration) (? map[string]int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") FastSyncPivot () (? uint64)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue) Idle () (? bool)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") InFlightBlocks () (? bool)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue) InFlightNodeData () (? bool)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") InFlightReceipts () (? bool)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") PendingBlocks () (? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue) PendingNodeData () (? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") PendingReceipts () (? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·1 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") Prepare (@"github.com/ethereum/go-ethereum/eth/downloader".offset·2 uint64, @"github.com/ethereum/go-ethereum/eth/downloader".mode·3 @"github.com/ethereum/go-ethereum/eth/downloader".SyncMode, @"github.com/ethereum/go-ethereum/eth/downloader".pivot·4 uint64)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") ReserveBlocks (@"github.com/ethereum/go-ethereum/eth/downloader".p·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peer, @"github.com/ethereum/go-ethereum/eth/downloader".count·4 int) (? *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·4 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") ReserveBodies (@"github.com/ethereum/go-ethereum/eth/downloader".p·5 *@"github.com/ethereum/go-ethereum/eth/downloader".peer, @"github.com/ethereum/go-ethereum/eth/downloader".count·6 int) (? *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest, ? bool, ? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue) ReserveNodeData (@"github.com/ethereum/go-ethereum/eth/downloader".p·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peer, @"github.com/ethereum/go-ethereum/eth/downloader".count·4 int) (? *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·4 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") ReserveReceipts (@"github.com/ethereum/go-ethereum/eth/downloader".p·5 *@"github.com/ethereum/go-ethereum/eth/downloader".peer, @"github.com/ethereum/go-ethereum/eth/downloader".count·6 int) (? *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest, ? bool, ? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·1 *@"github.com/ethereum/go-ethereum/eth/downloader".queue) Reset ()
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·1 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") Revoke (@"github.com/ethereum/go-ethereum/eth/downloader".peerId·2 string "esc:0x1")
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue) Schedule (@"github.com/ethereum/go-ethereum/eth/downloader".headers·3 []*@"github.com/ethereum/go-ethereum/core/types".Header "esc:0x9", @"github.com/ethereum/go-ethereum/eth/downloader".from·4 uint64) (? []*@"github.com/ethereum/go-ethereum/core/types".Header)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") Schedule61 (@"github.com/ethereum/go-ethereum/eth/downloader".hashes·3 []@"github.com/ethereum/go-ethereum/common".Hash "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".fifo·4 bool) (? []@"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") ShouldThrottleBlocks () (? bool)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") ShouldThrottleReceipts () (? bool)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue) WaitResults () (? []*@"github.com/ethereum/go-ethereum/eth/downloader".fetchResult)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·1 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") @"github.com/ethereum/go-ethereum/eth/downloader".cancel (@"github.com/ethereum/go-ethereum/eth/downloader".request·2 *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x9", @"github.com/ethereum/go-ethereum/eth/downloader".taskQueue·3 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque "esc:0x9", @"github.com/ethereum/go-ethereum/eth/downloader".pendPool·4 map[string]*@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x1")
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue) @"github.com/ethereum/go-ethereum/eth/downloader".countProcessableItems () (? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·3 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") @"github.com/ethereum/go-ethereum/eth/downloader".deliver (@"github.com/ethereum/go-ethereum/eth/downloader".id·4 string "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".taskPool·5 map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/core/types".Header "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".taskQueue·6 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque "esc:0x9", @"github.com/ethereum/go-ethereum/eth/downloader".pendPool·7 map[string]*@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".donePool·8 map[@"github.com/ethereum/go-ethereum/common".Hash]struct {} "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".reqTimer·9 @"github.com/rcrowley/go-metrics".Timer, @"github.com/ethereum/go-ethereum/eth/downloader".results·10 int, @"github.com/ethereum/go-ethereum/eth/downloader".reconstruct·11 func(@"github.com/ethereum/go-ethereum/eth/downloader".header *@"github.com/ethereum/go-ethereum/core/types".Header, @"github.com/ethereum/go-ethereum/eth/downloader".index int, @"github.com/ethereum/go-ethereum/eth/downloader".result *@"github.com/ethereum/go-ethereum/eth/downloader".fetchResult) (? error) "esc:0x1") (? int, ? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·1 *@"github.com/ethereum/go-ethereum/eth/downloader".queue) @"github.com/ethereum/go-ethereum/eth/downloader".deliverNodeData (@"github.com/ethereum/go-ethereum/eth/downloader".results·2 []@"github.com/ethereum/go-ethereum/trie".SyncResult "esc:0x9", @"github.com/ethereum/go-ethereum/eth/downloader".callback·3 func(? error, ? int) "esc:0x1")
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x1") @"github.com/ethereum/go-ethereum/eth/downloader".expire (@"github.com/ethereum/go-ethereum/eth/downloader".timeout·3 @"time".Duration, @"github.com/ethereum/go-ethereum/eth/downloader".pendPool·4 map[string]*@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x9", @"github.com/ethereum/go-ethereum/eth/downloader".taskQueue·5 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque "esc:0x9", @"github.com/ethereum/go-ethereum/eth/downloader".timeoutMeter·6 @"github.com/rcrowley/go-metrics".Meter) (? map[string]int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·2 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x1") @"github.com/ethereum/go-ethereum/eth/downloader".reserveHashes (@"github.com/ethereum/go-ethereum/eth/downloader".p·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peer, @"github.com/ethereum/go-ethereum/eth/downloader".count·4 int, @"github.com/ethereum/go-ethereum/eth/downloader".taskQueue·5 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque "esc:0x9", @"github.com/ethereum/go-ethereum/eth/downloader".taskGen·6 func(? int) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".pendPool·7 map[string]*@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".maxPending·8 int) (? *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".q·4 *@"github.com/ethereum/go-ethereum/eth/downloader".queue "esc:0x9") @"github.com/ethereum/go-ethereum/eth/downloader".reserveHeaders (@"github.com/ethereum/go-ethereum/eth/downloader".p·5 *@"github.com/ethereum/go-ethereum/eth/downloader".peer, @"github.com/ethereum/go-ethereum/eth/downloader".count·6 int, @"github.com/ethereum/go-ethereum/eth/downloader".taskPool·7 map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/core/types".Header "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".taskQueue·8 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque "esc:0x9", @"github.com/ethereum/go-ethereum/eth/downloader".pendPool·9 map[string]*@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".donePool·10 map[@"github.com/ethereum/go-ethereum/common".Hash]struct {} "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".isNoop·11 func(? *@"github.com/ethereum/go-ethereum/core/types".Header) (? bool) "esc:0x1") (? *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest, ? bool, ? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".peerSet struct { @"github.com/ethereum/go-ethereum/eth/downloader".peers map[string]*@"github.com/ethereum/go-ethereum/eth/downloader".peer; @"github.com/ethereum/go-ethereum/eth/downloader".lock @"sync".RWMutex }
	func (@"github.com/ethereum/go-ethereum/eth/downloader".ps·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet) AllPeers () (? []*@"github.com/ethereum/go-ethereum/eth/downloader".peer)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".ps·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet) BlockIdlePeers () (? []*@"github.com/ethereum/go-ethereum/eth/downloader".peer, ? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".ps·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet) BodyIdlePeers () (? []*@"github.com/ethereum/go-ethereum/eth/downloader".peer, ? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".ps·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet) Len () (? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".ps·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet) NodeDataIdlePeers () (? []*@"github.com/ethereum/go-ethereum/eth/downloader".peer, ? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".ps·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet) Peer (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string "esc:0x1") (? *@"github.com/ethereum/go-ethereum/eth/downloader".peer)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".ps·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet) ReceiptIdlePeers () (? []*@"github.com/ethereum/go-ethereum/eth/downloader".peer, ? int)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".ps·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet) Register (@"github.com/ethereum/go-ethereum/eth/downloader".p·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".ps·1 *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet) Reset ()
	func (@"github.com/ethereum/go-ethereum/eth/downloader".ps·2 *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet) Unregister (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string "esc:0x1") (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".ps·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet) @"github.com/ethereum/go-ethereum/eth/downloader".idlePeers (@"github.com/ethereum/go-ethereum/eth/downloader".minProtocol·4 int, @"github.com/ethereum/go-ethereum/eth/downloader".maxProtocol·5 int, @"github.com/ethereum/go-ethereum/eth/downloader".idleCheck·6 func(? *@"github.com/ethereum/go-ethereum/eth/downloader".peer) (? bool) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".throughput·7 func(? *@"github.com/ethereum/go-ethereum/eth/downloader".peer) (? float64) "esc:0x1") (? []*@"github.com/ethereum/go-ethereum/eth/downloader".peer, ? int)
	type @"github.com/ethereum/go-ethereum/eth/downloader".headerCheckFn func(? @"github.com/ethereum/go-ethereum/common".Hash) (? bool)
	type @"github.com/ethereum/go-ethereum/eth/downloader".blockCheckFn func(? @"github.com/ethereum/go-ethereum/common".Hash) (? bool)
	type @"github.com/ethereum/go-ethereum/eth/downloader".headerRetrievalFn func(? @"github.com/ethereum/go-ethereum/common".Hash) (? *@"github.com/ethereum/go-ethereum/core/types".Header)
	type @"github.com/ethereum/go-ethereum/eth/downloader".blockRetrievalFn func(? @"github.com/ethereum/go-ethereum/common".Hash) (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	type @"github.com/ethereum/go-ethereum/eth/downloader".headHeaderRetrievalFn func() (? *@"github.com/ethereum/go-ethereum/core/types".Header)
	type @"github.com/ethereum/go-ethereum/eth/downloader".headBlockRetrievalFn func() (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	type @"github.com/ethereum/go-ethereum/eth/downloader".headFastBlockRetrievalFn func() (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	type @"github.com/ethereum/go-ethereum/eth/downloader".headBlockCommitterFn func(? @"github.com/ethereum/go-ethereum/common".Hash) (? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".tdRetrievalFn func(? @"github.com/ethereum/go-ethereum/common".Hash) (? *@"math/big".Int)
	type @"github.com/ethereum/go-ethereum/eth/downloader".headerChainInsertFn func(? []*@"github.com/ethereum/go-ethereum/core/types".Header, ? int) (? int, ? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".blockChainInsertFn func(? @"github.com/ethereum/go-ethereum/core/types".Blocks) (? int, ? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".receiptChainInsertFn func(? @"github.com/ethereum/go-ethereum/core/types".Blocks, ? []@"github.com/ethereum/go-ethereum/core/types".Receipts) (? int, ? error)
	type @"github.com/ethereum/go-ethereum/eth/downloader".chainRollbackFn func(? []@"github.com/ethereum/go-ethereum/common".Hash)
	type @"github.com/ethereum/go-ethereum/eth/downloader".peerDropFn func(@"github.com/ethereum/go-ethereum/eth/downloader".id string)
	type @"github.com/ethereum/go-ethereum/eth/downloader".dataPack interface { Items() (? int); PeerId() (? string); Stats() (? string) }
	type @"github.com/ethereum/go-ethereum/eth/downloader".Downloader struct { @"github.com/ethereum/go-ethereum/eth/downloader".mode @"github.com/ethereum/go-ethereum/eth/downloader".SyncMode; @"github.com/ethereum/go-ethereum/eth/downloader".noFast bool; @"github.com/ethereum/go-ethereum/eth/downloader".mux *@"github.com/ethereum/go-ethereum/event".TypeMux; @"github.com/ethereum/go-ethereum/eth/downloader".queue *@"github.com/ethereum/go-ethereum/eth/downloader".queue; @"github.com/ethereum/go-ethereum/eth/downloader".peers *@"github.com/ethereum/go-ethereum/eth/downloader".peerSet; @"github.com/ethereum/go-ethereum/eth/downloader".interrupt int32; @"github.com/ethereum/go-ethereum/eth/downloader".syncStatsChainOrigin uint64; @"github.com/ethereum/go-ethereum/eth/downloader".syncStatsChainHeight uint64; @"github.com/ethereum/go-ethereum/eth/downloader".syncStatsStateTotal uint64; @"github.com/ethereum/go-ethereum/eth/downloader".syncStatsStateDone uint64; @"github.com/ethereum/go-ethereum/eth/downloader".syncStatsLock @"sync".RWMutex; @"github.com/ethereum/go-ethereum/eth/downloader".hasHeader @"github.com/ethereum/go-ethereum/eth/downloader".headerCheckFn; @"github.com/ethereum/go-ethereum/eth/downloader".hasBlock @"github.com/ethereum/go-ethereum/eth/downloader".blockCheckFn; @"github.com/ethereum/go-ethereum/eth/downloader".getHeader @"github.com/ethereum/go-ethereum/eth/downloader".headerRetrievalFn; @"github.com/ethereum/go-ethereum/eth/downloader".getBlock @"github.com/ethereum/go-ethereum/eth/downloader".blockRetrievalFn; @"github.com/ethereum/go-ethereum/eth/downloader".headHeader @"github.com/ethereum/go-ethereum/eth/downloader".headHeaderRetrievalFn; @"github.com/ethereum/go-ethereum/eth/downloader".headBlock @"github.com/ethereum/go-ethereum/eth/downloader".headBlockRetrievalFn; @"github.com/ethereum/go-ethereum/eth/downloader".headFastBlock @"github.com/ethereum/go-ethereum/eth/downloader".headFastBlockRetrievalFn; @"github.com/ethereum/go-ethereum/eth/downloader".commitHeadBlock @"github.com/ethereum/go-ethereum/eth/downloader".headBlockCommitterFn; @"github.com/ethereum/go-ethereum/eth/downloader".getTd @"github.com/ethereum/go-ethereum/eth/downloader".tdRetrievalFn; @"github.com/ethereum/go-ethereum/eth/downloader".insertHeaders @"github.com/ethereum/go-ethereum/eth/downloader".headerChainInsertFn; @"github.com/ethereum/go-ethereum/eth/downloader".insertBlocks @"github.com/ethereum/go-ethereum/eth/downloader".blockChainInsertFn; @"github.com/ethereum/go-ethereum/eth/downloader".insertReceipts @"github.com/ethereum/go-ethereum/eth/downloader".receiptChainInsertFn; @"github.com/ethereum/go-ethereum/eth/downloader".rollback @"github.com/ethereum/go-ethereum/eth/downloader".chainRollbackFn; @"github.com/ethereum/go-ethereum/eth/downloader".dropPeer @"github.com/ethereum/go-ethereum/eth/downloader".peerDropFn; @"github.com/ethereum/go-ethereum/eth/downloader".synchroniseMock func(@"github.com/ethereum/go-ethereum/eth/downloader".id string, @"github.com/ethereum/go-ethereum/eth/downloader".hash @"github.com/ethereum/go-ethereum/common".Hash) (? error); @"github.com/ethereum/go-ethereum/eth/downloader".synchronising int32; @"github.com/ethereum/go-ethereum/eth/downloader".notified int32; @"github.com/ethereum/go-ethereum/eth/downloader".newPeerCh chan *@"github.com/ethereum/go-ethereum/eth/downloader".peer; @"github.com/ethereum/go-ethereum/eth/downloader".hashCh chan @"github.com/ethereum/go-ethereum/eth/downloader".dataPack; @"github.com/ethereum/go-ethereum/eth/downloader".blockCh chan @"github.com/ethereum/go-ethereum/eth/downloader".dataPack; @"github.com/ethereum/go-ethereum/eth/downloader".headerCh chan @"github.com/ethereum/go-ethereum/eth/downloader".dataPack; @"github.com/ethereum/go-ethereum/eth/downloader".bodyCh chan @"github.com/ethereum/go-ethereum/eth/downloader".dataPack; @"github.com/ethereum/go-ethereum/eth/downloader".receiptCh chan @"github.com/ethereum/go-ethereum/eth/downloader".dataPack; @"github.com/ethereum/go-ethereum/eth/downloader".stateCh chan @"github.com/ethereum/go-ethereum/eth/downloader".dataPack; @"github.com/ethereum/go-ethereum/eth/downloader".blockWakeCh chan bool; @"github.com/ethereum/go-ethereum/eth/downloader".bodyWakeCh chan bool; @"github.com/ethereum/go-ethereum/eth/downloader".receiptWakeCh chan bool; @"github.com/ethereum/go-ethereum/eth/downloader".stateWakeCh chan bool; @"github.com/ethereum/go-ethereum/eth/downloader".cancelCh chan struct {}; @"github.com/ethereum/go-ethereum/eth/downloader".cancelLock @"sync".RWMutex; @"github.com/ethereum/go-ethereum/eth/downloader".syncInitHook func(? uint64, ? uint64); @"github.com/ethereum/go-ethereum/eth/downloader".bodyFetchHook func(? []*@"github.com/ethereum/go-ethereum/core/types".Header); @"github.com/ethereum/go-ethereum/eth/downloader".receiptFetchHook func(? []*@"github.com/ethereum/go-ethereum/core/types".Header); @"github.com/ethereum/go-ethereum/eth/downloader".chainInsertHook func(? []*@"github.com/ethereum/go-ethereum/eth/downloader".fetchResult) }
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) DeliverBlocks (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string, @"github.com/ethereum/go-ethereum/eth/downloader".blocks·4 []*@"github.com/ethereum/go-ethereum/core/types".Block) (@"github.com/ethereum/go-ethereum/eth/downloader".err·1 error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) DeliverBodies (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string, @"github.com/ethereum/go-ethereum/eth/downloader".transactions·4 [][]*@"github.com/ethereum/go-ethereum/core/types".Transaction, @"github.com/ethereum/go-ethereum/eth/downloader".uncles·5 [][]*@"github.com/ethereum/go-ethereum/core/types".Header) (@"github.com/ethereum/go-ethereum/eth/downloader".err·1 error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) DeliverHashes (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string, @"github.com/ethereum/go-ethereum/eth/downloader".hashes·4 []@"github.com/ethereum/go-ethereum/common".Hash) (@"github.com/ethereum/go-ethereum/eth/downloader".err·1 error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) DeliverHeaders (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string, @"github.com/ethereum/go-ethereum/eth/downloader".headers·4 []*@"github.com/ethereum/go-ethereum/core/types".Header) (@"github.com/ethereum/go-ethereum/eth/downloader".err·1 error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) DeliverNodeData (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string, @"github.com/ethereum/go-ethereum/eth/downloader".data·4 [][]byte) (@"github.com/ethereum/go-ethereum/eth/downloader".err·1 error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) DeliverReceipts (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string, @"github.com/ethereum/go-ethereum/eth/downloader".receipts·4 [][]*@"github.com/ethereum/go-ethereum/core/types".Receipt) (@"github.com/ethereum/go-ethereum/eth/downloader".err·1 error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·4 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) Progress () (? uint64, ? uint64, ? uint64)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x9") RegisterPeer (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string, @"github.com/ethereum/go-ethereum/eth/downloader".version·4 int, @"github.com/ethereum/go-ethereum/eth/downloader".head·5 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/eth/downloader".getRelHashes·6 @"github.com/ethereum/go-ethereum/eth/downloader".relativeHashFetcherFn, @"github.com/ethereum/go-ethereum/eth/downloader".getAbsHashes·7 @"github.com/ethereum/go-ethereum/eth/downloader".absoluteHashFetcherFn, @"github.com/ethereum/go-ethereum/eth/downloader".getBlocks·8 @"github.com/ethereum/go-ethereum/eth/downloader".blockFetcherFn, @"github.com/ethereum/go-ethereum/eth/downloader".getRelHeaders·9 @"github.com/ethereum/go-ethereum/eth/downloader".relativeHeaderFetcherFn, @"github.com/ethereum/go-ethereum/eth/downloader".getAbsHeaders·10 @"github.com/ethereum/go-ethereum/eth/downloader".absoluteHeaderFetcherFn, @"github.com/ethereum/go-ethereum/eth/downloader".getBlockBodies·11 @"github.com/ethereum/go-ethereum/eth/downloader".blockBodyFetcherFn, @"github.com/ethereum/go-ethereum/eth/downloader".getReceipts·12 @"github.com/ethereum/go-ethereum/eth/downloader".receiptFetcherFn, @"github.com/ethereum/go-ethereum/eth/downloader".getNodeData·13 @"github.com/ethereum/go-ethereum/eth/downloader".stateFetcherFn) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) Synchronise (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string, @"github.com/ethereum/go-ethereum/eth/downloader".head·4 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/eth/downloader".td·5 *@"math/big".Int, @"github.com/ethereum/go-ethereum/eth/downloader".mode·6 @"github.com/ethereum/go-ethereum/eth/downloader".SyncMode) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) Synchronising () (? bool)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·1 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) Terminate ()
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x9") UnregisterPeer (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·1 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) @"github.com/ethereum/go-ethereum/eth/downloader".cancel ()
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) @"github.com/ethereum/go-ethereum/eth/downloader".deliver (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".destCh·4 chan @"github.com/ethereum/go-ethereum/eth/downloader".dataPack "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".packet·5 @"github.com/ethereum/go-ethereum/eth/downloader".dataPack, @"github.com/ethereum/go-ethereum/eth/downloader".inMeter·6 @"github.com/rcrowley/go-metrics".Meter, @"github.com/ethereum/go-ethereum/eth/downloader".dropMeter·7 @"github.com/rcrowley/go-metrics".Meter) (@"github.com/ethereum/go-ethereum/eth/downloader".err·1 error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x9") @"github.com/ethereum/go-ethereum/eth/downloader".fetchBlocks61 (@"github.com/ethereum/go-ethereum/eth/downloader".from·3 uint64) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x9") @"github.com/ethereum/go-ethereum/eth/downloader".fetchBodies (@"github.com/ethereum/go-ethereum/eth/downloader".from·3 uint64) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x9") @"github.com/ethereum/go-ethereum/eth/downloader".fetchHashes61 (@"github.com/ethereum/go-ethereum/eth/downloader".p·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peer, @"github.com/ethereum/go-ethereum/eth/downloader".td·4 *@"math/big".Int "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".from·5 uint64) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x9") @"github.com/ethereum/go-ethereum/eth/downloader".fetchHeaders (@"github.com/ethereum/go-ethereum/eth/downloader".p·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peer, @"github.com/ethereum/go-ethereum/eth/downloader".td·4 *@"math/big".Int "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".from·5 uint64) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·3 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x1") @"github.com/ethereum/go-ethereum/eth/downloader".fetchHeight (@"github.com/ethereum/go-ethereum/eth/downloader".p·4 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) (? uint64, ? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·3 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x1") @"github.com/ethereum/go-ethereum/eth/downloader".fetchHeight61 (@"github.com/ethereum/go-ethereum/eth/downloader".p·4 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) (? uint64, ? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) @"github.com/ethereum/go-ethereum/eth/downloader".fetchNodeData () (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x9") @"github.com/ethereum/go-ethereum/eth/downloader".fetchParts (@"github.com/ethereum/go-ethereum/eth/downloader".errCancel·3 error "esc:0x12", @"github.com/ethereum/go-ethereum/eth/downloader".deliveryCh·4 chan @"github.com/ethereum/go-ethereum/eth/downloader".dataPack "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".deliver·5 func(? @"github.com/ethereum/go-ethereum/eth/downloader".dataPack) (? int, ? error) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".wakeCh·6 chan bool "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".expire·7 func() (? map[string]int) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".pending·8 func() (? int) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".inFlight·9 func() (? bool) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".throttle·10 func() (? bool) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".reserve·11 func(? *@"github.com/ethereum/go-ethereum/eth/downloader".peer, ? int) (? *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest, ? bool, ? error) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".fetchHook·12 func(? []*@"github.com/ethereum/go-ethereum/core/types".Header) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".fetch·13 func(? *@"github.com/ethereum/go-ethereum/eth/downloader".peer, ? *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest) (? error) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".cancel·14 func(? *@"github.com/ethereum/go-ethereum/eth/downloader".fetchRequest) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".capacity·15 func(? *@"github.com/ethereum/go-ethereum/eth/downloader".peer) (? int) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".idle·16 func() (? []*@"github.com/ethereum/go-ethereum/eth/downloader".peer, ? int) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".setIdle·17 func(? *@"github.com/ethereum/go-ethereum/eth/downloader".peer, ? int) "esc:0x1", @"github.com/ethereum/go-ethereum/eth/downloader".kind·18 string) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x9") @"github.com/ethereum/go-ethereum/eth/downloader".fetchReceipts (@"github.com/ethereum/go-ethereum/eth/downloader".from·3 uint64) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·3 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x1") @"github.com/ethereum/go-ethereum/eth/downloader".findAncestor (@"github.com/ethereum/go-ethereum/eth/downloader".p·4 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) (? uint64, ? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·3 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader "esc:0x1") @"github.com/ethereum/go-ethereum/eth/downloader".findAncestor61 (@"github.com/ethereum/go-ethereum/eth/downloader".p·4 *@"github.com/ethereum/go-ethereum/eth/downloader".peer) (? uint64, ? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) @"github.com/ethereum/go-ethereum/eth/downloader".process () (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) @"github.com/ethereum/go-ethereum/eth/downloader".spawnSync (@"github.com/ethereum/go-ethereum/eth/downloader".fetchers·3 ...func() (? error) "esc:0x9") (? error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) @"github.com/ethereum/go-ethereum/eth/downloader".syncWithPeer (@"github.com/ethereum/go-ethereum/eth/downloader".p·3 *@"github.com/ethereum/go-ethereum/eth/downloader".peer, @"github.com/ethereum/go-ethereum/eth/downloader".hash·4 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/eth/downloader".td·5 *@"math/big".Int) (@"github.com/ethereum/go-ethereum/eth/downloader".err·1 error)
	func (@"github.com/ethereum/go-ethereum/eth/downloader".d·2 *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) @"github.com/ethereum/go-ethereum/eth/downloader".synchronise (@"github.com/ethereum/go-ethereum/eth/downloader".id·3 string, @"github.com/ethereum/go-ethereum/eth/downloader".hash·4 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/eth/downloader".td·5 *@"math/big".Int, @"github.com/ethereum/go-ethereum/eth/downloader".mode·6 @"github.com/ethereum/go-ethereum/eth/downloader".SyncMode) (? error)
	import fetcher "github.com/ethereum/go-ethereum/eth/fetcher" // indirect
	type @"github.com/ethereum/go-ethereum/eth/fetcher".blockRequesterFn func(? []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	type @"github.com/ethereum/go-ethereum/eth/fetcher".headerRequesterFn func(? @"github.com/ethereum/go-ethereum/common".Hash) (? error)
	type @"github.com/ethereum/go-ethereum/eth/fetcher".bodyRequesterFn func(? []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	type @"github.com/ethereum/go-ethereum/eth/fetcher".announce struct { @"github.com/ethereum/go-ethereum/eth/fetcher".hash @"github.com/ethereum/go-ethereum/common".Hash; @"github.com/ethereum/go-ethereum/eth/fetcher".number uint64; @"github.com/ethereum/go-ethereum/eth/fetcher".header *@"github.com/ethereum/go-ethereum/core/types".Header; @"github.com/ethereum/go-ethereum/eth/fetcher".time @"time".Time; @"github.com/ethereum/go-ethereum/eth/fetcher".origin string; @"github.com/ethereum/go-ethereum/eth/fetcher".fetch61 @"github.com/ethereum/go-ethereum/eth/fetcher".blockRequesterFn; @"github.com/ethereum/go-ethereum/eth/fetcher".fetchHeader @"github.com/ethereum/go-ethereum/eth/fetcher".headerRequesterFn; @"github.com/ethereum/go-ethereum/eth/fetcher".fetchBodies @"github.com/ethereum/go-ethereum/eth/fetcher".bodyRequesterFn }
	type @"github.com/ethereum/go-ethereum/eth/fetcher".inject struct { @"github.com/ethereum/go-ethereum/eth/fetcher".origin string; @"github.com/ethereum/go-ethereum/eth/fetcher".block *@"github.com/ethereum/go-ethereum/core/types".Block }
	type @"github.com/ethereum/go-ethereum/eth/fetcher".headerFilterTask struct { @"github.com/ethereum/go-ethereum/eth/fetcher".headers []*@"github.com/ethereum/go-ethereum/core/types".Header; @"github.com/ethereum/go-ethereum/eth/fetcher".time @"time".Time }
	type @"github.com/ethereum/go-ethereum/eth/fetcher".bodyFilterTask struct { @"github.com/ethereum/go-ethereum/eth/fetcher".transactions [][]*@"github.com/ethereum/go-ethereum/core/types".Transaction; @"github.com/ethereum/go-ethereum/eth/fetcher".uncles [][]*@"github.com/ethereum/go-ethereum/core/types".Header; @"github.com/ethereum/go-ethereum/eth/fetcher".time @"time".Time }
	type @"github.com/ethereum/go-ethereum/eth/fetcher".blockRetrievalFn func(? @"github.com/ethereum/go-ethereum/common".Hash) (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	type @"github.com/ethereum/go-ethereum/eth/fetcher".blockValidatorFn func(@"github.com/ethereum/go-ethereum/eth/fetcher".block *@"github.com/ethereum/go-ethereum/core/types".Block, @"github.com/ethereum/go-ethereum/eth/fetcher".parent *@"github.com/ethereum/go-ethereum/core/types".Block) (? error)
	type @"github.com/ethereum/go-ethereum/eth/fetcher".blockBroadcasterFn func(@"github.com/ethereum/go-ethereum/eth/fetcher".block *@"github.com/ethereum/go-ethereum/core/types".Block, @"github.com/ethereum/go-ethereum/eth/fetcher".propagate bool)
	type @"github.com/ethereum/go-ethereum/eth/fetcher".chainHeightFn func() (? uint64)
	type @"github.com/ethereum/go-ethereum/eth/fetcher".chainInsertFn func(? @"github.com/ethereum/go-ethereum/core/types".Blocks) (? int, ? error)
	type @"github.com/ethereum/go-ethereum/eth/fetcher".peerDropFn func(@"github.com/ethereum/go-ethereum/eth/fetcher".id string)
	type @"time".runtimeTimer struct { @"time".i int; @"time".when int64; @"time".period int64; @"time".f func(? interface {}, ? uintptr); @"time".arg interface {}; @"time".seq uintptr }
	type @"time".Timer struct { C <-chan @"time".Time; @"time".r @"time".runtimeTimer }
	func (@"time".t·2 *@"time".Timer) Reset (@"time".d·3 @"time".Duration) (? bool)
	func (@"time".t·2 *@"time".Timer) Stop () (? bool)
	type @"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher struct { @"github.com/ethereum/go-ethereum/eth/fetcher".notify chan *@"github.com/ethereum/go-ethereum/eth/fetcher".announce; @"github.com/ethereum/go-ethereum/eth/fetcher".inject chan *@"github.com/ethereum/go-ethereum/eth/fetcher".inject; @"github.com/ethereum/go-ethereum/eth/fetcher".blockFilter chan chan []*@"github.com/ethereum/go-ethereum/core/types".Block; @"github.com/ethereum/go-ethereum/eth/fetcher".headerFilter chan chan *@"github.com/ethereum/go-ethereum/eth/fetcher".headerFilterTask; @"github.com/ethereum/go-ethereum/eth/fetcher".bodyFilter chan chan *@"github.com/ethereum/go-ethereum/eth/fetcher".bodyFilterTask; @"github.com/ethereum/go-ethereum/eth/fetcher".done chan @"github.com/ethereum/go-ethereum/common".Hash; @"github.com/ethereum/go-ethereum/eth/fetcher".quit chan struct {}; @"github.com/ethereum/go-ethereum/eth/fetcher".announces map[string]int; @"github.com/ethereum/go-ethereum/eth/fetcher".announced map[@"github.com/ethereum/go-ethereum/common".Hash][]*@"github.com/ethereum/go-ethereum/eth/fetcher".announce; @"github.com/ethereum/go-ethereum/eth/fetcher".fetching map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/eth/fetcher".announce; @"github.com/ethereum/go-ethereum/eth/fetcher".fetched map[@"github.com/ethereum/go-ethereum/common".Hash][]*@"github.com/ethereum/go-ethereum/eth/fetcher".announce; @"github.com/ethereum/go-ethereum/eth/fetcher".completing map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/eth/fetcher".announce; @"github.com/ethereum/go-ethereum/eth/fetcher".queue *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque; @"github.com/ethereum/go-ethereum/eth/fetcher".queues map[string]int; @"github.com/ethereum/go-ethereum/eth/fetcher".queued map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/eth/fetcher".inject; @"github.com/ethereum/go-ethereum/eth/fetcher".getBlock @"github.com/ethereum/go-ethereum/eth/fetcher".blockRetrievalFn; @"github.com/ethereum/go-ethereum/eth/fetcher".validateBlock @"github.com/ethereum/go-ethereum/eth/fetcher".blockValidatorFn; @"github.com/ethereum/go-ethereum/eth/fetcher".broadcastBlock @"github.com/ethereum/go-ethereum/eth/fetcher".blockBroadcasterFn; @"github.com/ethereum/go-ethereum/eth/fetcher".chainHeight @"github.com/ethereum/go-ethereum/eth/fetcher".chainHeightFn; @"github.com/ethereum/go-ethereum/eth/fetcher".insertChain @"github.com/ethereum/go-ethereum/eth/fetcher".chainInsertFn; @"github.com/ethereum/go-ethereum/eth/fetcher".dropPeer @"github.com/ethereum/go-ethereum/eth/fetcher".peerDropFn; @"github.com/ethereum/go-ethereum/eth/fetcher".announceChangeHook func(? @"github.com/ethereum/go-ethereum/common".Hash, ? bool); @"github.com/ethereum/go-ethereum/eth/fetcher".queueChangeHook func(? @"github.com/ethereum/go-ethereum/common".Hash, ? bool); @"github.com/ethereum/go-ethereum/eth/fetcher".fetchingHook func(? []@"github.com/ethereum/go-ethereum/common".Hash); @"github.com/ethereum/go-ethereum/eth/fetcher".completingHook func(? []@"github.com/ethereum/go-ethereum/common".Hash); @"github.com/ethereum/go-ethereum/eth/fetcher".importedHook func(? *@"github.com/ethereum/go-ethereum/core/types".Block) }
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·2 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher "esc:0x1") Enqueue (@"github.com/ethereum/go-ethereum/eth/fetcher".peer·3 string, @"github.com/ethereum/go-ethereum/eth/fetcher".block·4 *@"github.com/ethereum/go-ethereum/core/types".Block) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·2 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher "esc:0x1") FilterBlocks (@"github.com/ethereum/go-ethereum/eth/fetcher".blocks·3 @"github.com/ethereum/go-ethereum/core/types".Blocks) (? @"github.com/ethereum/go-ethereum/core/types".Blocks)
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·3 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher "esc:0x1") FilterBodies (@"github.com/ethereum/go-ethereum/eth/fetcher".transactions·4 [][]*@"github.com/ethereum/go-ethereum/core/types".Transaction, @"github.com/ethereum/go-ethereum/eth/fetcher".uncles·5 [][]*@"github.com/ethereum/go-ethereum/core/types".Header, @"github.com/ethereum/go-ethereum/eth/fetcher".time·6 @"time".Time) (? [][]*@"github.com/ethereum/go-ethereum/core/types".Transaction, ? [][]*@"github.com/ethereum/go-ethereum/core/types".Header)
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·2 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher "esc:0x1") FilterHeaders (@"github.com/ethereum/go-ethereum/eth/fetcher".headers·3 []*@"github.com/ethereum/go-ethereum/core/types".Header, @"github.com/ethereum/go-ethereum/eth/fetcher".time·4 @"time".Time) (? []*@"github.com/ethereum/go-ethereum/core/types".Header)
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·2 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher "esc:0x1") Notify (@"github.com/ethereum/go-ethereum/eth/fetcher".peer·3 string, @"github.com/ethereum/go-ethereum/eth/fetcher".hash·4 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/eth/fetcher".number·5 uint64, @"github.com/ethereum/go-ethereum/eth/fetcher".time·6 @"time".Time, @"github.com/ethereum/go-ethereum/eth/fetcher".blockFetcher·7 @"github.com/ethereum/go-ethereum/eth/fetcher".blockRequesterFn, @"github.com/ethereum/go-ethereum/eth/fetcher".headerFetcher·8 @"github.com/ethereum/go-ethereum/eth/fetcher".headerRequesterFn, @"github.com/ethereum/go-ethereum/eth/fetcher".bodyFetcher·9 @"github.com/ethereum/go-ethereum/eth/fetcher".bodyRequesterFn) (? error)
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·1 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher) Start ()
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·1 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher "esc:0x1") Stop () { close(@"github.com/ethereum/go-ethereum/eth/fetcher".f·1.@"github.com/ethereum/go-ethereum/eth/fetcher".quit) }
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·1 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher "esc:0x9") @"github.com/ethereum/go-ethereum/eth/fetcher".enqueue (@"github.com/ethereum/go-ethereum/eth/fetcher".peer·2 string, @"github.com/ethereum/go-ethereum/eth/fetcher".block·3 *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·1 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher "esc:0x1") @"github.com/ethereum/go-ethereum/eth/fetcher".forgetBlock (@"github.com/ethereum/go-ethereum/eth/fetcher".hash·2 @"github.com/ethereum/go-ethereum/common".Hash) { var @"github.com/ethereum/go-ethereum/eth/fetcher".insert·3 *@"github.com/ethereum/go-ethereum/eth/fetcher".inject; ; @"github.com/ethereum/go-ethereum/eth/fetcher".insert·3 = @"github.com/ethereum/go-ethereum/eth/fetcher".f·1.@"github.com/ethereum/go-ethereum/eth/fetcher".queued[@"github.com/ethereum/go-ethereum/eth/fetcher".hash·2]; if @"github.com/ethereum/go-ethereum/eth/fetcher".insert·3 != nil { @"github.com/ethereum/go-ethereum/eth/fetcher".f·1.@"github.com/ethereum/go-ethereum/eth/fetcher".queues[@"github.com/ethereum/go-ethereum/eth/fetcher".insert·3.@"github.com/ethereum/go-ethereum/eth/fetcher".origin]--; if @"github.com/ethereum/go-ethereum/eth/fetcher".f·1.@"github.com/ethereum/go-ethereum/eth/fetcher".queues[@"github.com/ethereum/go-ethereum/eth/fetcher".insert·3.@"github.com/ethereum/go-ethereum/eth/fetcher".origin] == 0x0 { delete(@"github.com/ethereum/go-ethereum/eth/fetcher".f·1.@"github.com/ethereum/go-ethereum/eth/fetcher".queues, @"github.com/ethereum/go-ethereum/eth/fetcher".insert·3.@"github.com/ethereum/go-ethereum/eth/fetcher".origin) }; delete(@"github.com/ethereum/go-ethereum/eth/fetcher".f·1.@"github.com/ethereum/go-ethereum/eth/fetcher".queued, @"github.com/ethereum/go-ethereum/eth/fetcher".hash·2) } }
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·1 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher "esc:0x9") @"github.com/ethereum/go-ethereum/eth/fetcher".forgetHash (@"github.com/ethereum/go-ethereum/eth/fetcher".hash·2 @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·1 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher) @"github.com/ethereum/go-ethereum/eth/fetcher".insert (@"github.com/ethereum/go-ethereum/eth/fetcher".peer·2 string, @"github.com/ethereum/go-ethereum/eth/fetcher".block·3 *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·1 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher) @"github.com/ethereum/go-ethereum/eth/fetcher".loop ()
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·1 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher "esc:0x1") @"github.com/ethereum/go-ethereum/eth/fetcher".rescheduleComplete (@"github.com/ethereum/go-ethereum/eth/fetcher".complete·2 *@"time".Timer)
	func (@"github.com/ethereum/go-ethereum/eth/fetcher".f·1 *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher "esc:0x1") @"github.com/ethereum/go-ethereum/eth/fetcher".rescheduleFetch (@"github.com/ethereum/go-ethereum/eth/fetcher".fetch·2 *@"time".Timer)
	type @"github.com/ethereum/go-ethereum/eth".PeerInfo struct { Version int "json:\"version\""; Difficulty *@"math/big".Int "json:\"difficulty\""; Head string "json:\"head\"" }
	type @"github.com/ethereum/go-ethereum/eth".blockBody struct { Transactions []*@"github.com/ethereum/go-ethereum/core/types".Transaction; Uncles []*@"github.com/ethereum/go-ethereum/core/types".Header }
	type @"github.com/ethereum/go-ethereum/eth".statusData struct { ProtocolVersion uint32; NetworkId uint32; TD *@"math/big".Int; CurrentBlock @"github.com/ethereum/go-ethereum/common".Hash; GenesisBlock @"github.com/ethereum/go-ethereum/common".Hash }
	type @"github.com/ethereum/go-ethereum/eth".peer struct { @"github.com/ethereum/go-ethereum/eth".id string; ? *@"github.com/ethereum/go-ethereum/p2p".Peer; @"github.com/ethereum/go-ethereum/eth".rw @"github.com/ethereum/go-ethereum/p2p".MsgReadWriter; @"github.com/ethereum/go-ethereum/eth".version int; @"github.com/ethereum/go-ethereum/eth".head @"github.com/ethereum/go-ethereum/common".Hash; @"github.com/ethereum/go-ethereum/eth".td *@"math/big".Int; @"github.com/ethereum/go-ethereum/eth".lock @"sync".RWMutex; @"github.com/ethereum/go-ethereum/eth".knownTxs *@"gopkg.in/fatih/set.v0".Set; @"github.com/ethereum/go-ethereum/eth".knownBlocks *@"gopkg.in/fatih/set.v0".Set }
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) Handshake (@"github.com/ethereum/go-ethereum/eth".network·3 int, @"github.com/ethereum/go-ethereum/eth".td·4 *@"math/big".Int, @"github.com/ethereum/go-ethereum/eth".head·5 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/eth".genesis·6 @"github.com/ethereum/go-ethereum/common".Hash) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) Head () (@"github.com/ethereum/go-ethereum/eth".hash·1 @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) Info () (? *@"github.com/ethereum/go-ethereum/eth".PeerInfo)
	func (@"github.com/ethereum/go-ethereum/eth".p·1 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") MarkBlock (@"github.com/ethereum/go-ethereum/eth".hash·2 @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/eth".p·1 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") MarkTransaction (@"github.com/ethereum/go-ethereum/eth".hash·2 @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) RequestBlocks (@"github.com/ethereum/go-ethereum/eth".hashes·3 []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) RequestBodies (@"github.com/ethereum/go-ethereum/eth".hashes·3 []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) RequestHashes (@"github.com/ethereum/go-ethereum/eth".from·3 @"github.com/ethereum/go-ethereum/common".Hash) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) RequestHashesFromNumber (@"github.com/ethereum/go-ethereum/eth".from·3 uint64, @"github.com/ethereum/go-ethereum/eth".count·4 int) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) RequestHeadersByHash (@"github.com/ethereum/go-ethereum/eth".origin·3 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/eth".amount·4 int, @"github.com/ethereum/go-ethereum/eth".skip·5 int, @"github.com/ethereum/go-ethereum/eth".reverse·6 bool) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) RequestHeadersByNumber (@"github.com/ethereum/go-ethereum/eth".origin·3 uint64, @"github.com/ethereum/go-ethereum/eth".amount·4 int, @"github.com/ethereum/go-ethereum/eth".skip·5 int, @"github.com/ethereum/go-ethereum/eth".reverse·6 bool) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) RequestNodeData (@"github.com/ethereum/go-ethereum/eth".hashes·3 []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) RequestOneHeader (@"github.com/ethereum/go-ethereum/eth".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) RequestReceipts (@"github.com/ethereum/go-ethereum/eth".hashes·3 []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") SendBlockBodies (@"github.com/ethereum/go-ethereum/eth".bodies·3 []*@"github.com/ethereum/go-ethereum/eth".blockBody) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") SendBlockBodiesRLP (@"github.com/ethereum/go-ethereum/eth".bodies·3 []@"github.com/ethereum/go-ethereum/rlp".RawValue) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") SendBlockHashes (@"github.com/ethereum/go-ethereum/eth".hashes·3 []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") SendBlockHeaders (@"github.com/ethereum/go-ethereum/eth".headers·3 []*@"github.com/ethereum/go-ethereum/core/types".Header) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") SendBlocks (@"github.com/ethereum/go-ethereum/eth".blocks·3 []*@"github.com/ethereum/go-ethereum/core/types".Block) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") SendNewBlock (@"github.com/ethereum/go-ethereum/eth".block·3 *@"github.com/ethereum/go-ethereum/core/types".Block, @"github.com/ethereum/go-ethereum/eth".td·4 *@"math/big".Int) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") SendNewBlockHashes (@"github.com/ethereum/go-ethereum/eth".hashes·3 []@"github.com/ethereum/go-ethereum/common".Hash "esc:0x1", @"github.com/ethereum/go-ethereum/eth".numbers·4 []uint64 "esc:0x1") (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") SendNewBlockHashes61 (@"github.com/ethereum/go-ethereum/eth".hashes·3 []@"github.com/ethereum/go-ethereum/common".Hash) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") SendNodeData (@"github.com/ethereum/go-ethereum/eth".data·3 [][]byte) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") SendReceiptsRLP (@"github.com/ethereum/go-ethereum/eth".receipts·3 []@"github.com/ethereum/go-ethereum/rlp".RawValue) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") SendTransactions (@"github.com/ethereum/go-ethereum/eth".txs·3 @"github.com/ethereum/go-ethereum/core/types".Transactions) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".p·1 *@"github.com/ethereum/go-ethereum/eth".peer) SetHead (@"github.com/ethereum/go-ethereum/eth".hash·2 @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/eth".p·1 *@"github.com/ethereum/go-ethereum/eth".peer) SetTd (@"github.com/ethereum/go-ethereum/eth".td·2 *@"math/big".Int "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") String () (? string)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer) Td () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer "esc:0x9") @"github.com/ethereum/go-ethereum/eth".readStatus (@"github.com/ethereum/go-ethereum/eth".network·3 int, @"github.com/ethereum/go-ethereum/eth".status·4 *@"github.com/ethereum/go-ethereum/eth".statusData, @"github.com/ethereum/go-ethereum/eth".genesis·5 @"github.com/ethereum/go-ethereum/common".Hash) (@"github.com/ethereum/go-ethereum/eth".err·1 error)
	type @"github.com/ethereum/go-ethereum/eth".peerSet struct { @"github.com/ethereum/go-ethereum/eth".peers map[string]*@"github.com/ethereum/go-ethereum/eth".peer; @"github.com/ethereum/go-ethereum/eth".lock @"sync".RWMutex }
	func (@"github.com/ethereum/go-ethereum/eth".ps·2 *@"github.com/ethereum/go-ethereum/eth".peerSet) BestPeer () (? *@"github.com/ethereum/go-ethereum/eth".peer)
	func (@"github.com/ethereum/go-ethereum/eth".ps·2 *@"github.com/ethereum/go-ethereum/eth".peerSet) Len () (? int)
	func (@"github.com/ethereum/go-ethereum/eth".ps·2 *@"github.com/ethereum/go-ethereum/eth".peerSet) Peer (@"github.com/ethereum/go-ethereum/eth".id·3 string "esc:0x1") (? *@"github.com/ethereum/go-ethereum/eth".peer)
	func (@"github.com/ethereum/go-ethereum/eth".ps·2 *@"github.com/ethereum/go-ethereum/eth".peerSet) PeersWithoutBlock (@"github.com/ethereum/go-ethereum/eth".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? []*@"github.com/ethereum/go-ethereum/eth".peer)
	func (@"github.com/ethereum/go-ethereum/eth".ps·2 *@"github.com/ethereum/go-ethereum/eth".peerSet) PeersWithoutTx (@"github.com/ethereum/go-ethereum/eth".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? []*@"github.com/ethereum/go-ethereum/eth".peer)
	func (@"github.com/ethereum/go-ethereum/eth".ps·2 *@"github.com/ethereum/go-ethereum/eth".peerSet) Register (@"github.com/ethereum/go-ethereum/eth".p·3 *@"github.com/ethereum/go-ethereum/eth".peer) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".ps·2 *@"github.com/ethereum/go-ethereum/eth".peerSet) Unregister (@"github.com/ethereum/go-ethereum/eth".id·3 string "esc:0x1") (? error)
	type @"github.com/ethereum/go-ethereum/eth".txsync struct { @"github.com/ethereum/go-ethereum/eth".p *@"github.com/ethereum/go-ethereum/eth".peer; @"github.com/ethereum/go-ethereum/eth".txs []*@"github.com/ethereum/go-ethereum/core/types".Transaction }
	type @"github.com/ethereum/go-ethereum/eth".EthNodeInfo struct { Network int "json:\"network\""; Difficulty *@"math/big".Int "json:\"difficulty\""; Genesis string "json:\"genesis\""; Head string "json:\"head\"" }
	type @"github.com/ethereum/go-ethereum/eth".ProtocolManager struct { @"github.com/ethereum/go-ethereum/eth".networkId int; @"github.com/ethereum/go-ethereum/eth".fastSync bool; @"github.com/ethereum/go-ethereum/eth".txpool @"github.com/ethereum/go-ethereum/eth".txPool; @"github.com/ethereum/go-ethereum/eth".blockchain *@"github.com/ethereum/go-ethereum/core".BlockChain; @"github.com/ethereum/go-ethereum/eth".chaindb @"github.com/ethereum/go-ethereum/ethdb".Database; @"github.com/ethereum/go-ethereum/eth".downloader *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader; @"github.com/ethereum/go-ethereum/eth".fetcher *@"github.com/ethereum/go-ethereum/eth/fetcher".Fetcher; @"github.com/ethereum/go-ethereum/eth".peers *@"github.com/ethereum/go-ethereum/eth".peerSet; SubProtocols []@"github.com/ethereum/go-ethereum/p2p".Protocol; @"github.com/ethereum/go-ethereum/eth".eventMux *@"github.com/ethereum/go-ethereum/event".TypeMux; @"github.com/ethereum/go-ethereum/eth".txSub @"github.com/ethereum/go-ethereum/event".Subscription; @"github.com/ethereum/go-ethereum/eth".minedBlockSub @"github.com/ethereum/go-ethereum/event".Subscription; @"github.com/ethereum/go-ethereum/eth".newPeerCh chan *@"github.com/ethereum/go-ethereum/eth".peer; @"github.com/ethereum/go-ethereum/eth".txsyncCh chan *@"github.com/ethereum/go-ethereum/eth".txsync; @"github.com/ethereum/go-ethereum/eth".quitSync chan struct {}; @"github.com/ethereum/go-ethereum/eth".wg @"sync".WaitGroup; @"github.com/ethereum/go-ethereum/eth".quit bool }
	func (@"github.com/ethereum/go-ethereum/eth".pm·1 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager "esc:0x9") BroadcastBlock (@"github.com/ethereum/go-ethereum/eth".block·2 *@"github.com/ethereum/go-ethereum/core/types".Block, @"github.com/ethereum/go-ethereum/eth".propagate·3 bool)
	func (@"github.com/ethereum/go-ethereum/eth".pm·1 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager "esc:0x9") BroadcastTx (@"github.com/ethereum/go-ethereum/eth".hash·2 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/eth".tx·3 *@"github.com/ethereum/go-ethereum/core/types".Transaction)
	func (@"github.com/ethereum/go-ethereum/eth".self·2 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager "esc:0x9") NodeInfo () (? *@"github.com/ethereum/go-ethereum/eth".EthNodeInfo)
	func (@"github.com/ethereum/go-ethereum/eth".pm·1 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager) Start ()
	func (@"github.com/ethereum/go-ethereum/eth".pm·1 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager) Stop ()
	func (@"github.com/ethereum/go-ethereum/eth".pm·2 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager) @"github.com/ethereum/go-ethereum/eth".handle (@"github.com/ethereum/go-ethereum/eth".p·3 *@"github.com/ethereum/go-ethereum/eth".peer) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".pm·2 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager) @"github.com/ethereum/go-ethereum/eth".handleMsg (@"github.com/ethereum/go-ethereum/eth".p·3 *@"github.com/ethereum/go-ethereum/eth".peer) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".self·1 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager "esc:0x9") @"github.com/ethereum/go-ethereum/eth".minedBroadcastLoop ()
	func (@"github.com/ethereum/go-ethereum/eth".pm·2 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager "esc:0x1") @"github.com/ethereum/go-ethereum/eth".newPeer (@"github.com/ethereum/go-ethereum/eth".pv·3 int, @"github.com/ethereum/go-ethereum/eth".p·4 *@"github.com/ethereum/go-ethereum/p2p".Peer, @"github.com/ethereum/go-ethereum/eth".rw·5 @"github.com/ethereum/go-ethereum/p2p".MsgReadWriter) (? *@"github.com/ethereum/go-ethereum/eth".peer)
	func (@"github.com/ethereum/go-ethereum/eth".pm·1 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager "esc:0x9") @"github.com/ethereum/go-ethereum/eth".removePeer (@"github.com/ethereum/go-ethereum/eth".id·2 string)
	func (@"github.com/ethereum/go-ethereum/eth".pm·1 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager "esc:0x9") @"github.com/ethereum/go-ethereum/eth".syncTransactions (@"github.com/ethereum/go-ethereum/eth".p·2 *@"github.com/ethereum/go-ethereum/eth".peer)
	func (@"github.com/ethereum/go-ethereum/eth".pm·1 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager) @"github.com/ethereum/go-ethereum/eth".syncer ()
	func (@"github.com/ethereum/go-ethereum/eth".pm·1 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager "esc:0x9") @"github.com/ethereum/go-ethereum/eth".synchronise (@"github.com/ethereum/go-ethereum/eth".peer·2 *@"github.com/ethereum/go-ethereum/eth".peer)
	func (@"github.com/ethereum/go-ethereum/eth".self·1 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager "esc:0x9") @"github.com/ethereum/go-ethereum/eth".txBroadcastLoop ()
	func (@"github.com/ethereum/go-ethereum/eth".pm·1 *@"github.com/ethereum/go-ethereum/eth".ProtocolManager "esc:0x1") @"github.com/ethereum/go-ethereum/eth".txsyncLoop ()
	import compiler "github.com/ethereum/go-ethereum/common/compiler" // indirect
	type @"github.com/ethereum/go-ethereum/common/compiler".ContractInfo struct { Source string "json:\"source\""; Language string "json:\"language\""; LanguageVersion string "json:\"languageVersion\""; CompilerVersion string "json:\"compilerVersion\""; CompilerOptions string "json:\"compilerOptions\""; AbiDefinition interface {} "json:\"abiDefinition\""; UserDoc interface {} "json:\"userDoc\""; DeveloperDoc interface {} "json:\"developerDoc\"" }
	type @"github.com/ethereum/go-ethereum/common/compiler".Contract struct { Code string "json:\"code\""; Info @"github.com/ethereum/go-ethereum/common/compiler".ContractInfo "json:\"info\"" }
	type @"github.com/ethereum/go-ethereum/common/compiler".Solidity struct { @"github.com/ethereum/go-ethereum/common/compiler".solcPath string; @"github.com/ethereum/go-ethereum/common/compiler".version string; @"github.com/ethereum/go-ethereum/common/compiler".fullVersion string; @"github.com/ethereum/go-ethereum/common/compiler".legacy bool }
	func (@"github.com/ethereum/go-ethereum/common/compiler".sol·3 *@"github.com/ethereum/go-ethereum/common/compiler".Solidity "esc:0x9") Compile (@"github.com/ethereum/go-ethereum/common/compiler".source·4 string) (? map[string]*@"github.com/ethereum/go-ethereum/common/compiler".Contract, ? error)
	func (@"github.com/ethereum/go-ethereum/common/compiler".sol·2 *@"github.com/ethereum/go-ethereum/common/compiler".Solidity "esc:0x9") Info () (? string)
	func (@"github.com/ethereum/go-ethereum/common/compiler".sol·2 *@"github.com/ethereum/go-ethereum/common/compiler".Solidity "esc:0x22") Version () (? string) { return @"github.com/ethereum/go-ethereum/common/compiler".sol·2.@"github.com/ethereum/go-ethereum/common/compiler".version }
	import http "net/http" // indirect
	type @"net/http".connectMethodKey struct { @"net/http".proxy string; @"net/http".scheme string; @"net/http".addr string }
	func (@"net/http".k·2 @"net/http".connectMethodKey) String () (? string)
	import tls "crypto/tls" // indirect
	import x509 "crypto/x509" // indirect
	type @"crypto/x509".SignatureAlgorithm int
	type @"crypto/x509".PublicKeyAlgorithm int
	import pkix "crypto/x509/pkix" // indirect
	import asn1 "encoding/asn1" // indirect
	type @"encoding/asn1".ObjectIdentifier []int
	func (@"encoding/asn1".oi·2 @"encoding/asn1".ObjectIdentifier "esc:0x1") Equal (@"encoding/asn1".other·3 @"encoding/asn1".ObjectIdentifier "esc:0x1") (? bool)
	func (@"encoding/asn1".oi·2 @"encoding/asn1".ObjectIdentifier "esc:0x1") String () (? string)
	type @"crypto/x509/pkix".AttributeTypeAndValue struct { Type @"encoding/asn1".ObjectIdentifier; Value interface {} }
	type @"crypto/x509/pkix".RelativeDistinguishedNameSET []@"crypto/x509/pkix".AttributeTypeAndValue
	type @"crypto/x509/pkix".RDNSequence []@"crypto/x509/pkix".RelativeDistinguishedNameSET
	type @"crypto/x509/pkix".Name struct { Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []@"crypto/x509/pkix".AttributeTypeAndValue; ExtraNames []@"crypto/x509/pkix".AttributeTypeAndValue }
	func (@"crypto/x509/pkix".n·1 *@"crypto/x509/pkix".Name "esc:0x9") FillFromRDNSequence (@"crypto/x509/pkix".rdns·2 *@"crypto/x509/pkix".RDNSequence "esc:0x9")
	func (@"crypto/x509/pkix".n·2 @"crypto/x509/pkix".Name) ToRDNSequence () (@"crypto/x509/pkix".ret·1 @"crypto/x509/pkix".RDNSequence)
	func (@"crypto/x509/pkix".n·2 @"crypto/x509/pkix".Name "esc:0x1") @"crypto/x509/pkix".appendRDNs (@"crypto/x509/pkix".in·3 @"crypto/x509/pkix".RDNSequence "esc:0x1a", @"crypto/x509/pkix".values·4 []string "esc:0x9", @"crypto/x509/pkix".oid·5 @"encoding/asn1".ObjectIdentifier) (? @"crypto/x509/pkix".RDNSequence)
	type @"crypto/x509".KeyUsage int
	type @"crypto/x509/pkix".Extension struct { Id @"encoding/asn1".ObjectIdentifier; Critical bool "asn1:\"optional\""; Value []byte }
	type @"crypto/x509".ExtKeyUsage int
	type @"encoding/asn1".RawContent []byte
	type @"encoding/asn1".RawValue struct { Class int; Tag int; IsCompound bool; Bytes []byte; FullBytes []byte }
	type @"crypto/x509/pkix".AlgorithmIdentifier struct { Algorithm @"encoding/asn1".ObjectIdentifier; Parameters @"encoding/asn1".RawValue "asn1:\"optional\"" }
	type @"crypto/x509/pkix".RevokedCertificate struct { SerialNumber *@"math/big".Int; RevocationTime @"time".Time; Extensions []@"crypto/x509/pkix".Extension "asn1:\"optional\"" }
	type @"crypto/x509/pkix".TBSCertificateList struct { Raw @"encoding/asn1".RawContent; Version int "asn1:\"optional,default:1\""; Signature @"crypto/x509/pkix".AlgorithmIdentifier; Issuer @"crypto/x509/pkix".RDNSequence; ThisUpdate @"time".Time; NextUpdate @"time".Time "asn1:\"optional\""; RevokedCertificates []@"crypto/x509/pkix".RevokedCertificate "asn1:\"optional\""; Extensions []@"crypto/x509/pkix".Extension "asn1:\"tag:0,optional,explicit\"" }
	type @"encoding/asn1".BitString struct { Bytes []byte; BitLength int }
	func (@"encoding/asn1".b·2 @"encoding/asn1".BitString "esc:0x1") At (@"encoding/asn1".i·3 int) (? int) { if @"encoding/asn1".i·3 < 0x0 || @"encoding/asn1".i·3 >= @"encoding/asn1".b·2.BitLength { return 0x0 }; var @"encoding/asn1".x·4 int; ; @"encoding/asn1".x·4 = @"encoding/asn1".i·3 / 0x8; var @"encoding/asn1".y·5 uint; ; @"encoding/asn1".y·5 = 0x7 - uint(@"encoding/asn1".i·3 % 0x8); return int(@"encoding/asn1".b·2.Bytes[@"encoding/asn1".x·4] >> @"encoding/asn1".y·5) & 0x1 }
	func (@"encoding/asn1".b·2 @"encoding/asn1".BitString "esc:0x12") RightAlign () (? []byte)
	type @"crypto/x509/pkix".CertificateList struct { TBSCertList @"crypto/x509/pkix".TBSCertificateList; SignatureAlgorithm @"crypto/x509/pkix".AlgorithmIdentifier; SignatureValue @"encoding/asn1".BitString }
	func (@"crypto/x509/pkix".certList·2 *@"crypto/x509/pkix".CertificateList "esc:0x1") HasExpired (@"crypto/x509/pkix".now·3 @"time".Time "esc:0x1") (? bool) { return @"crypto/x509/pkix".now·3.After(@"crypto/x509/pkix".certList·2.TBSCertList.NextUpdate) }
	type @"crypto/x509".CertPool struct { @"crypto/x509".bySubjectKeyId map[string][]int; @"crypto/x509".byName map[string][]int; @"crypto/x509".certs []*@"crypto/x509".Certificate }
	func (@"crypto/x509".s·1 *@"crypto/x509".CertPool "esc:0x9") AddCert (@"crypto/x509".cert·2 *@"crypto/x509".Certificate)
	func (@"crypto/x509".s·2 *@"crypto/x509".CertPool "esc:0x9") AppendCertsFromPEM (@"crypto/x509".pemCerts·3 []byte) (@"crypto/x509".ok·1 bool)
	func (@"crypto/x509".s·2 *@"crypto/x509".CertPool "esc:0x9") Subjects () (@"crypto/x509".res·1 [][]byte)
	func (@"crypto/x509".s·4 *@"crypto/x509".CertPool "esc:0x18a") @"crypto/x509".findVerifiedParents (@"crypto/x509".cert·5 *@"crypto/x509".Certificate "esc:0x9") (@"crypto/x509".parents·1 []int, @"crypto/x509".errCert·2 *@"crypto/x509".Certificate, @"crypto/x509".err·3 error)
	type @"crypto/x509".VerifyOptions struct { DNSName string; Intermediates *@"crypto/x509".CertPool; Roots *@"crypto/x509".CertPool; CurrentTime @"time".Time; KeyUsages []@"crypto/x509".ExtKeyUsage }
	type @"crypto/x509".Certificate struct { Raw []byte; RawTBSCertificate []byte; RawSubjectPublicKeyInfo []byte; RawSubject []byte; RawIssuer []byte; Signature []byte; SignatureAlgorithm @"crypto/x509".SignatureAlgorithm; PublicKeyAlgorithm @"crypto/x509".PublicKeyAlgorithm; PublicKey interface {}; Version int; SerialNumber *@"math/big".Int; Issuer @"crypto/x509/pkix".Name; Subject @"crypto/x509/pkix".Name; NotBefore @"time".Time; NotAfter @"time".Time; KeyUsage @"crypto/x509".KeyUsage; Extensions []@"crypto/x509/pkix".Extension; ExtraExtensions []@"crypto/x509/pkix".Extension; UnhandledCriticalExtensions []@"encoding/asn1".ObjectIdentifier; ExtKeyUsage []@"crypto/x509".ExtKeyUsage; UnknownExtKeyUsage []@"encoding/asn1".ObjectIdentifier; BasicConstraintsValid bool; IsCA bool; MaxPathLen int; MaxPathLenZero bool; SubjectKeyId []byte; AuthorityKeyId []byte; OCSPServer []string; IssuingCertificateURL []string; DNSNames []string; EmailAddresses []string; IPAddresses []@"net".IP; PermittedDNSDomainsCritical bool; PermittedDNSDomains []string; CRLDistributionPoints []string; PolicyIdentifiers []@"encoding/asn1".ObjectIdentifier }
	func (@"crypto/x509".c·2 *@"crypto/x509".Certificate "esc:0x9") CheckCRLSignature (@"crypto/x509".crl·3 *@"crypto/x509/pkix".CertificateList "esc:0x9") (@"crypto/x509".err·1 error)
	func (@"crypto/x509".c·2 *@"crypto/x509".Certificate "esc:0x9") CheckSignature (@"crypto/x509".algo·3 @"crypto/x509".SignatureAlgorithm, @"crypto/x509".signed·4 []byte, @"crypto/x509".signature·5 []byte) (@"crypto/x509".err·1 error)
	func (@"crypto/x509".c·2 *@"crypto/x509".Certificate "esc:0x9") CheckSignatureFrom (@"crypto/x509".parent·3 *@"crypto/x509".Certificate "esc:0x9") (@"crypto/x509".err·1 error)
	func (@"crypto/x509".c·3 *@"crypto/x509".Certificate "esc:0x9") CreateCRL (@"crypto/x509".rand·4 @"io".Reader, @"crypto/x509".priv·5 interface {}, @"crypto/x509".revokedCerts·6 []@"crypto/x509/pkix".RevokedCertificate, @"crypto/x509".now·7 @"time".Time, @"crypto/x509".expiry·8 @"time".Time) (@"crypto/x509".crlBytes·1 []byte, @"crypto/x509".err·2 error)
	func (@"crypto/x509".c·2 *@"crypto/x509".Certificate "esc:0x1") Equal (@"crypto/x509".other·3 *@"crypto/x509".Certificate "esc:0x1") (? bool)
	func (@"crypto/x509".c·3 *@"crypto/x509".Certificate) Verify (@"crypto/x509".opts·4 @"crypto/x509".VerifyOptions) (@"crypto/x509".chains·1 [][]*@"crypto/x509".Certificate, @"crypto/x509".err·2 error)
	func (@"crypto/x509".c·2 *@"crypto/x509".Certificate "esc:0x1a") VerifyHostname (@"crypto/x509".h·3 string) (? error)
	func (@"crypto/x509".c·3 *@"crypto/x509".Certificate) @"crypto/x509".buildChains (@"crypto/x509".cache·4 map[int][][]*@"crypto/x509".Certificate "esc:0x1", @"crypto/x509".currentChain·5 []*@"crypto/x509".Certificate "esc:0x9", @"crypto/x509".opts·6 *@"crypto/x509".VerifyOptions "esc:0x20a") (@"crypto/x509".chains·1 [][]*@"crypto/x509".Certificate, @"crypto/x509".err·2 error)
	func (@"crypto/x509".c·2 *@"crypto/x509".Certificate "esc:0x12") @"crypto/x509".isValid (@"crypto/x509".certType·3 int, @"crypto/x509".currentChain·4 []*@"crypto/x509".Certificate "esc:0x1", @"crypto/x509".opts·5 *@"crypto/x509".VerifyOptions "esc:0x1") (? error)
	func (@"crypto/x509".c·3 *@"crypto/x509".Certificate "esc:0x1") @"crypto/x509".systemVerify (@"crypto/x509".opts·4 *@"crypto/x509".VerifyOptions "esc:0x1") (@"crypto/x509".chains·1 [][]*@"crypto/x509".Certificate, @"crypto/x509".err·2 error) { return nil, nil }
	type @"crypto/tls".ConnectionState struct { Version uint16; HandshakeComplete bool; DidResume bool; CipherSuite uint16; NegotiatedProtocol string; NegotiatedProtocolIsMutual bool; ServerName string; PeerCertificates []*@"crypto/x509".Certificate; VerifiedChains [][]*@"crypto/x509".Certificate; SignedCertificateTimestamps [][]byte; OCSPResponse []byte; TLSUnique []byte }
	import bufio "bufio" // indirect
	type @"bufio".Reader struct { @"bufio".buf []byte; @"bufio".rd @"io".Reader; @"bufio".r int; @"bufio".w int; @"bufio".err error; @"bufio".lastByte int; @"bufio".lastRuneSize int }
	func (@"bufio".b·2 *@"bufio".Reader "esc:0x1") Buffered () (? int) { return @"bufio".b·2.@"bufio".w - @"bufio".b·2.@"bufio".r }
	func (@"bufio".b·3 *@"bufio".Reader "esc:0x10a") Discard (@"bufio".n·4 int) (@"bufio".discarded·1 int, @"bufio".err·2 error)
	func (@"bufio".b·3 *@"bufio".Reader "esc:0x12a") Peek (@"bufio".n·4 int) (? []byte, ? error)
	func (@"bufio".b·3 *@"bufio".Reader "esc:0x10a") Read (@"bufio".p·4 []byte) (@"bufio".n·1 int, @"bufio".err·2 error)
	func (@"bufio".b·3 *@"bufio".Reader "esc:0x10a") ReadByte () (@"bufio".c·1 byte, @"bufio".err·2 error)
	func (@"bufio".b·3 *@"bufio".Reader "esc:0x10a") ReadBytes (@"bufio".delim·4 byte) (@"bufio".line·1 []byte, @"bufio".err·2 error)
	func (@"bufio".b·4 *@"bufio".Reader "esc:0x82a") ReadLine () (@"bufio".line·1 []byte, @"bufio".isPrefix·2 bool, @"bufio".err·3 error)
	func (@"bufio".b·4 *@"bufio".Reader "esc:0x80a") ReadRune () (@"bufio".r·1 rune, @"bufio".size·2 int, @"bufio".err·3 error)
	func (@"bufio".b·3 *@"bufio".Reader "esc:0x12a") ReadSlice (@"bufio".delim·4 byte) (@"bufio".line·1 []byte, @"bufio".err·2 error)
	func (@"bufio".b·3 *@"bufio".Reader "esc:0x10a") ReadString (@"bufio".delim·4 byte) (@"bufio".line·1 string, @"bufio".err·2 error)
	func (@"bufio".b·1 *@"bufio".Reader "esc:0x9") Reset (@"bufio".r·2 @"io".Reader) { @"bufio".b·1.@"bufio".reset(@"bufio".b·1.@"bufio".buf, @"bufio".r·2) }
	func (@"bufio".b·2 *@"bufio".Reader "esc:0x1") UnreadByte () (? error) { if @"bufio".b·2.@"bufio".lastByte < 0x0 || @"bufio".b·2.@"bufio".r == 0x0 && @"bufio".b·2.@"bufio".w > 0x0 { return @"bufio".ErrInvalidUnreadByte }; if @"bufio".b·2.@"bufio".r > 0x0 { @"bufio".b·2.@"bufio".r-- } else { @"bufio".b·2.@"bufio".w = 0x1 }; @"bufio".b·2.@"bufio".buf[@"bufio".b·2.@"bufio".r] = byte(@"bufio".b·2.@"bufio".lastByte); @"bufio".b·2.@"bufio".lastByte = -0x1; @"bufio".b·2.@"bufio".lastRuneSize = -0x1; return nil }
	func (@"bufio".b·2 *@"bufio".Reader "esc:0x1") UnreadRune () (? error) { if @"bufio".b·2.@"bufio".lastRuneSize < 0x0 || @"bufio".b·2.@"bufio".r < @"bufio".b·2.@"bufio".lastRuneSize { return @"bufio".ErrInvalidUnreadRune }; @"bufio".b·2.@"bufio".r -= @"bufio".b·2.@"bufio".lastRuneSize; @"bufio".b·2.@"bufio".lastByte = -0x1; @"bufio".b·2.@"bufio".lastRuneSize = -0x1; return nil }
	func (@"bufio".b·3 *@"bufio".Reader "esc:0x10a") WriteTo (@"bufio".w·4 @"io".Writer) (@"bufio".n·1 int64, @"bufio".err·2 error)
	func (@"bufio".b·1 *@"bufio".Reader "esc:0x9") @"bufio".fill ()
	func (@"bufio".b·2 *@"bufio".Reader "esc:0x22") @"bufio".readErr () (? error) { var @"bufio".err·3 error; ; @"bufio".err·3 = @"bufio".b·2.@"bufio".err; @"bufio".b·2.@"bufio".err = nil; return @"bufio".err·3 }
	func (@"bufio".b·1 *@"bufio".Reader "esc:0x1") @"bufio".reset (@"bufio".buf·2 []byte, @"bufio".r·3 @"io".Reader) { *@"bufio".b·1 = (@"bufio".Reader{ @"bufio".buf:@"bufio".buf·2, @"bufio".rd:@"bufio".r·3, @"bufio".lastByte:-0x1, @"bufio".lastRuneSize:-0x1 }) }
	func (@"bufio".b·3 *@"bufio".Reader "esc:0x9") @"bufio".writeBuf (@"bufio".w·4 @"io".Writer) (? int64, ? error)
	type @"bufio".Writer struct { @"bufio".err error; @"bufio".buf []byte; @"bufio".n int; @"bufio".wr @"io".Writer }
	func (@"bufio".b·2 *@"bufio".Writer "esc:0x1") Available () (? int) { return len(@"bufio".b·2.@"bufio".buf) - @"bufio".b·2.@"bufio".n }
	func (@"bufio".b·2 *@"bufio".Writer "esc:0x1") Buffered () (? int) { return @"bufio".b·2.@"bufio".n }
	func (@"bufio".b·2 *@"bufio".Writer "esc:0x2a") Flush () (? error)
	func (@"bufio".b·3 *@"bufio".Writer "esc:0x10a") ReadFrom (@"bufio".r·4 @"io".Reader) (@"bufio".n·1 int64, @"bufio".err·2 error)
	func (@"bufio".b·1 *@"bufio".Writer "esc:0x1") Reset (@"bufio".w·2 @"io".Writer) { @"bufio".b·1.@"bufio".err = nil; @"bufio".b·1.@"bufio".n = 0x0; @"bufio".b·1.@"bufio".wr = @"bufio".w·2 }
	func (@"bufio".b·3 *@"bufio".Writer "esc:0x10a") Write (@"bufio".p·4 []byte) (@"bufio".nn·1 int, @"bufio".err·2 error)
	func (@"bufio".b·2 *@"bufio".Writer "esc:0x2a") WriteByte (@"bufio".c·3 byte) (? error)
	func (@"bufio".b·3 *@"bufio".Writer "esc:0x10a") WriteRune (@"bufio".r·4 rune) (@"bufio".size·1 int, @"bufio".err·2 error)
	func (@"bufio".b·3 *@"bufio".Writer "esc:0x10a") WriteString (@"bufio".s·4 string "esc:0x9") (? int, ? error)
	func (@"bufio".b·2 *@"bufio".Writer "esc:0x2a") @"bufio".flush () (? error)
	import url "net/url" // indirect
	type @"net/url".Userinfo struct { @"net/url".username string; @"net/url".password string; @"net/url".passwordSet bool }
	func (@"net/url".u·3 *@"net/url".Userinfo "esc:0x22") Password () (? string, ? bool) { if @"net/url".u·3.@"net/url".passwordSet { return @"net/url".u·3.@"net/url".password, true }; return "", false }
	func (@"net/url".u·2 *@"net/url".Userinfo "esc:0x22") String () (? string)
	func (@"net/url".u·2 *@"net/url".Userinfo "esc:0x22") Username () (? string) { return @"net/url".u·2.@"net/url".username }
	type @"net/url".Values map[string][]string
	func (@"net/url".v·1 @"net/url".Values "esc:0x9") Add (@"net/url".key·2 string, @"net/url".value·3 string) { @"net/url".v·1[@"net/url".key·2] = append(@"net/url".v·1[@"net/url".key·2], @"net/url".value·3) }
	func (@"net/url".v·1 @"net/url".Values "esc:0x1") Del (@"net/url".key·2 string "esc:0x1") { delete(@"net/url".v·1, @"net/url".key·2) }
	func (@"net/url".v·2 @"net/url".Values "esc:0x1") Encode () (? string)
	func (@"net/url".v·2 @"net/url".Values "esc:0x1") Get (@"net/url".key·3 string "esc:0x1") (? string) { if @"net/url".v·2 == nil { return "" }; var @"net/url".vs·4 []string; ; var @"net/url".ok·5 bool; ; @"net/url".vs·4, @"net/url".ok·5 = @"net/url".v·2[@"net/url".key·3]; if !@"net/url".ok·5 || len(@"net/url".vs·4) == 0x0 { return "" }; return @"net/url".vs·4[0x0] }
	func (@"net/url".v·1 @"net/url".Values "esc:0x1") Set (@"net/url".key·2 string, @"net/url".value·3 string) { @"net/url".v·1[@"net/url".key·2] = ([]string{ 0x0:@"net/url".value·3 }) }
	type @"net/url".URL struct { Scheme string; Opaque string; User *@"net/url".Userinfo; Host string; Path string; RawPath string; RawQuery string; Fragment string }
	func (@"net/url".u·2 *@"net/url".URL "esc:0x22") EscapedPath () (? string)
	func (@"net/url".u·2 *@"net/url".URL "esc:0x1") IsAbs () (? bool) { return @"net/url".u·2.Scheme != "" }
	func (@"net/url".u·3 *@"net/url".URL "esc:0x9") Parse (@"net/url".ref·4 string) (? *@"net/url".URL, ? error)
	func (@"net/url".u·2 *@"net/url".URL "esc:0x9") Query () (? @"net/url".Values)
	func (@"net/url".u·2 *@"net/url".URL "esc:0x22") RequestURI () (? string)
	func (@"net/url".u·2 *@"net/url".URL "esc:0xa") ResolveReference (@"net/url".ref·3 *@"net/url".URL "esc:0xa") (? *@"net/url".URL)
	func (@"net/url".u·2 *@"net/url".URL "esc:0x9") String () (? string)
	type @"net/http".keyValues struct { @"net/http".key string; @"net/http".values []string }
	type @"net/http".headerSorter struct { @"net/http".kvs []@"net/http".keyValues }
	func (@"net/http".s·2 *@"net/http".headerSorter "esc:0x1") Len () (? int) { return len(@"net/http".s·2.@"net/http".kvs) }
	func (@"net/http".s·2 *@"net/http".headerSorter "esc:0x1") Less (@"net/http".i·3 int, @"net/http".j·4 int) (? bool) { return @"net/http".s·2.@"net/http".kvs[@"net/http".i·3].@"net/http".key < @"net/http".s·2.@"net/http".kvs[@"net/http".j·4].@"net/http".key }
	func (@"net/http".s·1 *@"net/http".headerSorter "esc:0x9") Swap (@"net/http".i·2 int, @"net/http".j·3 int) { @"net/http".s·1.@"net/http".kvs[@"net/http".i·2], @"net/http".s·1.@"net/http".kvs[@"net/http".j·3] = @"net/http".s·1.@"net/http".kvs[@"net/http".j·3], @"net/http".s·1.@"net/http".kvs[@"net/http".i·2] }
	type @"net/http".Header map[string][]string
	func (@"net/http".h·1 @"net/http".Header "esc:0x9") Add (@"net/http".key·2 string, @"net/http".value·3 string)
	func (@"net/http".h·1 @"net/http".Header "esc:0x1") Del (@"net/http".key·2 string "esc:0x1")
	func (@"net/http".h·2 @"net/http".Header "esc:0x1") Get (@"net/http".key·3 string "esc:0x1") (? string)
	func (@"net/http".h·1 @"net/http".Header "esc:0x1") Set (@"net/http".key·2 string, @"net/http".value·3 string)
	func (@"net/http".h·2 @"net/http".Header "esc:0x9") Write (@"net/http".w·3 @"io".Writer) (? error)
	func (@"net/http".h·2 @"net/http".Header "esc:0x9") WriteSubset (@"net/http".w·3 @"io".Writer, @"net/http".exclude·4 map[string]bool "esc:0x1") (? error)
	func (@"net/http".h·2 @"net/http".Header "esc:0x9") @"net/http".clone () (? @"net/http".Header)
	func (@"net/http".h·2 @"net/http".Header "esc:0x1") @"net/http".get (@"net/http".key·3 string "esc:0x1") (? string) { var @"net/http".v·4 []string; ; @"net/http".v·4 = @"net/http".h·2[@"net/http".key·3]; if len(@"net/http".v·4) > 0x0 { return @"net/http".v·4[0x0] }; return "" }
	func (@"net/http".h·3 @"net/http".Header "esc:0x9") @"net/http".sortedKeyValues (@"net/http".exclude·4 map[string]bool "esc:0x1") (@"net/http".kvs·1 []@"net/http".keyValues, @"net/http".hs·2 *@"net/http".headerSorter)
	type @"io".ReadCloser interface { Close() (? error); Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	import multipart "mime/multipart" // indirect
	import textproto "net/textproto" // indirect
	type @"net/textproto".MIMEHeader map[string][]string
	func (@"net/textproto".h·1 @"net/textproto".MIMEHeader "esc:0x9") Add (@"net/textproto".key·2 string, @"net/textproto".value·3 string)
	func (@"net/textproto".h·1 @"net/textproto".MIMEHeader "esc:0x1") Del (@"net/textproto".key·2 string "esc:0x1")
	func (@"net/textproto".h·2 @"net/textproto".MIMEHeader "esc:0x1") Get (@"net/textproto".key·3 string "esc:0x1") (? string)
	func (@"net/textproto".h·1 @"net/textproto".MIMEHeader "esc:0x1") Set (@"net/textproto".key·2 string, @"net/textproto".value·3 string)
	type @"mime/multipart".File interface { Close() (? error); Read(@"io".p []byte) (@"io".n int, @"io".err error); ReadAt(@"io".p []byte, @"io".off int64) (@"io".n int, @"io".err error); Seek(@"io".offset int64, @"io".whence int) (? int64, ? error) }
	type @"mime/multipart".FileHeader struct { Filename string; Header @"net/textproto".MIMEHeader; @"mime/multipart".content []byte; @"mime/multipart".tmpfile string }
	func (@"mime/multipart".fh·3 *@"mime/multipart".FileHeader) Open () (? @"mime/multipart".File, ? error)
	type @"mime/multipart".Form struct { Value map[string][]string; File map[string][]*@"mime/multipart".FileHeader }
	func (@"mime/multipart".f·2 *@"mime/multipart".Form "esc:0x9") RemoveAll () (? error)
	type @"net/http".Cookie struct { Name string; Value string; Path string; Domain string; Expires @"time".Time; RawExpires string; MaxAge int; Secure bool; HttpOnly bool; Raw string; Unparsed []string }
	func (@"net/http".c·2 *@"net/http".Cookie "esc:0x9") String () (? string)
	type @"mime/multipart".Part struct { Header @"net/textproto".MIMEHeader; @"mime/multipart".buffer *@"bytes".Buffer; @"mime/multipart".mr *@"mime/multipart".Reader; @"mime/multipart".bytesRead int; @"mime/multipart".disposition string; @"mime/multipart".dispositionParams map[string]string; @"mime/multipart".r @"io".Reader }
	func (@"mime/multipart".p·2 *@"mime/multipart".Part) Close () (? error)
	func (@"mime/multipart".p·2 *@"mime/multipart".Part "esc:0x1") FileName () (? string)
	func (@"mime/multipart".p·2 *@"mime/multipart".Part "esc:0x1") FormName () (? string)
	func (@"mime/multipart".p·3 *@"mime/multipart".Part "esc:0x9") Read (@"mime/multipart".d·4 []byte) (@"mime/multipart".n·1 int, @"mime/multipart".err·2 error)
	func (@"mime/multipart".p·1 *@"mime/multipart".Part "esc:0x1") @"mime/multipart".parseContentDisposition ()
	func (@"mime/multipart".bp·2 *@"mime/multipart".Part "esc:0x4a") @"mime/multipart".populateHeaders () (? error)
	type @"mime/multipart".Reader struct { @"mime/multipart".bufReader *@"bufio".Reader; @"mime/multipart".currentPart *@"mime/multipart".Part; @"mime/multipart".partsRead int; @"mime/multipart".nl []byte; @"mime/multipart".nlDashBoundary []byte; @"mime/multipart".dashBoundaryDash []byte; @"mime/multipart".dashBoundary []byte }
	func (@"mime/multipart".r·3 *@"mime/multipart".Reader) NextPart () (? *@"mime/multipart".Part, ? error)
	func (@"mime/multipart".r·3 *@"mime/multipart".Reader) ReadForm (@"mime/multipart".maxMemory·4 int64) (@"mime/multipart".f·1 *@"mime/multipart".Form, @"mime/multipart".err·2 error)
	func (@"mime/multipart".mr·2 *@"mime/multipart".Reader "esc:0x1") @"mime/multipart".isBoundaryDelimiterLine (@"mime/multipart".line·3 []byte "esc:0x1") (@"mime/multipart".ret·1 bool)
	func (@"mime/multipart".mr·2 *@"mime/multipart".Reader "esc:0x1") @"mime/multipart".isFinalBoundary (@"mime/multipart".line·3 []byte "esc:0x1") (? bool)
	func (@"mime/multipart".mr·2 *@"mime/multipart".Reader "esc:0x1") @"mime/multipart".peekBufferIsEmptyPart (@"mime/multipart".peek·3 []byte "esc:0x1") (? bool)
	func (@"mime/multipart".mr·3 *@"mime/multipart".Reader "esc:0x1") @"mime/multipart".peekBufferSeparatorIndex (@"mime/multipart".peek·4 []byte "esc:0x1") (@"mime/multipart".idx·1 int, @"mime/multipart".isEnd·2 bool)
	type @"net/http".Request struct { Method string; URL *@"net/url".URL; Proto string; ProtoMajor int; ProtoMinor int; Header @"net/http".Header; Body @"io".ReadCloser; ContentLength int64; TransferEncoding []string; Close bool; Host string; Form @"net/url".Values; PostForm @"net/url".Values; MultipartForm *@"mime/multipart".Form; Trailer @"net/http".Header; RemoteAddr string; RequestURI string; TLS *@"crypto/tls".ConnectionState; Cancel <-chan struct {} }
	func (@"net/http".r·1 *@"net/http".Request "esc:0x1") AddCookie (@"net/http".c·2 *@"net/http".Cookie "esc:0x9")
	func (@"net/http".r·4 *@"net/http".Request "esc:0x1") BasicAuth () (@"net/http".username·1 string, @"net/http".password·2 string, @"net/http".ok·3 bool)
	func (@"net/http".r·3 *@"net/http".Request "esc:0x1") Cookie (@"net/http".name·4 string "esc:0x1") (? *@"net/http".Cookie, ? error)
	func (@"net/http".r·2 *@"net/http".Request "esc:0x1") Cookies () (? []*@"net/http".Cookie)
	func (@"net/http".r·4 *@"net/http".Request "esc:0x9") FormFile (@"net/http".key·5 string "esc:0x1") (? @"mime/multipart".File, ? *@"mime/multipart".FileHeader, ? error)
	func (@"net/http".r·2 *@"net/http".Request "esc:0x9") FormValue (@"net/http".key·3 string "esc:0x1") (? string)
	func (@"net/http".r·3 *@"net/http".Request "esc:0x9") MultipartReader () (? *@"mime/multipart".Reader, ? error)
	func (@"net/http".r·2 *@"net/http".Request "esc:0x9") ParseForm () (? error)
	func (@"net/http".r·2 *@"net/http".Request "esc:0x9") ParseMultipartForm (@"net/http".maxMemory·3 int64) (? error)
	func (@"net/http".r·2 *@"net/http".Request "esc:0x9") PostFormValue (@"net/http".key·3 string "esc:0x1") (? string)
	func (@"net/http".r·2 *@"net/http".Request "esc:0x1") ProtoAtLeast (@"net/http".major·3 int, @"net/http".minor·4 int) (? bool) { return @"net/http".r·2.ProtoMajor > @"net/http".major·3 || @"net/http".r·2.ProtoMajor == @"net/http".major·3 && @"net/http".r·2.ProtoMinor >= @"net/http".minor·4 }
	func (@"net/http".r·2 *@"net/http".Request "esc:0x1") Referer () (? string)
	func (@"net/http".r·1 *@"net/http".Request "esc:0x1") SetBasicAuth (@"net/http".username·2 string "esc:0x1", @"net/http".password·3 string "esc:0x1")
	func (@"net/http".r·2 *@"net/http".Request "esc:0x1") UserAgent () (? string)
	func (@"net/http".r·2 *@"net/http".Request "esc:0x9") Write (@"net/http".w·3 @"io".Writer) (? error)
	func (@"net/http".r·2 *@"net/http".Request "esc:0x9") WriteProxy (@"net/http".w·3 @"io".Writer) (? error)
	func (@"net/http".r·1 *@"net/http".Request "esc:0x9") @"net/http".closeBody ()
	func (@"net/http".r·2 *@"net/http".Request "esc:0x1") @"net/http".expectsContinue () (? bool)
	func (@"net/http".r·3 *@"net/http".Request "esc:0xa") @"net/http".multipartReader () (? *@"mime/multipart".Reader, ? error)
	func (@"net/http".r·2 *@"net/http".Request "esc:0x1") @"net/http".wantsClose () (? bool)
	func (@"net/http".r·2 *@"net/http".Request "esc:0x1") @"net/http".wantsHttp10KeepAlive () (? bool)
	func (@"net/http".req·2 *@"net/http".Request "esc:0x9") @"net/http".write (@"net/http".w·3 @"io".Writer, @"net/http".usingProxy·4 bool, @"net/http".extraHeaders·5 @"net/http".Header "esc:0x9") (? error)
	type @"net/http".Response struct { Status string; StatusCode int; Proto string; ProtoMajor int; ProtoMinor int; Header @"net/http".Header; Body @"io".ReadCloser; ContentLength int64; TransferEncoding []string; Close bool; Trailer @"net/http".Header; Request *@"net/http".Request; TLS *@"crypto/tls".ConnectionState }
	func (@"net/http".r·2 *@"net/http".Response "esc:0x9") Cookies () (? []*@"net/http".Cookie)
	func (@"net/http".r·3 *@"net/http".Response "esc:0x9") Location () (? *@"net/url".URL, ? error)
	func (@"net/http".r·2 *@"net/http".Response "esc:0x1") ProtoAtLeast (@"net/http".major·3 int, @"net/http".minor·4 int) (? bool) { return @"net/http".r·2.ProtoMajor > @"net/http".major·3 || @"net/http".r·2.ProtoMajor == @"net/http".major·3 && @"net/http".r·2.ProtoMinor >= @"net/http".minor·4 }
	func (@"net/http".r·2 *@"net/http".Response "esc:0x9") Write (@"net/http".w·3 @"io".Writer) (? error)
	type @"net/http".responseAndError struct { @"net/http".res *@"net/http".Response; @"net/http".err error }
	type @"net/http".requestAndChan struct { @"net/http".req *@"net/http".Request; @"net/http".ch chan @"net/http".responseAndError; @"net/http".addedGzip bool }
	type @"net/http".transportRequest struct { ? *@"net/http".Request; @"net/http".extra @"net/http".Header }
	func (@"net/http".tr·2 *@"net/http".transportRequest "esc:0x22") @"net/http".extraHeaders () (? @"net/http".Header) { if @"net/http".tr·2.@"net/http".extra == nil { @"net/http".tr·2.@"net/http".extra = make(@"net/http".Header) }; return @"net/http".tr·2.@"net/http".extra }
	type @"net/http".writeRequest struct { @"net/http".req *@"net/http".transportRequest; @"net/http".ch chan<- error }
	type @"net/http".persistConn struct { @"net/http".t *@"net/http".Transport; @"net/http".cacheKey @"net/http".connectMethodKey; @"net/http".conn @"net".Conn; @"net/http".tlsState *@"crypto/tls".ConnectionState; @"net/http".br *@"bufio".Reader; @"net/http".sawEOF bool; @"net/http".bw *@"bufio".Writer; @"net/http".reqch chan @"net/http".requestAndChan; @"net/http".writech chan @"net/http".writeRequest; @"net/http".closech chan struct {}; @"net/http".isProxy bool; @"net/http".writeErrCh chan error; @"net/http".lk @"sync".Mutex; @"net/http".numExpectedResponses int; @"net/http".closed bool; @"net/http".broken bool; @"net/http".canceled bool; @"net/http".mutateHeaderFunc func(? @"net/http".Header) }
	func (@"net/http".pc·1 *@"net/http".persistConn) @"net/http".cancelRequest ()
	func (@"net/http".pc·1 *@"net/http".persistConn) @"net/http".close ()
	func (@"net/http".pc·1 *@"net/http".persistConn "esc:0x9") @"net/http".closeLocked ()
	func (@"net/http".pc·2 *@"net/http".persistConn) @"net/http".isBroken () (? bool)
	func (@"net/http".pc·2 *@"net/http".persistConn) @"net/http".isCanceled () (? bool)
	func (@"net/http".pc·1 *@"net/http".persistConn) @"net/http".markBroken ()
	func (@"net/http".pc·1 *@"net/http".persistConn) @"net/http".readLoop ()
	func (@"net/http".pc·3 *@"net/http".persistConn) @"net/http".roundTrip (@"net/http".req·4 *@"net/http".transportRequest) (@"net/http".resp·1 *@"net/http".Response, @"net/http".err·2 error)
	func (@"net/http".pc·1 *@"net/http".persistConn) @"net/http".writeLoop ()
	func (@"net/http".pc·2 *@"net/http".persistConn "esc:0x1") @"net/http".wroteRequest () (? bool)
	type @"net/http".RoundTripper interface { RoundTrip(? *@"net/http".Request) (? *@"net/http".Response, ? error) }
	type @"crypto".PrivateKey interface {}
	type @"crypto/tls".Certificate struct { Certificate [][]byte; PrivateKey @"crypto".PrivateKey; OCSPStaple []byte; SignedCertificateTimestamps [][]byte; Leaf *@"crypto/x509".Certificate }
	type @"crypto/tls".CurveID uint16
	type @"crypto/tls".ClientHelloInfo struct { CipherSuites []uint16; ServerName string; SupportedCurves []@"crypto/tls".CurveID; SupportedPoints []uint8 }
	type @"crypto/tls".ClientAuthType int
	type @"crypto/tls".ClientSessionState struct { @"crypto/tls".sessionTicket []uint8; @"crypto/tls".vers uint16; @"crypto/tls".cipherSuite uint16; @"crypto/tls".masterSecret []byte; @"crypto/tls".serverCertificates []*@"crypto/x509".Certificate; @"crypto/tls".verifiedChains [][]*@"crypto/x509".Certificate }
	type @"crypto/tls".ClientSessionCache interface { Get(@"crypto/tls".sessionKey string) (@"crypto/tls".session *@"crypto/tls".ClientSessionState, @"crypto/tls".ok bool); Put(@"crypto/tls".sessionKey string, @"crypto/tls".cs *@"crypto/tls".ClientSessionState) }
	type @"crypto/tls".ticketKey struct { @"crypto/tls".keyName [16]byte; @"crypto/tls".aesKey [16]byte; @"crypto/tls".hmacKey [16]byte }
	type @"crypto/tls".Config struct { Rand @"io".Reader; Time func() (? @"time".Time); Certificates []@"crypto/tls".Certificate; NameToCertificate map[string]*@"crypto/tls".Certificate; GetCertificate func(@"crypto/tls".clientHello *@"crypto/tls".ClientHelloInfo) (? *@"crypto/tls".Certificate, ? error); RootCAs *@"crypto/x509".CertPool; NextProtos []string; ServerName string; ClientAuth @"crypto/tls".ClientAuthType; ClientCAs *@"crypto/x509".CertPool; InsecureSkipVerify bool; CipherSuites []uint16; PreferServerCipherSuites bool; SessionTicketsDisabled bool; SessionTicketKey [32]byte; ClientSessionCache @"crypto/tls".ClientSessionCache; MinVersion uint16; MaxVersion uint16; CurvePreferences []@"crypto/tls".CurveID; @"crypto/tls".serverInitOnce @"sync".Once; @"crypto/tls".mutex @"sync".RWMutex; @"crypto/tls".sessionTicketKeys []@"crypto/tls".ticketKey }
	func (@"crypto/tls".c·1 *@"crypto/tls".Config "esc:0x9") BuildNameToCertificate ()
	func (@"crypto/tls".c·1 *@"crypto/tls".Config) SetSessionTicketKeys (@"crypto/tls".keys·2 [][32]byte "esc:0x1")
	func (@"crypto/tls".c·2 *@"crypto/tls".Config "esc:0x22") @"crypto/tls".cipherSuites () (? []uint16)
	func (@"crypto/tls".c·2 *@"crypto/tls".Config "esc:0x22") @"crypto/tls".curvePreferences () (? []@"crypto/tls".CurveID) { if @"crypto/tls".c·2 == nil || len(@"crypto/tls".c·2.CurvePreferences) == 0x0 { return @"crypto/tls".defaultCurvePreferences }; return @"crypto/tls".c·2.CurvePreferences }
	func (@"crypto/tls".c·3 *@"crypto/tls".Config "esc:0x22") @"crypto/tls".getCertificate (@"crypto/tls".clientHello·4 *@"crypto/tls".ClientHelloInfo) (? *@"crypto/tls".Certificate, ? error)
	func (@"crypto/tls".c·2 *@"crypto/tls".Config "esc:0x1") @"crypto/tls".maxVersion () (? uint16) { if @"crypto/tls".c·2 == nil || @"crypto/tls".c·2.MaxVersion == 0x0 { return 0x303 }; return @"crypto/tls".c·2.MaxVersion }
	func (@"crypto/tls".c·2 *@"crypto/tls".Config "esc:0x1") @"crypto/tls".minVersion () (? uint16) { if @"crypto/tls".c·2 == nil || @"crypto/tls".c·2.MinVersion == 0x0 { return 0x301 }; return @"crypto/tls".c·2.MinVersion }
	func (@"crypto/tls".c·3 *@"crypto/tls".Config "esc:0x1") @"crypto/tls".mutualVersion (@"crypto/tls".vers·4 uint16) (? uint16, ? bool) { var @"crypto/tls".minVersion·5 uint16; ; @"crypto/tls".minVersion·5 = @"crypto/tls".c·3.@"crypto/tls".minVersion(); var @"crypto/tls".maxVersion·6 uint16; ; @"crypto/tls".maxVersion·6 = @"crypto/tls".c·3.@"crypto/tls".maxVersion(); if @"crypto/tls".vers·4 < @"crypto/tls".minVersion·5 { return 0x0, false }; if @"crypto/tls".vers·4 > @"crypto/tls".maxVersion·6 { @"crypto/tls".vers·4 = @"crypto/tls".maxVersion·6 }; return @"crypto/tls".vers·4, true }
	func (@"crypto/tls".c·2 *@"crypto/tls".Config "esc:0x22") @"crypto/tls".rand () (? @"io".Reader) { var @"crypto/tls".r·3 @"io".Reader; ; @"crypto/tls".r·3 = @"crypto/tls".c·2.Rand; if @"crypto/tls".r·3 == nil { return @"crypto/rand".Reader }; return @"crypto/tls".r·3 }
	func (@"crypto/tls".c·1 *@"crypto/tls".Config) @"crypto/tls".serverInit ()
	func (@"crypto/tls".c·2 *@"crypto/tls".Config) @"crypto/tls".ticketKeys () (? []@"crypto/tls".ticketKey)
	func (@"crypto/tls".c·2 *@"crypto/tls".Config "esc:0x1") @"crypto/tls".time () (? @"time".Time)
	type @"net/http".connectMethod struct { @"net/http".proxyURL *@"net/url".URL; @"net/http".targetScheme string; @"net/http".targetAddr string }
	func (@"net/http".cm·2 *@"net/http".connectMethod "esc:0x22") @"net/http".addr () (? string)
	func (@"net/http".cm·2 *@"net/http".connectMethod "esc:0x2a") @"net/http".key () (? @"net/http".connectMethodKey)
	func (@"net/http".cm·2 *@"net/http".connectMethod "esc:0x1") @"net/http".proxyAuth () (? string)
	func (@"net/http".cm·2 *@"net/http".connectMethod "esc:0x22") @"net/http".tlsHost () (? string)
	type @"net/http".Transport struct { @"net/http".idleMu @"sync".Mutex; @"net/http".wantIdle bool; @"net/http".idleConn map[@"net/http".connectMethodKey][]*@"net/http".persistConn; @"net/http".idleConnCh map[@"net/http".connectMethodKey]chan *@"net/http".persistConn; @"net/http".reqMu @"sync".Mutex; @"net/http".reqCanceler map[*@"net/http".Request]func(); @"net/http".altMu @"sync".RWMutex; @"net/http".altProto map[string]@"net/http".RoundTripper; Proxy func(? *@"net/http".Request) (? *@"net/url".URL, ? error); Dial func(@"net/http".network string, @"net/http".addr string) (? @"net".Conn, ? error); DialTLS func(@"net/http".network string, @"net/http".addr string) (? @"net".Conn, ? error); TLSClientConfig *@"crypto/tls".Config; TLSHandshakeTimeout @"time".Duration; DisableKeepAlives bool; DisableCompression bool; MaxIdleConnsPerHost int; ResponseHeaderTimeout @"time".Duration }
	func (@"net/http".t·1 *@"net/http".Transport) CancelRequest (@"net/http".req·2 *@"net/http".Request "esc:0x1")
	func (@"net/http".t·1 *@"net/http".Transport) CloseIdleConnections ()
	func (@"net/http".t·1 *@"net/http".Transport) RegisterProtocol (@"net/http".scheme·2 string, @"net/http".rt·3 @"net/http".RoundTripper)
	func (@"net/http".t·3 *@"net/http".Transport) RoundTrip (@"net/http".req·4 *@"net/http".Request) (@"net/http".resp·1 *@"net/http".Response, @"net/http".err·2 error)
	func (@"net/http".t·3 *@"net/http".Transport "esc:0x1") @"net/http".connectMethodForRequest (@"net/http".treq·4 *@"net/http".transportRequest "esc:0x4a") (@"net/http".cm·1 @"net/http".connectMethod, @"net/http".err·2 error)
	func (@"net/http".t·3 *@"net/http".Transport "esc:0x1") @"net/http".dial (@"net/http".network·4 string, @"net/http".addr·5 string) (@"net/http".c·1 @"net".Conn, @"net/http".err·2 error)
	func (@"net/http".t·3 *@"net/http".Transport) @"net/http".dialConn (@"net/http".cm·4 @"net/http".connectMethod) (? *@"net/http".persistConn, ? error)
	func (@"net/http".t·3 *@"net/http".Transport) @"net/http".getConn (@"net/http".req·4 *@"net/http".Request, @"net/http".cm·5 @"net/http".connectMethod) (? *@"net/http".persistConn, ? error)
	func (@"net/http".t·2 *@"net/http".Transport) @"net/http".getIdleConn (@"net/http".cm·3 @"net/http".connectMethod) (@"net/http".pconn·1 *@"net/http".persistConn)
	func (@"net/http".t·2 *@"net/http".Transport) @"net/http".getIdleConnCh (@"net/http".cm·3 @"net/http".connectMethod) (? chan *@"net/http".persistConn)
	func (@"net/http".t·2 *@"net/http".Transport) @"net/http".putIdleConn (@"net/http".pconn·3 *@"net/http".persistConn) (? bool)
	func (@"net/http".t·2 *@"net/http".Transport) @"net/http".replaceReqCanceler (@"net/http".r·3 *@"net/http".Request, @"net/http".fn·4 func()) (? bool)
	func (@"net/http".t·1 *@"net/http".Transport) @"net/http".setReqCanceler (@"net/http".r·2 *@"net/http".Request, @"net/http".fn·3 func())
	type @"net/http".CookieJar interface { Cookies(@"net/http".u *@"net/url".URL) (? []*@"net/http".Cookie); SetCookies(@"net/http".u *@"net/url".URL, @"net/http".cookies []*@"net/http".Cookie) }
	type @"net/http".Client struct { Transport @"net/http".RoundTripper; CheckRedirect func(@"net/http".req *@"net/http".Request, @"net/http".via []*@"net/http".Request) (? error); Jar @"net/http".CookieJar; Timeout @"time".Duration }
	func (@"net/http".c·3 *@"net/http".Client "esc:0x9") Do (@"net/http".req·4 *@"net/http".Request) (@"net/http".resp·1 *@"net/http".Response, @"net/http".err·2 error)
	func (@"net/http".c·3 *@"net/http".Client "esc:0x9") Get (@"net/http".url·4 string) (@"net/http".resp·1 *@"net/http".Response, @"net/http".err·2 error)
	func (@"net/http".c·3 *@"net/http".Client "esc:0x9") Head (@"net/http".url·4 string) (@"net/http".resp·1 *@"net/http".Response, @"net/http".err·2 error)
	func (@"net/http".c·3 *@"net/http".Client "esc:0x9") Post (@"net/http".url·4 string, @"net/http".bodyType·5 string, @"net/http".body·6 @"io".Reader) (@"net/http".resp·1 *@"net/http".Response, @"net/http".err·2 error)
	func (@"net/http".c·3 *@"net/http".Client "esc:0x9") PostForm (@"net/http".url·4 string, @"net/http".data·5 @"net/url".Values "esc:0x1") (@"net/http".resp·1 *@"net/http".Response, @"net/http".err·2 error)
	func (@"net/http".c·3 *@"net/http".Client "esc:0x9") @"net/http".doFollowingRedirects (@"net/http".ireq·4 *@"net/http".Request, @"net/http".shouldRedirect·5 func(? int) (? bool) "esc:0x1") (@"net/http".resp·1 *@"net/http".Response, @"net/http".err·2 error)
	func (@"net/http".c·3 *@"net/http".Client "esc:0x9") @"net/http".send (@"net/http".req·4 *@"net/http".Request) (? *@"net/http".Response, ? error)
	func (@"net/http".c·2 *@"net/http".Client "esc:0x22") @"net/http".transport () (? @"net/http".RoundTripper) { if @"net/http".c·2.Transport != nil { return @"net/http".c·2.Transport }; return @"net/http".DefaultTransport }
	type @"github.com/ethereum/go-ethereum/common/httpclient".HTTPClient struct { ? *@"net/http".Transport; DocRoot string; @"github.com/ethereum/go-ethereum/common/httpclient".schemes []string }
	func (@"github.com/ethereum/go-ethereum/common/httpclient".self·2 *@"github.com/ethereum/go-ethereum/common/httpclient".HTTPClient) Client () (? *@"net/http".Client) { return (&@"net/http".Client{ Transport:@"github.com/ethereum/go-ethereum/common/httpclient".self·2 }) }
	func (@"github.com/ethereum/go-ethereum/common/httpclient".self·3 *@"github.com/ethereum/go-ethereum/common/httpclient".HTTPClient) Get (@"github.com/ethereum/go-ethereum/common/httpclient".uri·4 string, @"github.com/ethereum/go-ethereum/common/httpclient".path·5 string) (? []byte, ? error)
	func (@"github.com/ethereum/go-ethereum/common/httpclient".self·3 *@"github.com/ethereum/go-ethereum/common/httpclient".HTTPClient) GetAuthContent (@"github.com/ethereum/go-ethereum/common/httpclient".uri·4 string, @"github.com/ethereum/go-ethereum/common/httpclient".hash·5 @"github.com/ethereum/go-ethereum/common".Hash) (? []byte, ? error)
	func (@"github.com/ethereum/go-ethereum/common/httpclient".self·2 *@"github.com/ethereum/go-ethereum/common/httpclient".HTTPClient "esc:0x1") HasScheme (@"github.com/ethereum/go-ethereum/common/httpclient".scheme·3 string "esc:0x1") (? bool)
	func (@"github.com/ethereum/go-ethereum/common/httpclient".self·1 *@"github.com/ethereum/go-ethereum/common/httpclient".HTTPClient "esc:0x9") RegisterScheme (@"github.com/ethereum/go-ethereum/common/httpclient".scheme·2 string, @"github.com/ethereum/go-ethereum/common/httpclient".rt·3 @"net/http".RoundTripper)
	type @"github.com/ethereum/go-ethereum/miner".Agent interface { GetHashRate() (? int64); SetReturnCh(? chan<- *@"github.com/ethereum/go-ethereum/miner".Result); Start(); Stop(); Work() (? chan<- *@"github.com/ethereum/go-ethereum/miner".Work) }
	type @"github.com/ethereum/go-ethereum/core".Backend interface { AccountManager() (? *@"github.com/ethereum/go-ethereum/accounts".Manager); BlockChain() (? *@"github.com/ethereum/go-ethereum/core".BlockChain); ChainDb() (? @"github.com/ethereum/go-ethereum/ethdb".Database); DappDb() (? @"github.com/ethereum/go-ethereum/ethdb".Database); EventMux() (? *@"github.com/ethereum/go-ethereum/event".TypeMux); TxPool() (? *@"github.com/ethereum/go-ethereum/core".TxPool) }
	type @"github.com/ethereum/go-ethereum/miner".worker struct { @"github.com/ethereum/go-ethereum/miner".mu @"sync".Mutex; @"github.com/ethereum/go-ethereum/miner".agents map[@"github.com/ethereum/go-ethereum/miner".Agent]struct {}; @"github.com/ethereum/go-ethereum/miner".recv chan *@"github.com/ethereum/go-ethereum/miner".Result; @"github.com/ethereum/go-ethereum/miner".mux *@"github.com/ethereum/go-ethereum/event".TypeMux; @"github.com/ethereum/go-ethereum/miner".quit chan struct {}; @"github.com/ethereum/go-ethereum/miner".pow @"github.com/ethereum/go-ethereum/pow".PoW; @"github.com/ethereum/go-ethereum/miner".eth @"github.com/ethereum/go-ethereum/core".Backend; @"github.com/ethereum/go-ethereum/miner".chain *@"github.com/ethereum/go-ethereum/core".BlockChain; @"github.com/ethereum/go-ethereum/miner".proc @"github.com/ethereum/go-ethereum/core".Validator; @"github.com/ethereum/go-ethereum/miner".chainDb @"github.com/ethereum/go-ethereum/ethdb".Database; @"github.com/ethereum/go-ethereum/miner".coinbase @"github.com/ethereum/go-ethereum/common".Address; @"github.com/ethereum/go-ethereum/miner".gasPrice *@"math/big".Int; @"github.com/ethereum/go-ethereum/miner".extra []byte; @"github.com/ethereum/go-ethereum/miner".currentMu @"sync".Mutex; @"github.com/ethereum/go-ethereum/miner".current *@"github.com/ethereum/go-ethereum/miner".Work; @"github.com/ethereum/go-ethereum/miner".uncleMu @"sync".Mutex; @"github.com/ethereum/go-ethereum/miner".possibleUncles map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/core/types".Block; @"github.com/ethereum/go-ethereum/miner".txQueueMu @"sync".Mutex; @"github.com/ethereum/go-ethereum/miner".txQueue map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/core/types".Transaction; @"github.com/ethereum/go-ethereum/miner".mining int32; @"github.com/ethereum/go-ethereum/miner".atWork int32; @"github.com/ethereum/go-ethereum/miner".fullValidation bool }
	func (@"github.com/ethereum/go-ethereum/miner".self·2 *@"github.com/ethereum/go-ethereum/miner".worker "esc:0x1") HashRate () (? int64) { return 0x0 }
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".commitNewWork ()
	func (@"github.com/ethereum/go-ethereum/miner".self·2 *@"github.com/ethereum/go-ethereum/miner".worker "esc:0x1") @"github.com/ethereum/go-ethereum/miner".commitUncle (@"github.com/ethereum/go-ethereum/miner".work·3 *@"github.com/ethereum/go-ethereum/miner".Work "esc:0x9", @"github.com/ethereum/go-ethereum/miner".uncle·4 *@"github.com/ethereum/go-ethereum/core/types".Header) (? error)
	func (@"github.com/ethereum/go-ethereum/miner".self·2 *@"github.com/ethereum/go-ethereum/miner".worker "esc:0x9") @"github.com/ethereum/go-ethereum/miner".isBlockLocallyMined (@"github.com/ethereum/go-ethereum/miner".current·3 *@"github.com/ethereum/go-ethereum/miner".Work "esc:0x1", @"github.com/ethereum/go-ethereum/miner".deepBlockNum·4 uint64) (? bool)
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".worker "esc:0x9") @"github.com/ethereum/go-ethereum/miner".logLocalMinedBlocks (@"github.com/ethereum/go-ethereum/miner".current·2 *@"github.com/ethereum/go-ethereum/miner".Work "esc:0x1", @"github.com/ethereum/go-ethereum/miner".previous·3 *@"github.com/ethereum/go-ethereum/miner".Work "esc:0x1")
	func (@"github.com/ethereum/go-ethereum/miner".self·2 *@"github.com/ethereum/go-ethereum/miner".worker "esc:0x9") @"github.com/ethereum/go-ethereum/miner".makeCurrent (@"github.com/ethereum/go-ethereum/miner".parent·3 *@"github.com/ethereum/go-ethereum/core/types".Block, @"github.com/ethereum/go-ethereum/miner".header·4 *@"github.com/ethereum/go-ethereum/core/types".Header) (? error)
	func (@"github.com/ethereum/go-ethereum/miner".self·2 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".pendingBlock () (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/miner".self·2 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".pendingState () (? *@"github.com/ethereum/go-ethereum/core/state".StateDB)
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".push (@"github.com/ethereum/go-ethereum/miner".work·2 *@"github.com/ethereum/go-ethereum/miner".Work)
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".register (@"github.com/ethereum/go-ethereum/miner".agent·2 @"github.com/ethereum/go-ethereum/miner".Agent)
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".setEtherbase (@"github.com/ethereum/go-ethereum/miner".addr·2 @"github.com/ethereum/go-ethereum/common".Address)
	func (@"github.com/ethereum/go-ethereum/miner".w·1 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".setGasPrice (@"github.com/ethereum/go-ethereum/miner".p·2 *@"math/big".Int "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".start ()
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".stop ()
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".unregister (@"github.com/ethereum/go-ethereum/miner".agent·2 @"github.com/ethereum/go-ethereum/miner".Agent)
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".update ()
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".worker) @"github.com/ethereum/go-ethereum/miner".wait ()
	type @"github.com/ethereum/go-ethereum/miner".Miner struct { @"github.com/ethereum/go-ethereum/miner".mux *@"github.com/ethereum/go-ethereum/event".TypeMux; @"github.com/ethereum/go-ethereum/miner".worker *@"github.com/ethereum/go-ethereum/miner".worker; MinAcceptedGasPrice *@"math/big".Int; @"github.com/ethereum/go-ethereum/miner".threads int; @"github.com/ethereum/go-ethereum/miner".coinbase @"github.com/ethereum/go-ethereum/common".Address; @"github.com/ethereum/go-ethereum/miner".mining int32; @"github.com/ethereum/go-ethereum/miner".eth @"github.com/ethereum/go-ethereum/core".Backend; @"github.com/ethereum/go-ethereum/miner".pow @"github.com/ethereum/go-ethereum/pow".PoW; @"github.com/ethereum/go-ethereum/miner".canStart int32; @"github.com/ethereum/go-ethereum/miner".shouldStart int32 }
	func (@"github.com/ethereum/go-ethereum/miner".self·2 *@"github.com/ethereum/go-ethereum/miner".Miner "esc:0x9") HashRate () (@"github.com/ethereum/go-ethereum/miner".tot·1 int64)
	func (@"github.com/ethereum/go-ethereum/miner".self·2 *@"github.com/ethereum/go-ethereum/miner".Miner) Mining () (? bool)
	func (@"github.com/ethereum/go-ethereum/miner".self·2 *@"github.com/ethereum/go-ethereum/miner".Miner "esc:0x9") PendingBlock () (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/miner".self·2 *@"github.com/ethereum/go-ethereum/miner".Miner "esc:0x9") PendingState () (? *@"github.com/ethereum/go-ethereum/core/state".StateDB)
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".Miner) Register (@"github.com/ethereum/go-ethereum/miner".agent·2 @"github.com/ethereum/go-ethereum/miner".Agent)
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".Miner "esc:0x9") SetEtherbase (@"github.com/ethereum/go-ethereum/miner".addr·2 @"github.com/ethereum/go-ethereum/common".Address)
	func (@"github.com/ethereum/go-ethereum/miner".self·2 *@"github.com/ethereum/go-ethereum/miner".Miner "esc:0x1") SetExtra (@"github.com/ethereum/go-ethereum/miner".extra·3 []byte) (? error)
	func (@"github.com/ethereum/go-ethereum/miner".m·1 *@"github.com/ethereum/go-ethereum/miner".Miner "esc:0x9") SetGasPrice (@"github.com/ethereum/go-ethereum/miner".price·2 *@"math/big".Int "esc:0x9")
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".Miner) Start (@"github.com/ethereum/go-ethereum/miner".coinbase·2 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/miner".threads·3 int)
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".Miner) Stop ()
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".Miner "esc:0x9") Unregister (@"github.com/ethereum/go-ethereum/miner".agent·2 @"github.com/ethereum/go-ethereum/miner".Agent)
	func (@"github.com/ethereum/go-ethereum/miner".self·1 *@"github.com/ethereum/go-ethereum/miner".Miner) @"github.com/ethereum/go-ethereum/miner".update ()
	type @"github.com/ethereum/go-ethereum/eth".Ethereum struct { @"github.com/ethereum/go-ethereum/eth".shutdownChan chan bool; @"github.com/ethereum/go-ethereum/eth".chainDb @"github.com/ethereum/go-ethereum/ethdb".Database; @"github.com/ethereum/go-ethereum/eth".dappDb @"github.com/ethereum/go-ethereum/ethdb".Database; @"github.com/ethereum/go-ethereum/eth".txPool *@"github.com/ethereum/go-ethereum/core".TxPool; @"github.com/ethereum/go-ethereum/eth".blockchain *@"github.com/ethereum/go-ethereum/core".BlockChain; @"github.com/ethereum/go-ethereum/eth".accountManager *@"github.com/ethereum/go-ethereum/accounts".Manager; @"github.com/ethereum/go-ethereum/eth".pow *@"github.com/ethereum/ethash".Ethash; @"github.com/ethereum/go-ethereum/eth".protocolManager *@"github.com/ethereum/go-ethereum/eth".ProtocolManager; SolcPath string; @"github.com/ethereum/go-ethereum/eth".solc *@"github.com/ethereum/go-ethereum/common/compiler".Solidity; GpoMinGasPrice *@"math/big".Int; GpoMaxGasPrice *@"math/big".Int; GpoFullBlockRatio int; GpobaseStepDown int; GpobaseStepUp int; GpobaseCorrectionFactor int; @"github.com/ethereum/go-ethereum/eth".httpclient *@"github.com/ethereum/go-ethereum/common/httpclient".HTTPClient; @"github.com/ethereum/go-ethereum/eth".eventMux *@"github.com/ethereum/go-ethereum/event".TypeMux; @"github.com/ethereum/go-ethereum/eth".miner *@"github.com/ethereum/go-ethereum/miner".Miner; Mining bool; MinerThreads int; NatSpec bool; AutoDAG bool; PowTest bool; @"github.com/ethereum/go-ethereum/eth".autodagquit chan bool; @"github.com/ethereum/go-ethereum/eth".etherbase @"github.com/ethereum/go-ethereum/common".Address; @"github.com/ethereum/go-ethereum/eth".netVersionId int }
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x22") AccountManager () (? *@"github.com/ethereum/go-ethereum/accounts".Manager) { return @"github.com/ethereum/go-ethereum/eth".s·2.@"github.com/ethereum/go-ethereum/eth".accountManager }
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x22") BlockChain () (? *@"github.com/ethereum/go-ethereum/core".BlockChain) { return @"github.com/ethereum/go-ethereum/eth".s·2.@"github.com/ethereum/go-ethereum/eth".blockchain }
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x22") ChainDb () (? @"github.com/ethereum/go-ethereum/ethdb".Database) { return @"github.com/ethereum/go-ethereum/eth".s·2.@"github.com/ethereum/go-ethereum/eth".chainDb }
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x22") DappDb () (? @"github.com/ethereum/go-ethereum/ethdb".Database) { return @"github.com/ethereum/go-ethereum/eth".s·2.@"github.com/ethereum/go-ethereum/eth".dappDb }
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x32") Downloader () (? *@"github.com/ethereum/go-ethereum/eth/downloader".Downloader) { return @"github.com/ethereum/go-ethereum/eth".s·2.@"github.com/ethereum/go-ethereum/eth".protocolManager.@"github.com/ethereum/go-ethereum/eth".downloader }
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x1") EthVersion () (? int) { return int(@"github.com/ethereum/go-ethereum/eth".s·2.@"github.com/ethereum/go-ethereum/eth".protocolManager.SubProtocols[0x0].Version) }
	func (@"github.com/ethereum/go-ethereum/eth".s·3 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x9") Etherbase () (@"github.com/ethereum/go-ethereum/eth".eb·1 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/eth".err·2 error)
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x22") EventMux () (? *@"github.com/ethereum/go-ethereum/event".TypeMux) { return @"github.com/ethereum/go-ethereum/eth".s·2.@"github.com/ethereum/go-ethereum/eth".eventMux }
	func (@"github.com/ethereum/go-ethereum/eth".self·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x22") HTTPClient () (? *@"github.com/ethereum/go-ethereum/common/httpclient".HTTPClient) { return @"github.com/ethereum/go-ethereum/eth".self·2.@"github.com/ethereum/go-ethereum/eth".httpclient }
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x1") IsListening () (? bool) { return true }
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x9") IsMining () (? bool)
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x22") Miner () (? *@"github.com/ethereum/go-ethereum/miner".Miner) { return @"github.com/ethereum/go-ethereum/eth".s·2.@"github.com/ethereum/go-ethereum/eth".miner }
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x1") NetVersion () (? int) { return @"github.com/ethereum/go-ethereum/eth".s·2.@"github.com/ethereum/go-ethereum/eth".netVersionId }
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x32") Protocols () (? []@"github.com/ethereum/go-ethereum/p2p".Protocol) { return @"github.com/ethereum/go-ethereum/eth".s·2.@"github.com/ethereum/go-ethereum/eth".protocolManager.SubProtocols }
	func (@"github.com/ethereum/go-ethereum/eth".s·1 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x9") ResetWithGenesisBlock (@"github.com/ethereum/go-ethereum/eth".gb·2 *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/eth".self·1 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x9") SetEtherbase (@"github.com/ethereum/go-ethereum/eth".etherbase·2 @"github.com/ethereum/go-ethereum/common".Address)
	func (@"github.com/ethereum/go-ethereum/eth".self·3 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x2a") SetSolc (@"github.com/ethereum/go-ethereum/eth".solcPath·4 string) (? *@"github.com/ethereum/go-ethereum/common/compiler".Solidity, ? error)
	func (@"github.com/ethereum/go-ethereum/eth".self·3 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x2a") Solc () (? *@"github.com/ethereum/go-ethereum/common/compiler".Solidity, ? error)
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum) Start (? *@"github.com/ethereum/go-ethereum/p2p".Server) (? error)
	func (@"github.com/ethereum/go-ethereum/eth".self·1 *@"github.com/ethereum/go-ethereum/eth".Ethereum) StartAutoDAG ()
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x9") StartMining (@"github.com/ethereum/go-ethereum/eth".threads·3 int, @"github.com/ethereum/go-ethereum/eth".gpus·4 string "esc:0x1") (? error)
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x9") Stop () (? error)
	func (@"github.com/ethereum/go-ethereum/eth".self·1 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x1") StopAutoDAG ()
	func (@"github.com/ethereum/go-ethereum/eth".s·1 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x9") StopMining ()
	func (@"github.com/ethereum/go-ethereum/eth".s·2 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x22") TxPool () (? *@"github.com/ethereum/go-ethereum/core".TxPool) { return @"github.com/ethereum/go-ethereum/eth".s·2.@"github.com/ethereum/go-ethereum/eth".txPool }
	func (@"github.com/ethereum/go-ethereum/eth".s·1 *@"github.com/ethereum/go-ethereum/eth".Ethereum "esc:0x1") WaitForShutdown () { <-@"github.com/ethereum/go-ethereum/eth".s·1.@"github.com/ethereum/go-ethereum/eth".shutdownChan }
	type @"github.com/ethereum/go-ethereum/eth".blockPriceInfo struct { @"github.com/ethereum/go-ethereum/eth".baseGasPrice *@"math/big".Int }
	type @"github.com/ethereum/go-ethereum/eth".GasPriceOracle struct { @"github.com/ethereum/go-ethereum/eth".eth *@"github.com/ethereum/go-ethereum/eth".Ethereum; @"github.com/ethereum/go-ethereum/eth".initOnce @"sync".Once; @"github.com/ethereum/go-ethereum/eth".minPrice *@"math/big".Int; @"github.com/ethereum/go-ethereum/eth".lastBaseMutex @"sync".Mutex; @"github.com/ethereum/go-ethereum/eth".lastBase *@"math/big".Int; @"github.com/ethereum/go-ethereum/eth".blocks map[uint64]*@"github.com/ethereum/go-ethereum/eth".blockPriceInfo; @"github.com/ethereum/go-ethereum/eth".firstProcessed uint64; @"github.com/ethereum/go-ethereum/eth".lastProcessed uint64; @"github.com/ethereum/go-ethereum/eth".minBase *@"math/big".Int }
	func (@"github.com/ethereum/go-ethereum/eth".self·2 *@"github.com/ethereum/go-ethereum/eth".GasPriceOracle) SuggestPrice () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/eth".gpo·1 *@"github.com/ethereum/go-ethereum/eth".GasPriceOracle) @"github.com/ethereum/go-ethereum/eth".init ()
	func (@"github.com/ethereum/go-ethereum/eth".self·1 *@"github.com/ethereum/go-ethereum/eth".GasPriceOracle) @"github.com/ethereum/go-ethereum/eth".listenLoop ()
	func (@"github.com/ethereum/go-ethereum/eth".self·2 *@"github.com/ethereum/go-ethereum/eth".GasPriceOracle "esc:0x9") @"github.com/ethereum/go-ethereum/eth".lowestPrice (@"github.com/ethereum/go-ethereum/eth".block·3 *@"github.com/ethereum/go-ethereum/core/types".Block) (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/eth".self·1 *@"github.com/ethereum/go-ethereum/eth".GasPriceOracle) @"github.com/ethereum/go-ethereum/eth".processBlock (@"github.com/ethereum/go-ethereum/eth".block·2 *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/eth".self·1 *@"github.com/ethereum/go-ethereum/eth".GasPriceOracle) @"github.com/ethereum/go-ethereum/eth".processPastBlocks (@"github.com/ethereum/go-ethereum/eth".chain·2 *@"github.com/ethereum/go-ethereum/core".BlockChain)
	type @"github.com/ethereum/go-ethereum/common".ValueIterator struct { @"github.com/ethereum/go-ethereum/common".value *@"github.com/ethereum/go-ethereum/common".Value; @"github.com/ethereum/go-ethereum/common".currentValue *@"github.com/ethereum/go-ethereum/common".Value; @"github.com/ethereum/go-ethereum/common".idx int }
	func (@"github.com/ethereum/go-ethereum/common".it·2 *@"github.com/ethereum/go-ethereum/common".ValueIterator "esc:0x1") Idx () (? int) { return @"github.com/ethereum/go-ethereum/common".it·2.@"github.com/ethereum/go-ethereum/common".idx - 0x1 }
	func (@"github.com/ethereum/go-ethereum/common".it·2 *@"github.com/ethereum/go-ethereum/common".ValueIterator "esc:0x9") Len () (? int)
	func (@"github.com/ethereum/go-ethereum/common".it·2 *@"github.com/ethereum/go-ethereum/common".ValueIterator "esc:0x9") Next () (? bool)
	func (@"github.com/ethereum/go-ethereum/common".it·2 *@"github.com/ethereum/go-ethereum/common".ValueIterator "esc:0x22") Value () (? *@"github.com/ethereum/go-ethereum/common".Value) { return @"github.com/ethereum/go-ethereum/common".it·2.@"github.com/ethereum/go-ethereum/common".currentValue }
	type @"github.com/ethereum/go-ethereum/common".Value struct { Val interface {} }
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1a") Add (@"github.com/ethereum/go-ethereum/common".other·3 interface {}) (? *@"github.com/ethereum/go-ethereum/common".Value)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1a") Append (@"github.com/ethereum/go-ethereum/common".v·3 interface {}) (? *@"github.com/ethereum/go-ethereum/common".Value) { @"github.com/ethereum/go-ethereum/common".val·2.Val = append(@"github.com/ethereum/go-ethereum/common".val·2.Slice(), @"github.com/ethereum/go-ethereum/common".v·3); return @"github.com/ethereum/go-ethereum/common".val·2 }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") AppendList () (? *@"github.com/ethereum/go-ethereum/common".Value) { var @"github.com/ethereum/go-ethereum/common".list·3 *@"github.com/ethereum/go-ethereum/common".Value; ; @"github.com/ethereum/go-ethereum/common".list·3 = @"github.com/ethereum/go-ethereum/common".EmptyValue(); @"github.com/ethereum/go-ethereum/common".val·2.Val = append(@"github.com/ethereum/go-ethereum/common".val·2.Slice(), @"github.com/ethereum/go-ethereum/common".list·3); return @"github.com/ethereum/go-ethereum/common".list·3 }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x2a") BigInt () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1") Byte () (? byte) { var @"github.com/ethereum/go-ethereum/common".Val·3 byte; ; var @"github.com/ethereum/go-ethereum/common".ok·4 bool; ; @"github.com/ethereum/go-ethereum/common".Val·3, @"github.com/ethereum/go-ethereum/common".ok·4 = @"github.com/ethereum/go-ethereum/common".val·2.Val.(byte); if @"github.com/ethereum/go-ethereum/common".ok·4 { return @"github.com/ethereum/go-ethereum/common".Val·3 }; return byte(0x0) }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x2a") Bytes () (? []byte)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") Cmp (@"github.com/ethereum/go-ethereum/common".o·3 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") (? bool)
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0xa") Copy () (? *@"github.com/ethereum/go-ethereum/common".Value)
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1") DecodeRLP (@"github.com/ethereum/go-ethereum/common".s·3 *@"github.com/ethereum/go-ethereum/rlp".Stream) (? error)
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") DeepCmp (@"github.com/ethereum/go-ethereum/common".o·3 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") (? bool)
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1a") Div (@"github.com/ethereum/go-ethereum/common".other·3 interface {}) (? *@"github.com/ethereum/go-ethereum/common".Value)
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") EncodeRLP (@"github.com/ethereum/go-ethereum/common".w·3 @"io".Writer) (? error)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x22") Err () (? error) { var @"github.com/ethereum/go-ethereum/common".err·3 error; ; var @"github.com/ethereum/go-ethereum/common".ok·4 bool; ; @"github.com/ethereum/go-ethereum/common".err·3, @"github.com/ethereum/go-ethereum/common".ok·4 = @"github.com/ethereum/go-ethereum/common".val·2.Val.(error); if @"github.com/ethereum/go-ethereum/common".ok·4 { return @"github.com/ethereum/go-ethereum/common".err·3 }; return nil }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x22") Get (@"github.com/ethereum/go-ethereum/common".idx·3 int) (? *@"github.com/ethereum/go-ethereum/common".Value)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") Int () (? int64)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") IsEmpty () (? bool)
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1") IsErr () (? bool) { var @"github.com/ethereum/go-ethereum/common".ok·3 bool; ; _, @"github.com/ethereum/go-ethereum/common".ok·3 = @"github.com/ethereum/go-ethereum/common".self·2.Val.(error); return @"github.com/ethereum/go-ethereum/common".ok·3 }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1") IsList () (? bool) { var @"github.com/ethereum/go-ethereum/common".ok·3 bool; ; _, @"github.com/ethereum/go-ethereum/common".ok·3 = @"github.com/ethereum/go-ethereum/common".val·2.Val.([]interface {}); return @"github.com/ethereum/go-ethereum/common".ok·3 }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1") IsNil () (? bool) { return @"github.com/ethereum/go-ethereum/common".val·2.Val == nil }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") IsSlice () (? bool)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") IsStr () (? bool)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") Len () (? int)
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1a") Mul (@"github.com/ethereum/go-ethereum/common".other·3 interface {}) (? *@"github.com/ethereum/go-ethereum/common".Value)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value) NewIterator () (? *@"github.com/ethereum/go-ethereum/common".ValueIterator) { return (&@"github.com/ethereum/go-ethereum/common".ValueIterator{ @"github.com/ethereum/go-ethereum/common".value:@"github.com/ethereum/go-ethereum/common".val·2 }) }
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1a") Pow (@"github.com/ethereum/go-ethereum/common".other·3 interface {}) (? *@"github.com/ethereum/go-ethereum/common".Value)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x22") Slice () (? []interface {}) { var @"github.com/ethereum/go-ethereum/common".d·3 []interface {}; ; var @"github.com/ethereum/go-ethereum/common".ok·4 bool; ; @"github.com/ethereum/go-ethereum/common".d·3, @"github.com/ethereum/go-ethereum/common".ok·4 = @"github.com/ethereum/go-ethereum/common".val·2.Val.([]interface {}); if @"github.com/ethereum/go-ethereum/common".ok·4 { return @"github.com/ethereum/go-ethereum/common".d·3 }; return ([]interface {}{  }) }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0xa") SliceFrom (@"github.com/ethereum/go-ethereum/common".from·3 int) (? *@"github.com/ethereum/go-ethereum/common".Value) { var @"github.com/ethereum/go-ethereum/common".slice·4 []interface {}; ; @"github.com/ethereum/go-ethereum/common".slice·4 = @"github.com/ethereum/go-ethereum/common".val·2.Slice(); return @"github.com/ethereum/go-ethereum/common".NewValue(@"github.com/ethereum/go-ethereum/common".slice·4[@"github.com/ethereum/go-ethereum/common".from·3:]) }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0xa") SliceFromTo (@"github.com/ethereum/go-ethereum/common".from·3 int, @"github.com/ethereum/go-ethereum/common".to·4 int) (? *@"github.com/ethereum/go-ethereum/common".Value) { var @"github.com/ethereum/go-ethereum/common".slice·5 []interface {}; ; @"github.com/ethereum/go-ethereum/common".slice·5 = @"github.com/ethereum/go-ethereum/common".val·2.Slice(); return @"github.com/ethereum/go-ethereum/common".NewValue(@"github.com/ethereum/go-ethereum/common".slice·5[@"github.com/ethereum/go-ethereum/common".from·3:@"github.com/ethereum/go-ethereum/common".to·4]) }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0xa") SliceTo (@"github.com/ethereum/go-ethereum/common".to·3 int) (? *@"github.com/ethereum/go-ethereum/common".Value) { var @"github.com/ethereum/go-ethereum/common".slice·4 []interface {}; ; @"github.com/ethereum/go-ethereum/common".slice·4 = @"github.com/ethereum/go-ethereum/common".val·2.Slice(); return @"github.com/ethereum/go-ethereum/common".NewValue(@"github.com/ethereum/go-ethereum/common".slice·4[:@"github.com/ethereum/go-ethereum/common".to·3]) }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x22") Str () (? string) { var @"github.com/ethereum/go-ethereum/common".a·3 []byte; ; var @"github.com/ethereum/go-ethereum/common".ok·4 bool; ; @"github.com/ethereum/go-ethereum/common".a·3, @"github.com/ethereum/go-ethereum/common".ok·4 = @"github.com/ethereum/go-ethereum/common".val·2.Val.([]byte); if @"github.com/ethereum/go-ethereum/common".ok·4 { return string(@"github.com/ethereum/go-ethereum/common".a·3) } else { var @"github.com/ethereum/go-ethereum/common".a·5 string; ; var @"github.com/ethereum/go-ethereum/common".ok·6 bool; ; @"github.com/ethereum/go-ethereum/common".a·5, @"github.com/ethereum/go-ethereum/common".ok·6 = @"github.com/ethereum/go-ethereum/common".val·2.Val.(string); if @"github.com/ethereum/go-ethereum/common".ok·6 { return @"github.com/ethereum/go-ethereum/common".a·5 } else { var @"github.com/ethereum/go-ethereum/common".a·7 byte; ; var @"github.com/ethereum/go-ethereum/common".ok·8 bool; ; @"github.com/ethereum/go-ethereum/common".a·7, @"github.com/ethereum/go-ethereum/common".ok·8 = @"github.com/ethereum/go-ethereum/common".val·2.Val.(byte); if @"github.com/ethereum/go-ethereum/common".ok·8 { return string(@"github.com/ethereum/go-ethereum/common".a·7) } } }; return "" }
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") String () (? string)
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1a") Sub (@"github.com/ethereum/go-ethereum/common".other·3 interface {}) (? *@"github.com/ethereum/go-ethereum/common".Value)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") Type () (? @"reflect".Kind)
	func (@"github.com/ethereum/go-ethereum/common".val·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1") Uint () (? uint64)
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x1a") @"github.com/ethereum/go-ethereum/common".doOp (@"github.com/ethereum/go-ethereum/common".op·3 int, @"github.com/ethereum/go-ethereum/common".other·4 interface {}) (? *@"github.com/ethereum/go-ethereum/common".Value)
	type @"github.com/ethereum/go-ethereum/xeth".Object struct { ? *@"github.com/ethereum/go-ethereum/core/state".StateObject }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Object "esc:0x9") Storage () (@"github.com/ethereum/go-ethereum/xeth".storage·1 map[string]string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Object "esc:0x9") StorageString (@"github.com/ethereum/go-ethereum/xeth".str·3 string "esc:0x1") (? []byte)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Object "esc:0x9") StorageValue (@"github.com/ethereum/go-ethereum/xeth".addr·3 *@"github.com/ethereum/go-ethereum/common".Value "esc:0x9") (? []byte)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Object "esc:0x9") @"github.com/ethereum/go-ethereum/xeth".storage (@"github.com/ethereum/go-ethereum/xeth".addr·3 []byte "esc:0x9") (? []byte)
	type @"github.com/ethereum/go-ethereum/xeth".State struct { @"github.com/ethereum/go-ethereum/xeth".xeth *@"github.com/ethereum/go-ethereum/xeth".XEth; @"github.com/ethereum/go-ethereum/xeth".state *@"github.com/ethereum/go-ethereum/core/state".StateDB }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".State "esc:0x9") Get (@"github.com/ethereum/go-ethereum/xeth".addr·3 string "esc:0x1") (? *@"github.com/ethereum/go-ethereum/xeth".Object)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".State "esc:0x9") SafeGet (@"github.com/ethereum/go-ethereum/xeth".addr·3 string "esc:0x1") (? *@"github.com/ethereum/go-ethereum/xeth".Object)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".State "esc:0x22") State () (? *@"github.com/ethereum/go-ethereum/core/state".StateDB) { return @"github.com/ethereum/go-ethereum/xeth".self·2.@"github.com/ethereum/go-ethereum/xeth".state }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".State "esc:0x9") @"github.com/ethereum/go-ethereum/xeth".safeGet (@"github.com/ethereum/go-ethereum/xeth".addr·3 string "esc:0x1") (? *@"github.com/ethereum/go-ethereum/core/state".StateObject)
	import filters "github.com/ethereum/go-ethereum/eth/filters" // indirect
	type @"github.com/ethereum/go-ethereum/eth/filters".Filter struct { @"github.com/ethereum/go-ethereum/eth/filters".db @"github.com/ethereum/go-ethereum/ethdb".Database; @"github.com/ethereum/go-ethereum/eth/filters".begin int64; @"github.com/ethereum/go-ethereum/eth/filters".end int64; @"github.com/ethereum/go-ethereum/eth/filters".addresses []@"github.com/ethereum/go-ethereum/common".Address; @"github.com/ethereum/go-ethereum/eth/filters".topics [][]@"github.com/ethereum/go-ethereum/common".Hash; BlockCallback func(? *@"github.com/ethereum/go-ethereum/core/types".Block, ? @"github.com/ethereum/go-ethereum/core/vm".Logs); TransactionCallback func(? *@"github.com/ethereum/go-ethereum/core/types".Transaction); LogsCallback func(? @"github.com/ethereum/go-ethereum/core/vm".Logs) }
	func (@"github.com/ethereum/go-ethereum/eth/filters".self·2 *@"github.com/ethereum/go-ethereum/eth/filters".Filter "esc:0x1") FilterLogs (@"github.com/ethereum/go-ethereum/eth/filters".logs·3 @"github.com/ethereum/go-ethereum/core/vm".Logs "esc:0x9") (? @"github.com/ethereum/go-ethereum/core/vm".Logs)
	func (@"github.com/ethereum/go-ethereum/eth/filters".self·2 *@"github.com/ethereum/go-ethereum/eth/filters".Filter "esc:0x9") Find () (? @"github.com/ethereum/go-ethereum/core/vm".Logs)
	func (@"github.com/ethereum/go-ethereum/eth/filters".self·1 *@"github.com/ethereum/go-ethereum/eth/filters".Filter "esc:0x1") SetAddresses (@"github.com/ethereum/go-ethereum/eth/filters".addr·2 []@"github.com/ethereum/go-ethereum/common".Address) { @"github.com/ethereum/go-ethereum/eth/filters".self·1.@"github.com/ethereum/go-ethereum/eth/filters".addresses = @"github.com/ethereum/go-ethereum/eth/filters".addr·2 }
	func (@"github.com/ethereum/go-ethereum/eth/filters".self·1 *@"github.com/ethereum/go-ethereum/eth/filters".Filter "esc:0x1") SetBeginBlock (@"github.com/ethereum/go-ethereum/eth/filters".begin·2 int64) { @"github.com/ethereum/go-ethereum/eth/filters".self·1.@"github.com/ethereum/go-ethereum/eth/filters".begin = @"github.com/ethereum/go-ethereum/eth/filters".begin·2 }
	func (@"github.com/ethereum/go-ethereum/eth/filters".self·1 *@"github.com/ethereum/go-ethereum/eth/filters".Filter "esc:0x1") SetEndBlock (@"github.com/ethereum/go-ethereum/eth/filters".end·2 int64) { @"github.com/ethereum/go-ethereum/eth/filters".self·1.@"github.com/ethereum/go-ethereum/eth/filters".end = @"github.com/ethereum/go-ethereum/eth/filters".end·2 }
	func (@"github.com/ethereum/go-ethereum/eth/filters".self·1 *@"github.com/ethereum/go-ethereum/eth/filters".Filter "esc:0x1") SetTopics (@"github.com/ethereum/go-ethereum/eth/filters".topics·2 [][]@"github.com/ethereum/go-ethereum/common".Hash) { @"github.com/ethereum/go-ethereum/eth/filters".self·1.@"github.com/ethereum/go-ethereum/eth/filters".topics = @"github.com/ethereum/go-ethereum/eth/filters".topics·2 }
	func (@"github.com/ethereum/go-ethereum/eth/filters".self·2 *@"github.com/ethereum/go-ethereum/eth/filters".Filter "esc:0x1") @"github.com/ethereum/go-ethereum/eth/filters".bloomFilter (@"github.com/ethereum/go-ethereum/eth/filters".block·3 *@"github.com/ethereum/go-ethereum/core/types".Block "esc:0x1") (? bool)
	func (@"github.com/ethereum/go-ethereum/eth/filters".self·2 *@"github.com/ethereum/go-ethereum/eth/filters".Filter "esc:0x9") @"github.com/ethereum/go-ethereum/eth/filters".getLogs (@"github.com/ethereum/go-ethereum/eth/filters".start·3 uint64, @"github.com/ethereum/go-ethereum/eth/filters".end·4 uint64) (@"github.com/ethereum/go-ethereum/eth/filters".logs·1 @"github.com/ethereum/go-ethereum/core/vm".Logs)
	func (@"github.com/ethereum/go-ethereum/eth/filters".self·2 *@"github.com/ethereum/go-ethereum/eth/filters".Filter "esc:0x9") @"github.com/ethereum/go-ethereum/eth/filters".mipFind (@"github.com/ethereum/go-ethereum/eth/filters".start·3 uint64, @"github.com/ethereum/go-ethereum/eth/filters".end·4 uint64, @"github.com/ethereum/go-ethereum/eth/filters".depth·5 int) (@"github.com/ethereum/go-ethereum/eth/filters".logs·1 @"github.com/ethereum/go-ethereum/core/vm".Logs)
	type @"github.com/ethereum/go-ethereum/eth/filters".FilterSystem struct { @"github.com/ethereum/go-ethereum/eth/filters".filterMu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/eth/filters".filterId int; @"github.com/ethereum/go-ethereum/eth/filters".filters map[int]*@"github.com/ethereum/go-ethereum/eth/filters".Filter; @"github.com/ethereum/go-ethereum/eth/filters".created map[int]@"time".Time; @"github.com/ethereum/go-ethereum/eth/filters".sub @"github.com/ethereum/go-ethereum/event".Subscription }
	func (@"github.com/ethereum/go-ethereum/eth/filters".fs·2 *@"github.com/ethereum/go-ethereum/eth/filters".FilterSystem) Add (@"github.com/ethereum/go-ethereum/eth/filters".filter·3 *@"github.com/ethereum/go-ethereum/eth/filters".Filter) (@"github.com/ethereum/go-ethereum/eth/filters".id·1 int)
	func (@"github.com/ethereum/go-ethereum/eth/filters".fs·2 *@"github.com/ethereum/go-ethereum/eth/filters".FilterSystem) Get (@"github.com/ethereum/go-ethereum/eth/filters".id·3 int) (? *@"github.com/ethereum/go-ethereum/eth/filters".Filter)
	func (@"github.com/ethereum/go-ethereum/eth/filters".fs·1 *@"github.com/ethereum/go-ethereum/eth/filters".FilterSystem) Remove (@"github.com/ethereum/go-ethereum/eth/filters".id·2 int)
	func (@"github.com/ethereum/go-ethereum/eth/filters".fs·1 *@"github.com/ethereum/go-ethereum/eth/filters".FilterSystem "esc:0x9") Stop ()
	func (@"github.com/ethereum/go-ethereum/eth/filters".fs·1 *@"github.com/ethereum/go-ethereum/eth/filters".FilterSystem) @"github.com/ethereum/go-ethereum/eth/filters".filterLoop ()
	type @"github.com/ethereum/go-ethereum/common".List struct { @"github.com/ethereum/go-ethereum/common".mut @"sync".Mutex; @"github.com/ethereum/go-ethereum/common".val interface {}; @"github.com/ethereum/go-ethereum/common".list @"reflect".Value; Length int }
	func (@"github.com/ethereum/go-ethereum/common".self·1 *@"github.com/ethereum/go-ethereum/common".List) Append (@"github.com/ethereum/go-ethereum/common".v·2 interface {})
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".List) Get (@"github.com/ethereum/go-ethereum/common".i·3 int) (? interface {})
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".List) GetAsJson (@"github.com/ethereum/go-ethereum/common".i·3 int) (? interface {})
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".List "esc:0x9") Interface () (? interface {})
	func (@"github.com/ethereum/go-ethereum/common".self·2 *@"github.com/ethereum/go-ethereum/common".List) ToJSON () (? string)
	type @"github.com/ethereum/go-ethereum/xeth".Transaction struct { @"github.com/ethereum/go-ethereum/xeth".ref *@"github.com/ethereum/go-ethereum/core/types".Transaction; Value string "json:\"value\""; Gas string "json:\"gas\""; GasPrice string "json:\"gasPrice\""; Hash string "json:\"hash\""; Address string "json:\"address\""; Sender string "json:\"sender\""; RawData string "json:\"rawData\""; Data string "json:\"data\""; Contract bool "json:\"isContract\""; CreatesContract bool "json:\"createsContract\""; Confirmations int "json:\"confirmations\"" }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Transaction "esc:0x9") ToString () (? string)
	type @"github.com/ethereum/go-ethereum/xeth".Block struct { @"github.com/ethereum/go-ethereum/xeth".ref *@"github.com/ethereum/go-ethereum/core/types".Block; Size string "json:\"size\""; Number int "json:\"number\""; Hash string "json:\"hash\""; Transactions *@"github.com/ethereum/go-ethereum/common".List "json:\"transactions\""; Uncles *@"github.com/ethereum/go-ethereum/common".List "json:\"uncles\""; Time *@"math/big".Int "json:\"time\""; Coinbase string "json:\"coinbase\""; Name string "json:\"name\""; GasLimit string "json:\"gasLimit\""; GasUsed string "json:\"gasUsed\""; PrevHash string "json:\"prevHash\""; Bloom string "json:\"bloom\""; Raw string "json:\"raw\"" }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Block "esc:0x9") GetTransaction (@"github.com/ethereum/go-ethereum/xeth".hash·3 string "esc:0x1") (? *@"github.com/ethereum/go-ethereum/xeth".Transaction)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".Block "esc:0x9") ToString () (? string)
	type @"github.com/ethereum/go-ethereum/xeth".XEth struct { @"github.com/ethereum/go-ethereum/xeth".quit chan struct {}; @"github.com/ethereum/go-ethereum/xeth".logMu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/xeth".logQueue map[int]*@"github.com/ethereum/go-ethereum/xeth".logQueue; @"github.com/ethereum/go-ethereum/xeth".blockMu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/xeth".blockQueue map[int]*@"github.com/ethereum/go-ethereum/xeth".hashQueue; @"github.com/ethereum/go-ethereum/xeth".transactionMu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/xeth".transactionQueue map[int]*@"github.com/ethereum/go-ethereum/xeth".hashQueue; @"github.com/ethereum/go-ethereum/xeth".messagesMu @"sync".RWMutex; @"github.com/ethereum/go-ethereum/xeth".messages map[int]*@"github.com/ethereum/go-ethereum/xeth".whisperFilter; @"github.com/ethereum/go-ethereum/xeth".transactMu @"sync".Mutex; @"github.com/ethereum/go-ethereum/xeth".backend *@"github.com/ethereum/go-ethereum/node".Node; @"github.com/ethereum/go-ethereum/xeth".frontend @"github.com/ethereum/go-ethereum/xeth".Frontend; @"github.com/ethereum/go-ethereum/xeth".agent *@"github.com/ethereum/go-ethereum/miner".RemoteAgent; @"github.com/ethereum/go-ethereum/xeth".gpo *@"github.com/ethereum/go-ethereum/eth".GasPriceOracle; @"github.com/ethereum/go-ethereum/xeth".state *@"github.com/ethereum/go-ethereum/xeth".State; @"github.com/ethereum/go-ethereum/xeth".whisper *@"github.com/ethereum/go-ethereum/xeth".Whisper; @"github.com/ethereum/go-ethereum/xeth".filterManager *@"github.com/ethereum/go-ethereum/eth/filters".FilterSystem }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") Accounts () (? []string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") AllLogs (@"github.com/ethereum/go-ethereum/xeth".earliest·3 int64, @"github.com/ethereum/go-ethereum/xeth".latest·4 int64, @"github.com/ethereum/go-ethereum/xeth".skip·5 int, @"github.com/ethereum/go-ethereum/xeth".max·6 int, @"github.com/ethereum/go-ethereum/xeth".address·7 []string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".topics·8 [][]string "esc:0x1") (? @"github.com/ethereum/go-ethereum/core/vm".Logs)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) AtStateNum (@"github.com/ethereum/go-ethereum/xeth".num·3 int64) (? *@"github.com/ethereum/go-ethereum/xeth".XEth)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") BalanceAt (@"github.com/ethereum/go-ethereum/xeth".addr·3 string "esc:0x1") (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") Block (@"github.com/ethereum/go-ethereum/xeth".v·3 interface {} "esc:0x1") (? *@"github.com/ethereum/go-ethereum/xeth".Block)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") BlockByHash (@"github.com/ethereum/go-ethereum/xeth".strHash·3 string "esc:0x1") (? *@"github.com/ethereum/go-ethereum/xeth".Block)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") BlockByNumber (@"github.com/ethereum/go-ethereum/xeth".num·3 int64) (? *@"github.com/ethereum/go-ethereum/xeth".Block)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) BlockFilterChanged (@"github.com/ethereum/go-ethereum/xeth".id·3 int) (? []@"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/xeth".self·4 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") Call (@"github.com/ethereum/go-ethereum/xeth".fromStr·5 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".toStr·6 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".valueStr·7 string, @"github.com/ethereum/go-ethereum/xeth".gasStr·8 string, @"github.com/ethereum/go-ethereum/xeth".gasPriceStr·9 string, @"github.com/ethereum/go-ethereum/xeth".dataStr·10 string "esc:0x1") (? string, ? string, ? error)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") ClientVersion () (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") CodeAt (@"github.com/ethereum/go-ethereum/xeth".address·3 string "esc:0x1") (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") CodeAtBytes (@"github.com/ethereum/go-ethereum/xeth".address·3 string "esc:0x1") (? []byte)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") Coinbase () (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") ConfirmTransaction (@"github.com/ethereum/go-ethereum/xeth".tx·3 string) (? bool)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") CurrentBlock () (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/xeth".self·3 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") DbGet (@"github.com/ethereum/go-ethereum/xeth".key·4 []byte "esc:0x9") (? []byte, ? error)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") DbPut (@"github.com/ethereum/go-ethereum/xeth".key·3 []byte "esc:0x9", @"github.com/ethereum/go-ethereum/xeth".val·4 []byte) (? bool)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") DefaultGasPrice () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") EachStorage (@"github.com/ethereum/go-ethereum/xeth".addr·3 string "esc:0x1") (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") EthBlockByHash (@"github.com/ethereum/go-ethereum/xeth".strHash·3 string "esc:0x1") (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") EthBlockByNumber (@"github.com/ethereum/go-ethereum/xeth".num·3 int64) (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/xeth".self·5 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") EthTransactionByHash (@"github.com/ethereum/go-ethereum/xeth".hash·6 string "esc:0x1") (? *@"github.com/ethereum/go-ethereum/core/types".Transaction, ? @"github.com/ethereum/go-ethereum/common".Hash, ? uint64, ? uint64)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") EthVersion () (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") EthereumService () (? *@"github.com/ethereum/go-ethereum/eth".Ethereum)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x1") FromAscii (@"github.com/ethereum/go-ethereum/xeth".str·3 string "esc:0x1") (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x1") FromNumber (@"github.com/ethereum/go-ethereum/xeth".str·3 string "esc:0x1") (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x22") Frontend () (? @"github.com/ethereum/go-ethereum/xeth".Frontend) { return @"github.com/ethereum/go-ethereum/xeth".self·2.@"github.com/ethereum/go-ethereum/xeth".frontend }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") GasLimit () (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") GetBlockReceipts (@"github.com/ethereum/go-ethereum/xeth".bhash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? @"github.com/ethereum/go-ethereum/core/types".Receipts)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x1") GetFilterType (@"github.com/ethereum/go-ethereum/xeth".id·3 int) (? byte) { var @"github.com/ethereum/go-ethereum/xeth".ok·4 bool; ; _, @"github.com/ethereum/go-ethereum/xeth".ok·4 = @"github.com/ethereum/go-ethereum/xeth".self·2.@"github.com/ethereum/go-ethereum/xeth".blockQueue[@"github.com/ethereum/go-ethereum/xeth".id·3]; if @"github.com/ethereum/go-ethereum/xeth".ok·4 { return byte(0x1) } else { var @"github.com/ethereum/go-ethereum/xeth".ok·5 bool; ; _, @"github.com/ethereum/go-ethereum/xeth".ok·5 = @"github.com/ethereum/go-ethereum/xeth".self·2.@"github.com/ethereum/go-ethereum/xeth".transactionQueue[@"github.com/ethereum/go-ethereum/xeth".id·3]; if @"github.com/ethereum/go-ethereum/xeth".ok·5 { return byte(0x2) } else { var @"github.com/ethereum/go-ethereum/xeth".ok·6 bool; ; _, @"github.com/ethereum/go-ethereum/xeth".ok·6 = @"github.com/ethereum/go-ethereum/xeth".self·2.@"github.com/ethereum/go-ethereum/xeth".logQueue[@"github.com/ethereum/go-ethereum/xeth".id·3]; if @"github.com/ethereum/go-ethereum/xeth".ok·6 { return byte(0x3) } } }; return byte(0x0) }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") GetTxReceipt (@"github.com/ethereum/go-ethereum/xeth".txhash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? *@"github.com/ethereum/go-ethereum/core/types".Receipt)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") HashRate () (? int64)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") IsContract (@"github.com/ethereum/go-ethereum/xeth".address·3 string "esc:0x1") (? bool)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x1") IsListening () (? bool) { return true }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") IsMining () (? bool)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) LogFilterChanged (@"github.com/ethereum/go-ethereum/xeth".id·3 int) (? @"github.com/ethereum/go-ethereum/core/vm".Logs)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") Logs (@"github.com/ethereum/go-ethereum/xeth".id·3 int) (? @"github.com/ethereum/go-ethereum/core/vm".Logs)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") NetworkVersion () (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) NewBlockFilter () (? int)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) NewLogFilter (@"github.com/ethereum/go-ethereum/xeth".earliest·3 int64, @"github.com/ethereum/go-ethereum/xeth".latest·4 int64, @"github.com/ethereum/go-ethereum/xeth".skip·5 int, @"github.com/ethereum/go-ethereum/xeth".max·6 int, @"github.com/ethereum/go-ethereum/xeth".address·7 []string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".topics·8 [][]string "esc:0x1") (? int)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) NewTransactionFilter () (? int)
	func (@"github.com/ethereum/go-ethereum/xeth".p·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) NewWhisperFilter (@"github.com/ethereum/go-ethereum/xeth".to·3 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".from·4 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".topics·5 [][]string "esc:0x1") (? int)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x1") NumberToHuman (@"github.com/ethereum/go-ethereum/xeth".balance·3 string) (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") PeerCount () (? int)
	func (@"github.com/ethereum/go-ethereum/xeth".self·3 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") PushTx (@"github.com/ethereum/go-ethereum/xeth".encodedTx·4 string "esc:0x1") (? string, ? error)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x22") RemoteMining () (? *@"github.com/ethereum/go-ethereum/miner".RemoteAgent) { return @"github.com/ethereum/go-ethereum/xeth".self·2.@"github.com/ethereum/go-ethereum/xeth".agent }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") SetMining (@"github.com/ethereum/go-ethereum/xeth".shouldmine·3 bool, @"github.com/ethereum/go-ethereum/xeth".threads·4 int) (? bool)
	func (@"github.com/ethereum/go-ethereum/xeth".self·3 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") SetSolc (@"github.com/ethereum/go-ethereum/xeth".solcPath·4 string) (? *@"github.com/ethereum/go-ethereum/common/compiler".Solidity, ? error)
	func (@"github.com/ethereum/go-ethereum/xeth".self·3 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") Sign (@"github.com/ethereum/go-ethereum/xeth".fromStr·4 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".hashStr·5 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".didUnlock·6 bool) (? string, ? error)
	func (@"github.com/ethereum/go-ethereum/xeth".self·3 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") SignTransaction (@"github.com/ethereum/go-ethereum/xeth".fromStr·4 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".toStr·5 string, @"github.com/ethereum/go-ethereum/xeth".nonceStr·6 string, @"github.com/ethereum/go-ethereum/xeth".valueStr·7 string, @"github.com/ethereum/go-ethereum/xeth".gasStr·8 string, @"github.com/ethereum/go-ethereum/xeth".gasPriceStr·9 string, @"github.com/ethereum/go-ethereum/xeth".codeStr·10 string "esc:0x1") (? *@"github.com/ethereum/go-ethereum/core/types".Transaction, ? error)
	func (@"github.com/ethereum/go-ethereum/xeth".self·3 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") Solc () (? *@"github.com/ethereum/go-ethereum/common/compiler".Solidity, ? error)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x22") State () (? *@"github.com/ethereum/go-ethereum/xeth".State) { return @"github.com/ethereum/go-ethereum/xeth".self·2.@"github.com/ethereum/go-ethereum/xeth".state }
	func (@"github.com/ethereum/go-ethereum/xeth".self·1 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") Stop ()
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") StorageAt (@"github.com/ethereum/go-ethereum/xeth".addr·3 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".storageAddr·4 string "esc:0x1") (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") Td (@"github.com/ethereum/go-ethereum/xeth".hash·3 @"github.com/ethereum/go-ethereum/common".Hash) (? *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x1") ToAscii (@"github.com/ethereum/go-ethereum/xeth".str·3 string "esc:0x1") (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·3 *@"github.com/ethereum/go-ethereum/xeth".XEth) Transact (@"github.com/ethereum/go-ethereum/xeth".fromStr·4 string "esc:0x1", @"github.com/ethereum/go-ethereum/xeth".toStr·5 string, @"github.com/ethereum/go-ethereum/xeth".nonceStr·6 string, @"github.com/ethereum/go-ethereum/xeth".valueStr·7 string, @"github.com/ethereum/go-ethereum/xeth".gasStr·8 string, @"github.com/ethereum/go-ethereum/xeth".gasPriceStr·9 string, @"github.com/ethereum/go-ethereum/xeth".codeStr·10 string) (? string, ? error)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) TransactionFilterChanged (@"github.com/ethereum/go-ethereum/xeth".id·3 int) (? []@"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") TxCountAt (@"github.com/ethereum/go-ethereum/xeth".address·3 string "esc:0x1") (? int)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) UninstallFilter (@"github.com/ethereum/go-ethereum/xeth".id·3 int) (? bool)
	func (@"github.com/ethereum/go-ethereum/xeth".p·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) UninstallWhisperFilter (@"github.com/ethereum/go-ethereum/xeth".id·3 int) (? bool)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) UpdateState () (@"github.com/ethereum/go-ethereum/xeth".wait·1 chan *@"math/big".Int)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x22") Whisper () (? *@"github.com/ethereum/go-ethereum/xeth".Whisper) { return @"github.com/ethereum/go-ethereum/xeth".self·2.@"github.com/ethereum/go-ethereum/xeth".whisper }
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) WhisperMessages (@"github.com/ethereum/go-ethereum/xeth".id·3 int) (? []@"github.com/ethereum/go-ethereum/xeth".WhisperMessage)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) WhisperMessagesChanged (@"github.com/ethereum/go-ethereum/xeth".id·3 int) (? []@"github.com/ethereum/go-ethereum/xeth".WhisperMessage)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") WhisperService () (? *@"github.com/ethereum/go-ethereum/whisper".Whisper)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") WhisperVersion () (? string)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth) WithState (@"github.com/ethereum/go-ethereum/xeth".statedb·3 *@"github.com/ethereum/go-ethereum/core/state".StateDB) (? *@"github.com/ethereum/go-ethereum/xeth".XEth) { var @"github.com/ethereum/go-ethereum/xeth".xeth·4 *@"github.com/ethereum/go-ethereum/xeth".XEth; ; @"github.com/ethereum/go-ethereum/xeth".xeth·4 = (&@"github.com/ethereum/go-ethereum/xeth".XEth{ @"github.com/ethereum/go-ethereum/xeth".backend:@"github.com/ethereum/go-ethereum/xeth".self·2.@"github.com/ethereum/go-ethereum/xeth".backend, @"github.com/ethereum/go-ethereum/xeth".frontend:@"github.com/ethereum/go-ethereum/xeth".self·2.@"github.com/ethereum/go-ethereum/xeth".frontend, @"github.com/ethereum/go-ethereum/xeth".gpo:@"github.com/ethereum/go-ethereum/xeth".self·2.@"github.com/ethereum/go-ethereum/xeth".gpo }); @"github.com/ethereum/go-ethereum/xeth".xeth·4.@"github.com/ethereum/go-ethereum/xeth".state = @"github.com/ethereum/go-ethereum/xeth".NewState(@"github.com/ethereum/go-ethereum/xeth".xeth·4, @"github.com/ethereum/go-ethereum/xeth".statedb·3); return @"github.com/ethereum/go-ethereum/xeth".xeth·4 }
	func (@"github.com/ethereum/go-ethereum/xeth".self·3 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") @"github.com/ethereum/go-ethereum/xeth".doSign (@"github.com/ethereum/go-ethereum/xeth".from·4 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/xeth".hash·5 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/xeth".didUnlock·6 bool) (? []byte, ? error)
	func (@"github.com/ethereum/go-ethereum/xeth".self·2 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") @"github.com/ethereum/go-ethereum/xeth".getBlockByHeight (@"github.com/ethereum/go-ethereum/xeth".height·3 int64) (? *@"github.com/ethereum/go-ethereum/core/types".Block)
	func (@"github.com/ethereum/go-ethereum/xeth".self·3 *@"github.com/ethereum/go-ethereum/xeth".XEth "esc:0x9") @"github.com/ethereum/go-ethereum/xeth".sign (@"github.com/ethereum/go-ethereum/xeth".tx·4 *@"github.com/ethereum/go-ethereum/core/types".Transaction "esc:0x1a", @"github.com/ethereum/go-ethereum/xeth".from·5 @"github.com/ethereum/go-ethereum/common".Address, @"github.com/ethereum/go-ethereum/xeth".didUnlock·6 bool) (? *@"github.com/ethereum/go-ethereum/core/types".Transaction, ? error)
	func (@"github.com/ethereum/go-ethereum/xeth".self·1 *@"github.com/ethereum/go-ethereum/xeth".XEth) @"github.com/ethereum/go-ethereum/xeth".start ()
	func @"".GetNotice (@"".xeth·2 *@"github.com/ethereum/go-ethereum/xeth".XEth, @"".tx·3 string, @"".http·4 *@"github.com/ethereum/go-ethereum/common/httpclient".HTTPClient) (@"".notice·1 string)
	func @"".New (@"".xeth·3 *@"github.com/ethereum/go-ethereum/xeth".XEth, @"".jsontx·4 string, @"".http·5 *@"github.com/ethereum/go-ethereum/common/httpclient".HTTPClient) (@"".self·1 *@"".NatSpec, @"".err·2 error)
	func @"".FetchDocsForContract (@"".contractAddress·3 string, @"".xeth·4 *@"github.com/ethereum/go-ethereum/xeth".XEth, @"".client·5 *@"github.com/ethereum/go-ethereum/common/httpclient".HTTPClient) (@"".content·1 []byte, @"".err·2 error)
	func @"".NewWithDocs (@"".infoDoc·3 []byte, @"".tx·4 string, @"".data·5 string) (@"".self·1 *@"".NatSpec, @"".err·2 error)
	func @"".init ()
	type @"reflect".imethod struct { @"reflect".name *string; @"reflect".pkgPath *string; @"reflect".typ *@"reflect".rtype }
	type @"reflect".interfaceType struct { @"reflect".? @"reflect".rtype "reflect:\"interface\""; @"reflect".methods []@"reflect".imethod }
	func (@"reflect".t·2 *@"reflect".interfaceType "esc:0x32") Method (@"reflect".i·3 int) (@"reflect".m·1 @"reflect".Method) { if @"reflect".i·3 < 0x0 || @"reflect".i·3 >= len(@"reflect".t·2.@"reflect".methods) { return  }; var @"reflect".p·4 *@"reflect".imethod; ; @"reflect".p·4 = &@"reflect".t·2.@"reflect".methods[@"reflect".i·3]; @"reflect".m·1.Name = *@"reflect".p·4.@"reflect".name; if @"reflect".p·4.@"reflect".pkgPath != nil { @"reflect".m·1.PkgPath = *@"reflect".p·4.@"reflect".pkgPath }; @"reflect".m·1.Type = @"reflect".toType(@"reflect".p·4.@"reflect".typ); @"reflect".m·1.Index = @"reflect".i·3; return  }
	func (@"reflect".t·3 *@"reflect".interfaceType "esc:0x32") MethodByName (@"reflect".name·4 string "esc:0x1") (@"reflect".m·1 @"reflect".Method, @"reflect".ok·2 bool)
	func (@"reflect".t·2 *@"reflect".interfaceType "esc:0x1") NumMethod () (? int) { return len(@"reflect".t·2.@"reflect".methods) }
	import unsafe "unsafe" // indirect
	func @"github.com/robertkrimen/otto".isArray (@"github.com/robertkrimen/otto".object·2 *@"github.com/robertkrimen/otto"._object "esc:0x1") (? bool) { return @"github.com/robertkrimen/otto".object·2 != nil && (@"github.com/robertkrimen/otto".object·2.@"github.com/robertkrimen/otto".class == "Array" || @"github.com/robertkrimen/otto".object·2.@"github.com/robertkrimen/otto".class == "GoArray") }
	type @"github.com/robertkrimen/otto"._propertyGetSet [2]*@"github.com/robertkrimen/otto"._object
	type @"github.com/robertkrimen/otto"._propertyReference struct { @"github.com/robertkrimen/otto".name string; @"github.com/robertkrimen/otto".strict bool; @"github.com/robertkrimen/otto".base *@"github.com/robertkrimen/otto"._object; @"github.com/robertkrimen/otto".runtime *@"github.com/robertkrimen/otto"._runtime; @"github.com/robertkrimen/otto".at @"github.com/robertkrimen/otto"._at }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._propertyReference "esc:0x9") @"github.com/robertkrimen/otto".delete () (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._propertyReference "esc:0x9") @"github.com/robertkrimen/otto".getValue () (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._propertyReference "esc:0x1") @"github.com/robertkrimen/otto".invalid () (? bool) { return @"github.com/robertkrimen/otto".self·2.@"github.com/robertkrimen/otto".base == nil }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._propertyReference "esc:0x2a") @"github.com/robertkrimen/otto".putValue (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) (? string)
	func @"github.com/robertkrimen/otto".newPropertyReference (@"github.com/robertkrimen/otto".rt·2 *@"github.com/robertkrimen/otto"._runtime, @"github.com/robertkrimen/otto".base·3 *@"github.com/robertkrimen/otto"._object, @"github.com/robertkrimen/otto".name·4 string, @"github.com/robertkrimen/otto".strict·5 bool, @"github.com/robertkrimen/otto".at·6 @"github.com/robertkrimen/otto"._at) (? *@"github.com/robertkrimen/otto"._propertyReference) { return (&@"github.com/robertkrimen/otto"._propertyReference{ @"github.com/robertkrimen/otto".runtime:@"github.com/robertkrimen/otto".rt·2, @"github.com/robertkrimen/otto".name:@"github.com/robertkrimen/otto".name·4, @"github.com/robertkrimen/otto".strict:@"github.com/robertkrimen/otto".strict·5, @"github.com/robertkrimen/otto".base:@"github.com/robertkrimen/otto".base·3, @"github.com/robertkrimen/otto".at:@"github.com/robertkrimen/otto".at·6 }) }
	type @"github.com/robertkrimen/otto"._stashReference struct { @"github.com/robertkrimen/otto".name string; @"github.com/robertkrimen/otto".strict bool; @"github.com/robertkrimen/otto".base @"github.com/robertkrimen/otto"._stash }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._stashReference "esc:0x9") @"github.com/robertkrimen/otto".delete () (? bool)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._stashReference "esc:0x9") @"github.com/robertkrimen/otto".getValue () (? @"github.com/robertkrimen/otto".Value)
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._stashReference "esc:0x1") @"github.com/robertkrimen/otto".invalid () (? bool) { return false }
	func (@"github.com/robertkrimen/otto".self·2 *@"github.com/robertkrimen/otto"._stashReference "esc:0x9") @"github.com/robertkrimen/otto".putValue (@"github.com/robertkrimen/otto".value·3 @"github.com/robertkrimen/otto".Value) (? string)
	var @"time".months [12]string
	var @"time".days [7]string
	var @"time".Local *@"time".Location
	var @"time".UTC *@"time".Location
	func @"github.com/robertkrimen/otto".NaNValue () (? @"github.com/robertkrimen/otto".Value) { return (@"github.com/robertkrimen/otto".Value{ @"github.com/robertkrimen/otto".kind:@"github.com/robertkrimen/otto"._valueKind(0x2), @"github.com/robertkrimen/otto".value:@"github.com/robertkrimen/otto".__NaN__ }) }
	var @"regexp/syntax".instOpNames []string
	func @"strings".HasPrefix (@"strings".s·2 string "esc:0x1", @"strings".prefix·3 string "esc:0x1") (? bool) { return len(@"strings".s·2) >= len(@"strings".prefix·3) && @"strings".s·2[0x0:len(@"strings".prefix·3)] == @"strings".prefix·3 }
	func @"github.com/robertkrimen/otto".valueOfArrayIndex (@"github.com/robertkrimen/otto".array·2 []@"github.com/robertkrimen/otto".Value "esc:0x22", @"github.com/robertkrimen/otto".index·3 int) (? @"github.com/robertkrimen/otto".Value) { var @"github.com/robertkrimen/otto".value·4 @"github.com/robertkrimen/otto".Value; ; @"github.com/robertkrimen/otto".value·4, _ = @"github.com/robertkrimen/otto".getValueOfArrayIndex(@"github.com/robertkrimen/otto".array·2, @"github.com/robertkrimen/otto".index·3); return @"github.com/robertkrimen/otto".value·4 }
	func @"github.com/robertkrimen/otto".getValueOfArrayIndex (@"github.com/robertkrimen/otto".array·3 []@"github.com/robertkrimen/otto".Value "esc:0x22", @"github.com/robertkrimen/otto".index·4 int) (? @"github.com/robertkrimen/otto".Value, ? bool) { if @"github.com/robertkrimen/otto".index·4 >= 0x0 && @"github.com/robertkrimen/otto".index·4 < len(@"github.com/robertkrimen/otto".array·3) { var @"github.com/robertkrimen/otto".value·5 @"github.com/robertkrimen/otto".Value; ; @"github.com/robertkrimen/otto".value·5 = @"github.com/robertkrimen/otto".array·3[@"github.com/robertkrimen/otto".index·4]; if !@"github.com/robertkrimen/otto".value·5.@"github.com/robertkrimen/otto".isEmpty() { return @"github.com/robertkrimen/otto".value·5, true } }; return (@"github.com/robertkrimen/otto".Value{  }), false }
	func @"github.com/robertkrimen/otto".newScope (@"github.com/robertkrimen/otto".lexical·2 @"github.com/robertkrimen/otto"._stash, @"github.com/robertkrimen/otto".variable·3 @"github.com/robertkrimen/otto"._stash, @"github.com/robertkrimen/otto".this·4 *@"github.com/robertkrimen/otto"._object) (? *@"github.com/robertkrimen/otto"._scope) { return (&@"github.com/robertkrimen/otto"._scope{ @"github.com/robertkrimen/otto".lexical:@"github.com/robertkrimen/otto".lexical·2, @"github.com/robertkrimen/otto".variable:@"github.com/robertkrimen/otto".variable·3, @"github.com/robertkrimen/otto".this:@"github.com/robertkrimen/otto".this·4 }) }
	func @"github.com/robertkrimen/otto".newObject (@"github.com/robertkrimen/otto".runtime·2 *@"github.com/robertkrimen/otto"._runtime, @"github.com/robertkrimen/otto".class·3 string) (? *@"github.com/robertkrimen/otto"._object) { var @"github.com/robertkrimen/otto".self·4 *@"github.com/robertkrimen/otto"._object; ; @"github.com/robertkrimen/otto".self·4 = (&@"github.com/robertkrimen/otto"._object{ @"github.com/robertkrimen/otto".runtime:@"github.com/robertkrimen/otto".runtime·2, @"github.com/robertkrimen/otto".class:@"github.com/robertkrimen/otto".class·3, @"github.com/robertkrimen/otto".objectClass:@"github.com/robertkrimen/otto"._classObject, @"github.com/robertkrimen/otto".property:make(map[string]@"github.com/robertkrimen/otto"._property), @"github.com/robertkrimen/otto".extensible:true }); return @"github.com/robertkrimen/otto".self·4 }
	type @"sync".rlocker struct { @"sync".w @"sync".Mutex; @"sync".writerSem uint32; @"sync".readerSem uint32; @"sync".readerCount int32; @"sync".readerWait int32 }
	func (@"sync".r·1 *@"sync".rlocker) Lock ()
	func (@"sync".r·1 *@"sync".rlocker) Unlock ()
	func @"math/big".low64 (@"math/big".z·2 @"math/big".nat "esc:0x1") (? uint64) { if len(@"math/big".z·2) == 0x0 { return 0x0 }; var @"math/big".v·3 uint64; ; @"math/big".v·3 = uint64(@"math/big".z·2[0x0]); if false && len(@"math/big".z·2) > 0x1 { @"math/big".v·3 |= uint64(@"math/big".z·2[0x1]) << 0x20 }; return @"math/big".v·3 }
	func @"github.com/ethereum/go-ethereum/common".BytesToHash (@"github.com/ethereum/go-ethereum/common".b·2 []byte "esc:0x9") (? @"github.com/ethereum/go-ethereum/common".Hash) { var @"github.com/ethereum/go-ethereum/common".h·3 @"github.com/ethereum/go-ethereum/common".Hash; ; @"github.com/ethereum/go-ethereum/common".h·3.SetBytes(@"github.com/ethereum/go-ethereum/common".b·2); return @"github.com/ethereum/go-ethereum/common".h·3 }
	var @"github.com/ethereum/go-ethereum/rlp".ErrElemTooLarge error
	var @"github.com/ethereum/go-ethereum/rlp".ErrValueTooLarge error
	var @"crypto".hashes []func() (? @"hash".Hash)
	func @"net".IPv4 (@"net".a·2 byte, @"net".b·3 byte, @"net".c·4 byte, @"net".d·5 byte) (? @"net".IP) { var @"net".p·6 @"net".IP; ; @"net".p·6 = make(@"net".IP, 0x10); copy(@"net".p·6, @"net".v4InV6Prefix); @"net".p·6[0xc] = @"net".a·2; @"net".p·6[0xd] = @"net".b·3; @"net".p·6[0xe] = @"net".c·4; @"net".p·6[0xf] = @"net".d·5; return @"net".p·6 }
	import errors "errors" // indirect
	func @"errors".New (@"errors".text·2 string) (? error) { return (&@"errors".errorString{ @"errors".s:@"errors".text·2 }) }
	func @"github.com/ethereum/go-ethereum/trie".NewIterator (@"github.com/ethereum/go-ethereum/trie".trie·2 *@"github.com/ethereum/go-ethereum/trie".Trie) (? *@"github.com/ethereum/go-ethereum/trie".Iterator) { return (&@"github.com/ethereum/go-ethereum/trie".Iterator{ @"github.com/ethereum/go-ethereum/trie".trie:@"github.com/ethereum/go-ethereum/trie".trie·2, Key:nil }) }
	var @"github.com/ethereum/go-ethereum/trie".secureKeyPrefix []byte
	func @"github.com/ethereum/go-ethereum/common".CopyBytes (@"github.com/ethereum/go-ethereum/common".b·2 []byte "esc:0x9") (@"github.com/ethereum/go-ethereum/common".copiedBytes·1 []byte) { @"github.com/ethereum/go-ethereum/common".copiedBytes·1 = make([]byte, len(@"github.com/ethereum/go-ethereum/common".b·2)); copy(@"github.com/ethereum/go-ethereum/common".copiedBytes·1, @"github.com/ethereum/go-ethereum/common".b·2); return  }
	import binary "encoding/binary" // indirect
	type @"encoding/binary".bigEndian struct {}
	func (? @"encoding/binary".bigEndian) GoString () (? string) { return "binary.BigEndian" }
	func (? @"encoding/binary".bigEndian) PutUint16 (@"encoding/binary".b·1 []byte "esc:0x1", @"encoding/binary".v·2 uint16) { @"encoding/binary".b·1[0x0] = byte(@"encoding/binary".v·2 >> 0x8); @"encoding/binary".b·1[0x1] = byte(@"encoding/binary".v·2) }
	func (? @"encoding/binary".bigEndian) PutUint32 (@"encoding/binary".b·1 []byte "esc:0x1", @"encoding/binary".v·2 uint32) { @"encoding/binary".b·1[0x0] = byte(@"encoding/binary".v·2 >> 0x18); @"encoding/binary".b·1[0x1] = byte(@"encoding/binary".v·2 >> 0x10); @"encoding/binary".b·1[0x2] = byte(@"encoding/binary".v·2 >> 0x8); @"encoding/binary".b·1[0x3] = byte(@"encoding/binary".v·2) }
	func (? @"encoding/binary".bigEndian) PutUint64 (@"encoding/binary".b·1 []byte "esc:0x1", @"encoding/binary".v·2 uint64) { @"encoding/binary".b·1[0x0] = byte(@"encoding/binary".v·2 >> 0x38); @"encoding/binary".b·1[0x1] = byte(@"encoding/binary".v·2 >> 0x30); @"encoding/binary".b·1[0x2] = byte(@"encoding/binary".v·2 >> 0x28); @"encoding/binary".b·1[0x3] = byte(@"encoding/binary".v·2 >> 0x20); @"encoding/binary".b·1[0x4] = byte(@"encoding/binary".v·2 >> 0x18); @"encoding/binary".b·1[0x5] = byte(@"encoding/binary".v·2 >> 0x10); @"encoding/binary".b·1[0x6] = byte(@"encoding/binary".v·2 >> 0x8); @"encoding/binary".b·1[0x7] = byte(@"encoding/binary".v·2) }
	func (? @"encoding/binary".bigEndian) String () (? string) { return "BigEndian" }
	func (? @"encoding/binary".bigEndian) Uint16 (@"encoding/binary".b·2 []byte "esc:0x1") (? uint16) { return uint16(@"encoding/binary".b·2[0x1]) | uint16(@"encoding/binary".b·2[0x0]) << 0x8 }
	func (? @"encoding/binary".bigEndian) Uint32 (@"encoding/binary".b·2 []byte "esc:0x1") (? uint32) { return uint32(@"encoding/binary".b·2[0x3]) | uint32(@"encoding/binary".b·2[0x2]) << 0x8 | uint32(@"encoding/binary".b·2[0x1]) << 0x10 | uint32(@"encoding/binary".b·2[0x0]) << 0x18 }
	func (? @"encoding/binary".bigEndian) Uint64 (@"encoding/binary".b·2 []byte "esc:0x1") (? uint64) { return uint64(@"encoding/binary".b·2[0x7]) | uint64(@"encoding/binary".b·2[0x6]) << 0x8 | uint64(@"encoding/binary".b·2[0x5]) << 0x10 | uint64(@"encoding/binary".b·2[0x4]) << 0x18 | uint64(@"encoding/binary".b·2[0x3]) << 0x20 | uint64(@"encoding/binary".b·2[0x2]) << 0x28 | uint64(@"encoding/binary".b·2[0x1]) << 0x30 | uint64(@"encoding/binary".b·2[0x0]) << 0x38 }
	var @"encoding/binary".BigEndian @"encoding/binary".bigEndian
	func @"gopkg.in/karalabe/cookiejar.v2/collections/prque".newSstack () (? *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".sstack) { var @"gopkg.in/karalabe/cookiejar.v2/collections/prque".result·2 *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".sstack; ; @"gopkg.in/karalabe/cookiejar.v2/collections/prque".result·2 = new(@"gopkg.in/karalabe/cookiejar.v2/collections/prque".sstack); @"gopkg.in/karalabe/cookiejar.v2/collections/prque".result·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".active = make([]*@"gopkg.in/karalabe/cookiejar.v2/collections/prque".item, 0x1000); @"gopkg.in/karalabe/cookiejar.v2/collections/prque".result·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".blocks = ([][]*@"gopkg.in/karalabe/cookiejar.v2/collections/prque".item{ 0x0:@"gopkg.in/karalabe/cookiejar.v2/collections/prque".result·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".active }); @"gopkg.in/karalabe/cookiejar.v2/collections/prque".result·2.@"gopkg.in/karalabe/cookiejar.v2/collections/prque".capacity = 0x1000; return @"gopkg.in/karalabe/cookiejar.v2/collections/prque".result·2 }
	func @"gopkg.in/karalabe/cookiejar.v2/collections/prque".New () (? *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque) { return (&@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque{ @"gopkg.in/karalabe/cookiejar.v2/collections/prque".cont:@"gopkg.in/karalabe/cookiejar.v2/collections/prque".newSstack() }) }
	type @"github.com/ethereum/go-ethereum/trie".TrieSync struct { @"github.com/ethereum/go-ethereum/trie".database @"github.com/ethereum/go-ethereum/ethdb".Database; @"github.com/ethereum/go-ethereum/trie".requests map[@"github.com/ethereum/go-ethereum/common".Hash]*@"github.com/ethereum/go-ethereum/trie".request; @"github.com/ethereum/go-ethereum/trie".queue *@"gopkg.in/karalabe/cookiejar.v2/collections/prque".Prque }
	func (@"github.com/ethereum/go-ethereum/trie".s·1 *@"github.com/ethereum/go-ethereum/trie".TrieSync "esc:0x9") AddRawEntry (@"github.com/ethereum/go-ethereum/trie".hash·2 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/trie".depth·3 int, @"github.com/ethereum/go-ethereum/trie".parent·4 @"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/trie".s·1 *@"github.com/ethereum/go-ethereum/trie".TrieSync "esc:0x9") AddSubTrie (@"github.com/ethereum/go-ethereum/trie".root·2 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/trie".depth·3 int, @"github.com/ethereum/go-ethereum/trie".parent·4 @"github.com/ethereum/go-ethereum/common".Hash, @"github.com/ethereum/go-ethereum/trie".callback·5 @"github.com/ethereum/go-ethereum/trie".TrieSyncLeafCallback)
	func (@"github.com/ethereum/go-ethereum/trie".s·2 *@"github.com/ethereum/go-ethereum/trie".TrieSync "esc:0x9") Missing (@"github.com/ethereum/go-ethereum/trie".max·3 int) (? []@"github.com/ethereum/go-ethereum/common".Hash)
	func (@"github.com/ethereum/go-ethereum/trie".s·2 *@"github.com/ethereum/go-ethereum/trie".TrieSync "esc:0x1") Pending () (? int) { return len(@"github.com/ethereum/go-ethereum/trie".s·2.@"github.com/ethereum/go-ethereum/trie".requests) }
	func (@"github.com/ethereum/go-ethereum/trie".s·3 *@"github.com/ethereum/go-ethereum/trie".TrieSync "esc:0x9") Process (@"github.com/ethereum/go-ethereum/trie".results·4 []@"github.com/ethereum/go-ethereum/trie".SyncResult "esc:0x9") (? int, ? error)
	func (@"github.com/ethereum/go-ethereum/trie".s·3 *@"github.com/ethereum/go-ethereum/trie".TrieSync "esc:0x9") @"github.com/ethereum/go-ethereum/trie".children (@"github.com/ethereum/go-ethereum/trie".req·4 *@"github.com/ethereum/go-ethereum/trie".request) (? []*@"github.com/ethereum/go-ethereum/trie".request, ? error)
	func (@"github.com/ethereum/go-ethereum/trie".s·2 *@"github.com/ethereum/go-ethereum/trie".TrieSync "esc:0x9") @"github.com/ethereum/go-ethereum/trie".commit (@"github.com/ethereum/go-ethereum/trie".req·3 *@"github.com/ethereum/go-ethereum/trie".request, @"github.com/ethereum/go-ethereum/trie".batch·4 @"github.com/ethereum/go-ethereum/ethdb".Batch) (@"github.com/ethereum/go-ethereum/trie".err·1 error)
	func (@"github.com/ethereum/go-ethereum/trie".s·1 *@"github.com/ethereum/go-ethereum/trie".TrieSync "esc:0x9") @"github.com/ethereum/go-ethereum/trie".schedule (@"github.com/ethereum/go-ethereum/trie".req·2 *@"github.com/ethereum/go-ethereum/trie".request)
	var @"bufio".ErrInvalidUnreadByte error
	var @"bufio".ErrInvalidUnreadRune error
	var @"crypto/tls".defaultCurvePreferences []@"crypto/tls".CurveID
	import rand "crypto/rand" // indirect
	var @"crypto/rand".Reader @"io".Reader
	var @"net/http".DefaultTransport @"net/http".RoundTripper
	func @"github.com/ethereum/go-ethereum/common".EmptyValue () (? *@"github.com/ethereum/go-ethereum/common".Value) { return @"github.com/ethereum/go-ethereum/common".NewValue(([]interface {}{  })) }
	func @"github.com/ethereum/go-ethereum/common".NewValue (@"github.com/ethereum/go-ethereum/common".val·2 interface {}) (? *@"github.com/ethereum/go-ethereum/common".Value) { var @"github.com/ethereum/go-ethereum/common".t·3 interface {}; ; @"github.com/ethereum/go-ethereum/common".t·3 = @"github.com/ethereum/go-ethereum/common".val·2; var @"github.com/ethereum/go-ethereum/common".v·4 *@"github.com/ethereum/go-ethereum/common".Value; ; var @"github.com/ethereum/go-ethereum/common".ok·5 bool; ; @"github.com/ethereum/go-ethereum/common".v·4, @"github.com/ethereum/go-ethereum/common".ok·5 = @"github.com/ethereum/go-ethereum/common".val·2.(*@"github.com/ethereum/go-ethereum/common".Value); if @"github.com/ethereum/go-ethereum/common".ok·5 { @"github.com/ethereum/go-ethereum/common".t·3 = @"github.com/ethereum/go-ethereum/common".v·4.Val }; return (&@"github.com/ethereum/go-ethereum/common".Value{ Val:@"github.com/ethereum/go-ethereum/common".t·3 }) }
	func @"github.com/ethereum/go-ethereum/xeth".NewState (@"github.com/ethereum/go-ethereum/xeth".xeth·2 *@"github.com/ethereum/go-ethereum/xeth".XEth, @"github.com/ethereum/go-ethereum/xeth".statedb·3 *@"github.com/ethereum/go-ethereum/core/state".StateDB) (? *@"github.com/ethereum/go-ethereum/xeth".State) { return (&@"github.com/ethereum/go-ethereum/xeth".State{ @"github.com/ethereum/go-ethereum/xeth".xeth:@"github.com/ethereum/go-ethereum/xeth".xeth·2, @"github.com/ethereum/go-ethereum/xeth".state:@"github.com/ethereum/go-ethereum/xeth".statedb·3 }) }
	func @"reflect".toType (@"reflect".t·2 *@"reflect".rtype "esc:0x12") (? @"reflect".Type) { if @"reflect".t·2 == nil { return nil }; return @"reflect".t·2 }
	var @"github.com/robertkrimen/otto".__NaN__ float64
	var @"github.com/robertkrimen/otto"._classObject *@"github.com/robertkrimen/otto"._objectClass
	var @"net".v4InV6Prefix []byte
	type @"errors".errorString struct { @"errors".s string }
	func (@"errors".e·2 *@"errors".errorString "esc:0x22") Error () (? string) { return @"errors".e·2.@"errors".s }

$$
_go_.o          0           0     0     644     228979    `
go object darwin amd64 go1.5 X:none

!
  go13ldbytes.aencoding/json.a
fmt.astrings.aPgithub.com/ethereum/go-ethereum/common.afgithub.com/ethereum/go-ethereum/common/httpclient.adgithub.com/ethereum/go-ethereum/common/registrar.aPgithub.com/ethereum/go-ethereum/crypto.aLgithub.com/ethereum/go-ethereum/xeth.a<github.com/robertkrimen/otto.a "".GetNotice    eH%    HD$H;AN  H   11H$   H$   H$   H$H$   H\$H$   H\$H$   H\$    HL$ HD$(HT$0HT$@HD$8H c  1H9,  1H\$XH\$`H\$XH 
  HǄ$      HǄ$      H\$xH$HT$    HL$HD$H\$xHL$HHHD$P=        HCH    H$HD$&   H\$xH\$H$   H\$H$   H\$     HL$(HD$0HL$hH$HD$pHD$H$   H\$H$   H\$    HL$ HD$(H$   H$   HĐ   LCL$HD$    N1H\$XH\$`H\$XH 
  HǄ$      HǄ$      H\$xH$HT$    HL$HD$H\$xHL$HHHD$P=        HCH    H$HD$   H\$xH\$H$   H\$H$   H\$     HL$(HD$0HL$hH$HD$pHD$H$   H\$H$   H\$    HL$ HD$(H$   H$   HĐ   LCL$HD$    NH$    H\$H$   H\$H$   HL$HT$ H 6  1H\$XH\$`H\$XH   HǄ$      HǄ$      H\$xHL$8H$HT$@HT$    HL$HD$H\$xHL$HHHD$P=        HCH    H$HD$   H\$xH\$H$   H\$H$   H\$     HL$(HD$0HL$hH$HD$pHD$H$   H\$H$   H\$    HL$ HD$(H$   H$   HĐ   LCL$HD$    NHĐ       ,
      
  "".New   
  runtime.convI2E    6runtime.writeBarrierEnabled     dgo.string."no NatSpec info found for contract: %v"   
  fmt.Sprintf   
  ("".getFallbackNotice   
  .runtime.writebarrierptr   
  runtime.convI2E    6runtime.writeBarrierEnabled     Hgo.string."invalid NatSpec info: %v"   	
  fmt.Sprintf   

  ("".getFallbackNotice   
  .runtime.writebarrierptr   
  ("".(*NatSpec).Notice   
  runtime.convI2E    6runtime.writeBarrierEnabled     Hgo.string."NatSpec notice error: %v"   
  fmt.Sprintf   
  ("".getFallbackNotice   
  .runtime.writebarrierptr   
  0runtime.morestack_noctxt   `  ,"".autotmp_0022  "type.interface {} "".autotmp_0021  (type.[1]interface {} "".autotmp_0019  *type.*[1]interface {} "".autotmp_0018  &type.[]interface {} "".autotmp_0017  "type.interface {} "".autotmp_0016  (type.[1]interface {} "".autotmp_0014  *type.*[1]interface {} "".autotmp_0013  &type.[]interface {} "".autotmp_0012 "type.interface {} "".autotmp_0011 o(type.[1]interface {} "".autotmp_0008 /&type.[]interface {} "".autotmp_0007  type.string "".autotmp_0006  type.string "".autotmp_0005  type.string "".autotmp_0004  type.string "".autotmp_0003  type.string "".autotmp_0002 Otype.string "".err type.error "".notice @type.string "".http 0type.*github.com/ethereum/go-ethereum/common/httpclient.HTTPClient 
"".tx type.string "".xeth  ^type.*github.com/ethereum/go-ethereum/xeth.XEth B%
  4^3L-

 0 ftjpp~jp# Tgclocals·c850c5a2fb77dc8d291a85b90724aa4c Tgclocals·993a8f687c3a43661e933cd48069a9fd   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go("".getFallbackNotice    eH%    HD$H;A  H   1H$   H$   H$   H\$XH$   H\$`H$   H\$HH$   H\$P1H$   H$   H$   H$   H$   H ;  HD$p   HD$x   H\$hH    H$H\$XH\$HD$        HL$HD$ H\$hHL$8HHD$@=        HCH    H$H\$HH\$HD$        HL$HD$ H\$hHHL$8HHD$@=     u]HCH    H$HD$$   H\$hH\$H\$pH\$H\$xH\$     HL$(HD$0H$   H$   HĠ   LCL$HD$    LCL$HD$    ,    
        type.string   
  runtime.convT2E    6runtime.writeBarrierEnabled     type.string   
  runtime.convT2E    6runtime.writeBarrierEnabled     `go.string."About to submit transaction (%s): %s"   
  fmt.Sprintf   
  .runtime.writebarrierptr   
  .runtime.writebarrierptr   
  0runtime.morestack_noctxt   `  "".autotmp_0031  "type.interface {} "".autotmp_0030 "type.interface {} "".autotmp_0029 ?(type.[2]interface {} "".autotmp_0026 o&type.[]interface {} "".autotmp_0024 type.string "".autotmp_0023 type.string "".~r2 @type.string 
"".tx  type.string "".comment  type.string G  1  4: Tgclocals·01222aa938402b47e50e7b0eb35d9e3b Tgclocals·24dad5c01c8a1c135720cc7d2d411117   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go"".New  	  	eH%    HD$H;AH  H   11H$   H$  HǄ$       H    H$    HD$HD$XHD$PH$    H$   H\$H$   H\$    H\$HH$HKHL$HKHL$HL$PH    H\$pH\$HL$xHL$     HD$(H\$0H$  H$   H tH   H\$XHHCHkH$   H$   H H$   7  H)H$   HiH$   HiH$   HiH$   H$   H$   HL$`H$HD$hHD$H$   H\$H$   H\$    HT$ HL$(HD$0Hl$8H\$@H$  H$   H tH   H$   H$H$   HL$H$   HD$H$   H\$H$   H\$ H$   H|$(HHHKHO    H\$8H$   H\$@H$   H\$HH$  H           
        type."".jsonTx   
  "runtime.newobject   
  2runtime.stringtoslicebyte     type.*"".jsonTx   
  .encoding/json.Unmarshal   
  ."".FetchDocsForContract   
  "".NewWithDocs   	
  $runtime.panicindex   	
  0runtime.morestack_noctxt   p  "".autotmp_0032 type.*"".jsonTx "".&tx type.*"".jsonTx "".content type.[]uint8 $"".contractAddress type.string "".t ?&type."".transaction "".err Ptype.error "".self @ type.*"".NatSpec "".http 0type.*github.com/ethereum/go-ethereum/common/httpclient.HTTPClient "".jsontx type.string "".xeth  ^type.*github.com/ethereum/go-ethereum/xeth.XEth 6  @?aS  J6CK Tgclocals·47f233e0263a498be5a5f839f5fbb981 Tgclocals·78cd9471839bd2c88c065c7d5732f7e8   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go."".FetchDocsForContract      eH%    H$H;A  Hh  111H$  H$  1H$  H$  H$  H$  H$H$p  H\$H$x  H\$    H\$H$   H\$ H$  H$  H$H$p  H\$H$x  H\$    H$  H\$H$  H\$ H$  H\$(H$  Hr  H$   H,$HD$H-    Hl$HD$       \$  9  H$p  H$  H$x  H$  1H$P  H$X  H$P  H    HǄ$@     HǄ$H     H$8  H    H$H$  H\$HD$        HL$HD$ H$8  H$@  HH$H  =     ufHCH    H$HD$   H$8  H\$H$@  H\$H$H  H\$     H\$(H$  H\$0H$  Hh  LCL$HD$    늉1H$  H$  H$  H$  H j  HǄ$(     HǄ$0     H$   H$  HhH$  HhH$  =       H(H$H$(  H\$H$0  H\$    HT$Hl$ HL$(H|$`1    H$   1    H$   HH$  H$  HH$  H }  HH HIH9`  H)I)II tMHLLH    H)H )  H    H)IH   H tML$P  LH$X  H$`  H$   H$  HH$  HH$  H$  H$  HH$  H9}HH$  H<$H$  Ht$HD$    H$   H|$`    Ht$`H$       H$  H$   H    1H9  H$   H$0  HH$8  1H$   H$(  H$   H   H$  HH$  HHH$   H$H$   H|$        H$   Ht$(    HD$HH\$PH$  H$  H tHh  H$  H$H    H\$HD$       \$   H$   H        HL$ H\$(H$x  H  HHH$p  H tHHH$    H    H\$HD$   H$`  Hl$H$h  HL$     H\$(H|$HHHKHOH$  H$1H\$H\$     H\$(H$  H\$0H$  H\$8H$  HD$@H\$HH$  H$  H uHh  1H$  H$  H$   H$H$   H|$        HL$(HD$0HT$8H\$@H$  H$  H tHh  H$  H$H$   HL$H$   HD$H$   H|$        H\$8H$  H\$@H$  H\$HH$  HD$PH\$XH$  H$  H tHh  Hh       =H    H$H    H\$H    H\$    HD$        H$Hl$    H$        T
      
  fgithub.com/ethereum/go-ethereum/xeth.(*XEth).CodeAt   
  pgithub.com/ethereum/go-ethereum/xeth.(*XEth).CodeAtBytes     go.string."0x"   
   runtime.eqstring     type.string   
  runtime.convT2E    6runtime.writeBarrierEnabled     Fgo.string."contract (%v) not found"   
  fmt.Errorf   	
  .runtime.writebarrierptr    6runtime.writeBarrierEnabled   
  Vgithub.com/ethereum/go-ethereum/crypto.Sha3   
	  runtime.duffzero   
	  runtime.duffzero   
  runtime.memmove   
  runtime.duffcopy   
  runtime.duffcopy     go.itab.*github.com/ethereum/go-ethereum/xeth.XEth.github.com/ethereum/go-ethereum/common/registrar.Backend   
  runtime.duffcopy   
  github.com/ethereum/go-ethereum/common/registrar.(*Registrar).HashToHash   
  runtime.duffcopy     go.string."bzz"   
  github.com/ethereum/go-ethereum/common/httpclient.(*HTTPClient).HasScheme   
  runtime.duffcopy   
  ^github.com/ethereum/go-ethereum/common.Hash.Hex     $go.string."bzz://"   
  *runtime.concatstring2   
  github.com/ethereum/go-ethereum/common/httpclient.(*HTTPClient).Get   
  runtime.duffcopy   
  github.com/ethereum/go-ethereum/common/registrar.(*Registrar).HashToUrl   
  runtime.duffcopy   
  github.com/ethereum/go-ethereum/common/httpclient.(*HTTPClient).GetAuthContent   
  $runtime.panicslice     ^type.*github.com/ethereum/go-ethereum/xeth.XEth     ztype.github.com/ethereum/go-ethereum/common/registrar.Backend     go.itab.*github.com/ethereum/go-ethereum/xeth.XEth.github.com/ethereum/go-ethereum/common/registrar.Backend   
   runtime.typ2Itab   
  $runtime.panicslice   
  $runtime.panicslice   
  .runtime.writebarrierptr    
  0runtime.morestack_noctxt   	  D"".autotmp_0064 ~type.github.com/ethereum/go-ethereum/common/registrar.Registrar "".autotmp_0061 ztype.github.com/ethereum/go-ethereum/common/registrar.Backend "".autotmp_0059  type.int "".autotmp_0058 type.[]uint8 "".autotmp_0057 type.[]uint8 "".autotmp_0056 type.[1][]uint8 "".autotmp_0053 type.[][]uint8 "".autotmp_0052 "type.interface {} "".autotmp_0051 (type.[1]interface {} "".autotmp_0048 _&type.[]interface {} "".autotmp_0047 type.string "".autotmp_0046 type.string "".autotmp_0044 ^type.*github.com/ethereum/go-ethereum/xeth.XEth "".autotmp_0043  type.[]uint8 "".autotmp_0042  type.int "".autotmp_0041  type.int "".autotmp_0037 /type.[]uint8 "".autotmp_0036 type.string jgithub.com/ethereum/go-ethereum/common/registrar.b·2 ztype.github.com/ethereum/go-ethereum/common/registrar.Backend Vgithub.com/ethereum/go-ethereum/common.b·2 type.[]uint8 "".~r0 `type.github.com/ethereum/go-ethereum/common.Hash Vgithub.com/ethereum/go-ethereum/common.h·3 `type.github.com/ethereum/go-ethereum/common.Hash Vgithub.com/ethereum/go-ethereum/common.b·2 type.[]uint8 "".uri type.string "".hash `type.github.com/ethereum/go-ethereum/common.Hash "".reg type.*github.com/ethereum/go-ethereum/common/registrar.Registrar "".codehash `type.github.com/ethereum/go-ethereum/common.Hash "".codeb type.[]uint8 "".codehex type.string "".err ptype.error "".content @type.[]uint8 "".client 0type.*github.com/ethereum/go-ethereum/common/httpclient.HTTPClient "".xeth  ^type.*github.com/ethereum/go-ethereum/xeth.XEth $"".contractAddress  type.string ^"							f						  ~REZCxG4?v#9< J xEdr4o/ Tgclocals·b807092b1eea3d28f2ad4a2ec7f54681 Tgclocals·74da45b210931fd185bef32b4a738ae5   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go"".NewWithDocs    eH%    H;aC  H   11H$   H$   HǄ$       H    H$    HL$HL$XH$   H$H$   H\$H$   HD$H    HD$`HD$HL$hHL$     HD$(H\$0H$   H$   H tHĀ       H$H\$PH    H$    HD$HD$HH [  Hl$P=     1  H(H\$XHk0H   L@LD$Hl$H-    H,$    H\$XHkHH\$HH   LC LD$Hl$H-    H,$    H\$HH$   Hk0H$   =     |  Hk(H\$HH$   Hk@H$   =     ;  Hk8H\$HH$   H    H\$pHD$x H    H$H\$pH\$HD$        H\$H|$HHHKHOH$   HHH$HKHL$    HD$8H\$@H$   H$   H tHĀ   H    H\$pHD$x!   H    H$H\$pH\$HD$        H\$H|$HHHKHOH$   HHH$HKHL$    H\$8H$   H\$@H$   HĀ   LC8L$Hl$    LC(L$Hl$    q" H$Hl$    HD$H     6
      z  (type."".contractInfo   
  "runtime.newobject     *type.*"".contractInfo   
  .encoding/json.Unmarshal   
  @github.com/robertkrimen/otto.New     type."".NatSpec   
  "runtime.newobject    6runtime.writeBarrierEnabled     :type.encoding/json.RawMessage   
  (runtime.typedmemmove     type."".userDoc   
  (runtime.typedmemmove    6runtime.writeBarrierEnabled    6runtime.writeBarrierEnabled     ""..gostring.1     type.string   
  runtime.convT2E   
  Jgithub.com/robertkrimen/otto.Otto.Run   	  Zgo.string."var natspec = require('natspec');"   
  type.string   

  runtime.convT2E   
  Jgithub.com/robertkrimen/otto.Otto.Run   
  .runtime.writebarrierptr   
  .runtime.writebarrierptr   
  .runtime.writebarrierptr   
  0runtime.morestack_noctxt     "".autotmp_0070 o type.*"".NatSpec "".autotmp_0069  type.string "".autotmp_0068 type.string "".autotmp_0067 _Ntype.*github.com/robertkrimen/otto.Otto "".&contract O*type.*"".contractInfo "".err type.error "".self p type.*"".NatSpec "".data Ptype.string 
"".tx 0type.string "".infoDoc  type.[]uint8 6e  f:]91
 . EP-Z68  Tgclocals·3ae1279d5e348d56f28cce3670b32483 Tgclocals·7cad11c35fe914c1ff5567188e681a41   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go8"".(*NatSpec).makeAbi2method    eH%    H$H;A  H  1H$   H$   H$  HǄ$      H$  Hk H$@  1    H    H$Hl$H$@  H\$    H$@  1H9  H$H  HH$@  H   HHkHD$`HT$hH$Hl$pHl$H    H\$HD$       HL$ HD$(H\$0H   H)Hl$xHiH$   1H$   H$   H$  H$   H ]  HǄ$     HǄ$      H$  H$    H\$hH\$H\$pH\$    HT$HL$ HD$(H$  H$   HKH$   HCH$   =       HH$  H$H$  H\$H$   H\$    HT$HL$ HD$(H$   H$H$   HL$H$   HD$    HL$HD$ H\$@H$H$   HL$H$   HD$    HL$H\$ H$   HD$(1@t$8@t$9@t$:@t$;@t$<@t$=@t$>@t$?Ht$8H   I   H   H$   H  H$   I   H$   L$   H$   H$   H$(  HL$0  H$8  H$   L$   LL$   M9}LH$   H4$H$   HT$HD$    H\$8H   H   H   HH$  H    H   H   H$   H<$H$   Ht$H$   Hl$H$(  H\$H$0  HT$ H$8  HL$(    \$0 tGHD$`H$  H$   HhHl$x=     uHhHĠ  L@L$Hl$    H$@  H$    H$@  1H9+HĠ  É    %H$HT$    +        =(
      
  runtime.duffzero     4type.map[string]*"".method   
  &runtime.mapiterinit     go.string."("   
  strings.Split   
  2runtime.stringtoslicebyte    6runtime.writeBarrierEnabled   
  Vgithub.com/ethereum/go-ethereum/crypto.Sha3   
  `github.com/ethereum/go-ethereum/common.Bytes2Hex   	
  2runtime.stringtoslicebyte   
  runtime.memmove   
  bytes.Equal    6runtime.writeBarrierEnabled   
  .runtime.writebarrierptr   
  &runtime.mapiternext   
  $runtime.panicslice   
  .runtime.writebarrierptr   
  $runtime.panicindex   
  0runtime.morestack_noctxt   0  *"".autotmp_0091 type.[]uint8 "".autotmp_0090 type.[]uint8 "".autotmp_0089 type.[32]uint8 "".autotmp_0088 type.[]uint8 "".autotmp_0087 type.[1][]uint8 "".autotmp_0084 type.[][]uint8 "".autotmp_0081  type.[]uint8 "".autotmp_0080  type.[]uint8 "".autotmp_0079 type.[]uint8 "".autotmp_0078  type.[]uint8 "".autotmp_0077 type.string "".autotmp_0076  type.[]uint8 "".autotmp_0074 >type.map.iter[string]*"".method "".key type.[8]uint8 "".hash type.[]uint8 "".name type.string "".m type.*"".method "".signature type.string "".meth  type.*"".method "".abiKey type.[8]uint8 "".self   type.*"".NatSpec &"?[ 	 ZHyZ*&$ , irA% Tgclocals·a1d155bd7945fa5b509c2735486d8a30 Tgclocals·0ba8541f778fa0d9212354994a24af5b   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go("".(*NatSpec).Notice    eH%    HD$H;A  H   H$   111H$   H$   1H$   H$   1ۈ\$X\$Y\$Z\$[\$\\$]\$^\$_Hi@H
}LH    H$HD$   1H\$H\$H\$     H\$(H$   H\$0H$   Hİ   H\$XH   I   H   Hi@H
  Hi8HH   H$   HL$   H$   H$   Hl$pHH|$xL$   LH|$hL9}HH$   H4$HT$`HT$HD$    H$   H$\$X\$\$Y\$	\$Z\$
\$[\$\$\\$\$]\$\$^\$\$_\$    H$   HD$1H9uLH    H$HD$!   1H\$H\$H\$     H\$(H$   H\$0H$   Hİ   H$H    HY(H|$HHHKHOH tkHXH|$HHHKHOH|$(HHHHHO    H\$8H$   H\$@H$   H\$HH$   H\$PH$   Hİ   É 둉m        %
        Hgo.string."Invalid transaction data"   
  fmt.Errorf   
  runtime.memmove   
  8"".(*NatSpec).makeAbi2method     Zgo.string."abi key does not match any method"   
  fmt.Errorf   	
  :"".(*NatSpec).noticeForMethod   
  $runtime.panicslice   
  0runtime.morestack_noctxt   P  "".autotmp_0099  type.int "".autotmp_0098 type.string "".autotmp_0097 _type.[]uint8 "".autotmp_0096 type.string "".autotmp_0095 /type.[]uint8 "".abiKey type.[8]uint8 "".err 0type.error "".notice type.string "".self   type.*"".NatSpec 6(  DO"
DfD  i Tgclocals·54204102ae5f74797e57e36f7d22edb3 Tgclocals·2d441abba90d5bffc819c5be89799912   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go:"".(*NatSpec).noticeForMethod  5  5eH%    HD$H;A+  H   111H$  H$   1H$  H$  H$    H    H\$HD$   H$   H\$H$   H\$ H    H\$(HD$0       H\$8H$   H\$@H$   H    H$H$   H\$HD$        H\$H|$HHHKHOH$   HHH$HKHL$    HL$8HT$@H$   H$  H   1H\$hH\$pH\$hH    HǄ$      HǄ$      H$   H$HT$    HL$HD$H$   HL$XHHD$`=     uxHCH    H$HD$(   H$   H\$H$   H\$H$   H\$     HL$(HD$01H$  H$  H$  H$   H   LCL$HD$    uH$   H 
  H^HH$HKHL$HKHL$    H\$H|$HHHKHOH$    H    H\$HD$
   H    H\$(HD$0       H\$8H$   H\$@H$   H    H$H$   H\$HD$        H\$H|$HHHKHOH$   HHH$HKHL$    HL$8HT$@H$   H$  H   1H\$hH\$pH\$hH    HǄ$      HǄ$      H$   H$HT$    HL$HD$H$   HL$XHHD$`=     uxHCH    H$HD$    H$   H\$H$   H\$H$   H\$     HL$(HD$01H$  H$  H$  H$   H   LCL$HD$    uH$    H    H\$HD$   H$   H\$H$   H\$ H    H\$(HD$0       H\$8H$   H\$@H$   H    H$H$   H\$HD$        H\$H|$HHHKHOH$   HHH$HKHL$    HL$8HT$@H$   H$  H   1H\$hH\$pH\$hH    HǄ$      HǄ$      H$   H$HT$    HL$HD$H$   HL$XHHD$`=     uxHCH    H$HD$#   H$   H\$H$   H\$H$   H\$     HL$(HD$01H$  H$  H$  H$   H   LCL$HD$    uH$    H    H\$HD$   H$   H\$H$   H\$ H    H\$(HD$0       H\$8H$   H\$@H$   H    H$H$   H\$HD$        H\$H|$HHHKHOH$   HHH$HKHL$    HL$8HT$@H$   H$  H   1H\$hH\$pH\$hH    HǄ$      HǄ$      H$   H$HT$    HL$HD$H$   HL$XHHD$`=     uxHCH    H$HD$'   H$   H\$H$   H\$H$   H\$     HL$(HD$01H$  H$  H$  H$   H   LCL$HD$    uH    H$   HǄ$   >   H    H$H$   H\$HD$        H\$H|$HHHKHOH$   HHH$HKHL$    H    H$   HǄ$   -   H    H$H$   H\$HD$        H\$H|$HHHKHOH$   HHH$HKHL$    Hl$ H$   HT$(H$   HD$0H$   HL$8Ht$@H$   H$  H   1H\$hH\$pH\$hH    HǄ$      HǄ$      H$   H$Ht$    HL$HD$H$   HL$XHHD$`=     uxHCH    H$HD$*   H$   H\$H$   H\$H$   H\$     HL$(HD$01H$  H$  H$  H$   H   LCL$HD$    uH    H\$HHD$P-   H,$HT$HD$    HT$PHL$HD$ H9w  HL$xH$H$   HD$Hl$HHl$HT$    \$  ?  H$   H$   H$   H$   1H\$hH\$pH\$hH    HǄ$      HǄ$      H$   H    H$H$   H\$HD$        HL$HD$ H$   HL$XHHD$`=     uxHCH    H$HD$M   H$   H\$H$   H\$H$   H\$     HL$(HD$01H$  H$  H$  H$   H   LCL$HD$    uH$   H$H$   H\$H$   H\$    H\$H\$ H u^H    H$HD$&   1H\$H\$H\$     HL$(HD$01H$  H$  H$  H$   H   H$   H$H$   H\$H$   H\$    HL$HD$ H$  H$  1H$  H$   H   É
    
        <go.string."var transaction = "     go.string.";"   
  *runtime.concatstring3     type.string   
  runtime.convT2E   
  Jgithub.com/robertkrimen/otto.Otto.Run   
  runtime.convI2E    6runtime.writeBarrierEnabled     hgo.string."natspec.js error setting transaction: %v"   
  fmt.Errorf   
  .runtime.writebarrierptr   	
  8runtime.slicebytetostringtmp   
  ,go.string."var abi = "   
  go.string.";"   

  *runtime.concatstring3     type.string   
  runtime.convT2E   
  Jgithub.com/robertkrimen/otto.Otto.Run   
  runtime.convI2E    6runtime.writeBarrierEnabled     Xgo.string."natspec.js error setting abi: %v"   
  fmt.Errorf   
  .runtime.writebarrierptr     4go.string."var method = '"     go.string."';"   
  *runtime.concatstring3     type.string   
  runtime.convT2E   
  Jgithub.com/robertkrimen/otto.Otto.Run   
  runtime.convI2E    6runtime.writeBarrierEnabled     ^go.string."natspec.js error setting method: %v"   
  fmt.Errorf   
  .runtime.writebarrierptr     >go.string."var expression = \""     go.string."\";"   
  *runtime.concatstring3     type.string   
  runtime.convT2E   
  Jgithub.com/robertkrimen/otto.Otto.Run   
  runtime.convI2E    6runtime.writeBarrierEnabled     fgo.string."natspec.js error setting expression: %v"   
  fmt.Errorf    
  .runtime.writebarrierptr   !  go.string."var call = {method: method,abi: abi,transaction: transaction};"   !  type.string   "
  runtime.convT2E   "
  Jgithub.com/robertkrimen/otto.Otto.Run   #  rgo.string."natspec.evaluateExpression(expression, call);"   #  type.string   #
  runtime.convT2E   $
  Jgithub.com/robertkrimen/otto.Otto.Run   '
  runtime.convI2E   ' 6runtime.writeBarrierEnabled   '  lgo.string."natspec.js error evaluating expression: %v"   (
  fmt.Errorf   )
  .runtime.writebarrierptr   *  rgo.string."Natspec evaluation failed, wrong input params"   *
  Rgithub.com/robertkrimen/otto.Value.String   +
   runtime.eqstring   -  type.string   .
  runtime.convT2E   . 6runtime.writeBarrierEnabled   .  go.string."natspec.js error evaluating expression: wrong input params in expression '%s'"   /
  fmt.Errorf   0
  .runtime.writebarrierptr   1
  Rgithub.com/robertkrimen/otto.Value.String   2  dgo.string."natspec.js error evaluating expression"   2
  fmt.Errorf   4
  Rgithub.com/robertkrimen/otto.Value.String   5
  0runtime.morestack_noctxt     ^"".autotmp_0148  "type.interface {} "".autotmp_0147  (type.[1]interface {} "".autotmp_0145  *type.*[1]interface {} "".autotmp_0144  &type.[]interface {} "".autotmp_0143  "type.interface {} "".autotmp_0142  (type.[1]interface {} "".autotmp_0140  *type.*[1]interface {} "".autotmp_0139  &type.[]interface {} "".autotmp_0138  "type.interface {} "".autotmp_0137  (type.[1]interface {} "".autotmp_0135  *type.*[1]interface {} "".autotmp_0134  &type.[]interface {} "".autotmp_0133  "type.interface {} "".autotmp_0132  (type.[1]interface {} "".autotmp_0130  *type.*[1]interface {} "".autotmp_0129  &type.[]interface {} "".autotmp_0128  "type.interface {} "".autotmp_0127  (type.[1]interface {} "".autotmp_0125  *type.*[1]interface {} "".autotmp_0124  &type.[]interface {} "".autotmp_0123 "type.interface {} "".autotmp_0122 (type.[1]interface {} "".autotmp_0119 /&type.[]interface {} "".autotmp_0118  type.string "".autotmp_0117  type.error "".autotmp_0115  type.string "".autotmp_0114  type.error "".autotmp_0113  type.string "".autotmp_0112 type.string "".autotmp_0111  type.error "".autotmp_0110  type.string "".autotmp_0109  type.string "".autotmp_0108  type.error "".autotmp_0107  type.string "".autotmp_0106  type.error "".autotmp_0105  type.string "".autotmp_0104  type.error "".autotmp_0103  type.string "".autotmp_0101 type.string "".evalError type.string "".value _Ntype.github.com/robertkrimen/otto.Value "".err type.error "".notice ptype.string "".expression Ptype.string "".name 0type.string 
"".tx type.string "".self   type.*"".NatSpec z^  nGyc;^_1  @lF@lF]@lF]@lFMlF4BlF7:	 Tgclocals·667457f8ddc6c4dfd61b70c4fca21bb8 Tgclocals·d7e3fc7369d255717fb96672f86fbe64   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go"".init    eH%    H;ava     t    u                                                        "
      $  "".initdone·   <  "".initdone·   R
  "runtime.throwinit   b "".initdone·   n
  bytes.init   x
  $encoding/json.init   
  fmt.init   
  strings.init   
  Vgithub.com/ethereum/go-ethereum/common.init   
  lgithub.com/ethereum/go-ethereum/common/httpclient.init   
  jgithub.com/ethereum/go-ethereum/common/registrar.init   
  Vgithub.com/ethereum/go-ethereum/crypto.init   
  Rgithub.com/ethereum/go-ethereum/xeth.init   
  Bgithub.com/robertkrimen/otto.init    "".initdone·   
  0runtime.morestack_noctxt          
> 
 (X Tgclocals·33cdeccccebe80329f1fdbee7f5874cb Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec_js.go(type..hash."".method   eH%    H;avmHH\$ H$H<$ tPH\$(H\$    HD$H\$ H$H<$ t#H$HD$(HD$    H\$H\$0HÉ%    ԉ%        z
      \
  runtime.strhash   
  runtime.strhash   
  0runtime.morestack_noctxt   00  "".~r2  type.uintptr "".h type.uintptr "".p  type.*"".method 0V/0&   
 -c Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go$type..eq."".method   eH%    H;a  HHH\$PH    H3HKH\$XH    HHCH9   Ht$8H4$HL$@HL$HT$(HT$HD$0HD$    \$  t}H\$PH tnHSHCH\$XH tWHsHKH9u@HT$(H$HD$0HD$Ht$8Ht$HL$@HL$    \$  t
D$`HHD$` HHÉ륉D$` HHÉ,    
      
   runtime.eqstring   
   runtime.eqstring   
  0runtime.morestack_noctxt   0  "".autotmp_0152  type.string "".autotmp_0151  type.string "".autotmp_0150 ?type.string "".autotmp_0149 type.string "".~r2  type.bool "".q type.*"".method "".p  type.*"".method 2	'    s Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go(type..hash.[8]string   eH%    H;a   H(HL$81HD$   Hl$H9}\HD$ HHHHckR HHH\$0H t;HHH$HD$8HD$    HL$HD$ HHl$H9|HL$@H(É    [
      
  runtime.strhash   
  0runtime.morestack_noctxt   0P  
"".autotmp_0154 type.int "".autotmp_0153 type.int "".~r2  type.uintptr "".h type.uintptr "".p  type.*[8]string POP   
 q? Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go$type..eq.[8]string   eH%    H;a   HX1HD$(   Hl$(H9   HD$0H\$`H    HHHH3HKH\$hH tvHHHHHCH9uVHt$HH4$HL$PHL$HT$8HT$HD$@HD$    \$  t HD$0HHl$(H9nD$pHXD$p HXÉ놉c    
      
   runtime.eqstring   
  0runtime.morestack_noctxt   0  "".autotmp_0158 ?type.string "".autotmp_0157 type.string "".autotmp_0156 _type.int "".autotmp_0155 Otype.int "".~r2  type.bool "".q type.*[8]string "".p  type.*[8]string &	    S Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go4type..hash.[1]interface {}   eH%    H;a   H(HL$81HD$   Hl$H9}\HD$ HHHHckR HHH\$0H t;HHH$HD$8HD$    HL$HD$ HHl$H9|HL$@H(É    [
      
  (runtime.nilinterhash   
  0runtime.morestack_noctxt   0P  
"".autotmp_0160 type.int "".autotmp_0159 type.int "".~r2  type.uintptr "".h type.uintptr "".p  *type.*[1]interface {} POP   
 q? Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go0type..eq.[1]interface {}   eH%    H;a   HX1HD$(   Hl$(H9   HD$0H\$hH    HHHHHsH\$`H tvHHHHHSH9uVHD$8H$HT$@HT$HL$HHL$Ht$PHt$    \$  t HD$0HHl$(H9nD$pHXD$p HXÉ놉c    
      
  runtime.efaceeq   
  0runtime.morestack_noctxt   0  "".autotmp_0164 ?"type.interface {} "".autotmp_0163 "type.interface {} "".autotmp_0162 _type.int "".autotmp_0161 Otype.int "".~r2  type.bool "".q *type.*[1]interface {} "".p  *type.*[1]interface {} &	    S Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go4type..hash.[2]interface {}   eH%    H;a   H(HL$81HD$   Hl$H9}\HD$ HHHHckR HHH\$0H t;HHH$HD$8HD$    HL$HD$ HHl$H9|HL$@H(É    [
      
  (runtime.nilinterhash   
  0runtime.morestack_noctxt   0P  
"".autotmp_0166 type.int "".autotmp_0165 type.int "".~r2  type.uintptr "".h type.uintptr "".p  *type.*[2]interface {} POP   
 q? Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go0type..eq.[2]interface {}   eH%    H;a   HX1HD$(   Hl$(H9   HD$0H\$hH    HHHHHsH\$`H tvHHHHHSH9uVHD$8H$HT$@HT$HL$HHL$Ht$PHt$    \$  t HD$0HHl$(H9nD$pHXD$p HXÉ놉c    
      
  runtime.efaceeq   
  0runtime.morestack_noctxt   0  "".autotmp_0170 ?"type.interface {} "".autotmp_0169 "type.interface {} "".autotmp_0168 _type.int "".autotmp_0167 Otype.int "".~r2  type.bool "".q *type.*[2]interface {} "".p  *type.*[2]interface {} &	    S Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go2type..hash."".transaction   eH%    H;avmHH\$ H$H<$ tPH\$(H\$    HD$H\$ H$H<$ t#H$HD$(HD$    H\$H\$0HÉ%    ԉ%        z
      \
  runtime.strhash   
  runtime.strhash   
  0runtime.morestack_noctxt   00  "".~r2  type.uintptr "".h type.uintptr "".p  (type.*"".transaction 0V/0&   
 -c Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.go.type..eq."".transaction   eH%    H;a  HHH\$PH    H3HKH\$XH    HHCH9   Ht$8H4$HL$@HL$HT$(HT$HD$0HD$    \$  t}H\$PH tnHSHCH\$XH tWHsHKH9u@HT$(H$HD$0HD$Ht$8Ht$HL$@HL$    \$  t
D$`HHD$` HHÉ륉D$` HHÉ,    
      
   runtime.eqstring   
   runtime.eqstring   
  0runtime.morestack_noctxt   0  "".autotmp_0174  type.string "".autotmp_0173  type.string "".autotmp_0172 ?type.string "".autotmp_0171 type.string "".~r2  type.bool "".q (type.*"".transaction "".p  (type.*"".transaction 2	'    s Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /Users/jeffrey/go/src/github.com/ethereum/go-ethereum/build/_workspace/src/github.com/ethereum/go-ethereum/common/natspec/natspec.golgo.string.hdr."no NatSpec info found for contract: %v"             &          dgo.string."no NatSpec info found for contract: %v"   dgo.string."no NatSpec info found for contract: %v" P  Nno NatSpec info found for contract: %v  Pgo.string.hdr."invalid NatSpec info: %v"                       Hgo.string."invalid NatSpec info: %v"   Hgo.string."invalid NatSpec info: %v" @  2invalid NatSpec info: %v  Pgo.string.hdr."NatSpec notice error: %v"                       Hgo.string."NatSpec notice error: %v"   Hgo.string."NatSpec notice error: %v" @  2NatSpec notice error: %v  Tgclocals·993a8f687c3a43661e933cd48069a9fd (  (          0  0    Tgclocals·c850c5a2fb77dc8d291a85b90724aa4c (  (                hgo.string.hdr."About to submit transaction (%s): %s"             $          `go.string."About to submit transaction (%s): %s"   `go.string."About to submit transaction (%s): %s" P  JAbout to submit transaction (%s): %s  Tgclocals·24dad5c01c8a1c135720cc7d2d411117 (  (          T     Tgclocals·01222aa938402b47e50e7b0eb35d9e3b (  (                Tgclocals·78cd9471839bd2c88c065c7d5732f7e8 8  8                     P   Tgclocals·47f233e0263a498be5a5f839f5fbb981 8  8                      0go.itab.*github.com/ethereum/go-ethereum/xeth.XEth.github.com/ethereum/go-ethereum/common/registrar.Backend     $go.string.hdr."0x"                       go.string."0x"   go.string."0x"   0x  Ngo.string.hdr."contract (%v) not found"                       Fgo.string."contract (%v) not found"   Fgo.string."contract (%v) not found" 0  0contract (%v) not found  &go.string.hdr."bzz"                       go.string."bzz"   go.string."bzz"   bzz  ,go.string.hdr."bzz://"                       $go.string."bzz://"   $go.string."bzz://"   bzz://  Tgclocals·74da45b210931fd185bef32b4a738ae5      1                            @                                                                         Tgclocals·b807092b1eea3d28f2ad4a2ec7f54681      	                                              $"".hdr..gostring.1                     ""..gostring.1   ""..gostring.1   
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
/*
    This file is part of ethereum.js.

    ethereum.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ethereum.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with ethereum.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file abi.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Gav Wood <g@ethdev.com>
 * @date 2014
 */

var utils = require('../utils/utils');
var c = require('../utils/config');
var types = require('./types');
var f = require('./formatters');
var solUtils = require('./utils');

/**
 * throw incorrect type error
 *
 * @method throwTypeError
 * @param {String} type
 * @throws incorrect type error
 */
var throwTypeError = function (type) {
    throw new Error('parser does not support type: ' + type);
};

/** This method should be called if we want to check if givent type is an array type
 *
 * @method isArrayType
 * @param {String} type name
 * @returns {Boolean} true if it is, otherwise false
 */
var isArrayType = function (type) {
    return type.slice(-2) === '[]';
};

/**
 * This method should be called to return dynamic type length in hex
 *
 * @method dynamicTypeBytes
 * @param {String} type
 * @param {String|Array} dynamic type
 * @return {String} length of dynamic type in hex or empty string if type is not dynamic
 */
var dynamicTypeBytes = function (type, value) {
    // TODO: decide what to do with array of strings
    if (isArrayType(type) || type === 'bytes')
        return f.formatInputInt(value.length);
    return "";
};

var inputTypes = types.inputTypes();

/**
 * Formats input params to bytes
 *
 * @method formatInput
 * @param {Array} abi inputs of method
 * @param {Array} params that will be formatted to bytes
 * @returns bytes representation of input params
 */
var formatInput = function (inputs, params) {
    var bytes = "";
    var toAppendConstant = "";
    var toAppendArrayContent = "";

    /// first we iterate in search for dynamic
    inputs.forEach(function (input, index) {
        bytes += dynamicTypeBytes(input.type, params[index]);
    });

    inputs.forEach(function (input, i) {
        /*jshint maxcomplexity:5 */
        var typeMatch = false;
        for (var j = 0; j < inputTypes.length && !typeMatch; j++) {
            typeMatch = inputTypes[j].type(inputs[i].type, params[i]);
        }
        if (!typeMatch) {
            throwTypeError(inputs[i].type);
        }

        var formatter = inputTypes[j - 1].format;

        if (isArrayType(inputs[i].type))
            toAppendArrayContent += params[i].reduce(function (acc, curr) {
                return acc + formatter(curr);
            }, "");
        else if (inputs[i].type === 'bytes')
            toAppendArrayContent += formatter(params[i]);
        else
            toAppendConstant += formatter(params[i]);
    });

    bytes += toAppendConstant + toAppendArrayContent;

    return bytes;
};

/**
 * This method should be called to predict the length of dynamic type
 *
 * @method dynamicBytesLength
 * @param {String} type
 * @returns {Number} length of dynamic type, 0 or multiplication of ETH_PADDING (32)
 */
var dynamicBytesLength = function (type) {
    if (isArrayType(type) || type === 'bytes')
        return c.ETH_PADDING * 2;
    return 0;
};

var outputTypes = types.outputTypes();

/** 
 * Formats output bytes back to param list
 *
 * @method formatOutput
 * @param {Array} abi outputs of method
 * @param {String} bytes represention of output
 * @returns {Array} output params
 */
var formatOutput = function (outs, output) {

    output = output.slice(2);
    var result = [];
    var padding = c.ETH_PADDING * 2;

    var dynamicPartLength = outs.reduce(function (acc, curr) {
        return acc + dynamicBytesLength(curr.type);
    }, 0);

    var dynamicPart = output.slice(0, dynamicPartLength);
    output = output.slice(dynamicPartLength);

    outs.forEach(function (out, i) {
        /*jshint maxcomplexity:6 */
        var typeMatch = false;
        for (var j = 0; j < outputTypes.length && !typeMatch; j++) {
            typeMatch = outputTypes[j].type(outs[i].type);
        }

        if (!typeMatch) {
            throwTypeError(outs[i].type);
        }

        var formatter = outputTypes[j - 1].format;
        if (isArrayType(outs[i].type)) {
            var size = f.formatOutputUInt(dynamicPart.slice(0, padding));
            dynamicPart = dynamicPart.slice(padding);
            var array = [];
            for (var k = 0; k < size; k++) {
                array.push(formatter(output.slice(0, padding)));
                output = output.slice(padding);
            }
            result.push(array);
        }
        else if (types.prefixedType('bytes')(outs[i].type)) {
            dynamicPart = dynamicPart.slice(padding);
            result.push(formatter(output.slice(0, padding)));
            output = output.slice(padding);
        } else {
            result.push(formatter(output.slice(0, padding)));
            output = output.slice(padding);
        }
    });

    return result;
};

/**
 * Should be called to create input parser for contract with given abi
 *
 * @method inputParser
 * @param {Array} contract abi
 * @returns {Object} input parser object for given json abi
 * TODO: refactor creating the parser, do not double logic from contract
 */
var inputParser = function (json) {
    var parser = {};
    json.forEach(function (method) {
        var displayName = utils.extractDisplayName(method.name);
        var typeName = utils.extractTypeName(method.name);

        var impl = function () {
            var params = Array.prototype.slice.call(arguments);
            return formatInput(method.inputs, params);
        };

        if (parser[displayName] === undefined) {
            parser[displayName] = impl;
        }

        parser[displayName][typeName] = impl;
    });

    return parser;
};

/**
 * Should be called to create output parser for contract with given abi
 *
 * @method outputParser
 * @param {Array} contract abi
 * @returns {Object} output parser for given json abi
 */
var outputParser = function (json) {
    var parser = {};
    json.forEach(function (method) {

        var displayName = utils.extractDisplayName(method.name);
        var typeName = utils.extractTypeName(method.name);

        var impl = function (output) {
            return formatOutput(method.outputs, output);
        };

        if (parser[displayName] === undefined) {
            parser[displayName] = impl;
        }

        parser[displayName][typeName] = impl;
    });

    return parser;
};

var formatConstructorParams = function (abi, params) {
    var constructor = solUtils.getConstructor(abi, params.length);
    if (!constructor) {
        if (params.length > 0) {
            console.warn("didn't found matching constructor, using default one");
        }
        return '';
    }
    return formatInput(constructor.inputs, params);
};

module.exports = {
    inputParser: inputParser,
    outputParser: outputParser,
    formatInput: formatInput,
    formatOutput: formatOutput,
    formatConstructorParams: formatConstructorParams
};

},{"../utils/config":6,"../utils/utils":7,"./formatters":3,"./types":4,"./utils":5}],3:[function(require,module,exports){
/*
    This file is part of ethereum.js.

    ethereum.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ethereum.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with ethereum.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file formatters.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var BigNumber = require('bignumber.js');
var utils = require('../utils/utils');
var c = require('../utils/config');

/**
 * Formats input value to byte representation of int
 * If value is negative, return it's two's complement
 * If the value is floating point, round it down
 *
 * @method formatInputInt
 * @param {String|Number|BigNumber} value that needs to be formatted
 * @returns {String} right-aligned byte representation of int
 */
var formatInputInt = function (value) {
    var padding = c.ETH_PADDING * 2;
    BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);
    return utils.padLeft(utils.toTwosComplement(value).round().toString(16), padding);
};

/**
 * Formats input value to byte representation of string
 *
 * @method formatInputString
 * @param {String}
 * @returns {String} left-algined byte representation of string
 */
var formatInputString = function (value) {
    return utils.fromAscii(value, c.ETH_PADDING).substr(2);
};

/**
 * Formats input value to byte representation of bool
 *
 * @method formatInputBool
 * @param {Boolean}
 * @returns {String} right-aligned byte representation bool
 */
var formatInputBool = function (value) {
    return '000000000000000000000000000000000000000000000000000000000000000' + (value ?  '1' : '0');
};

/**
 * Formats input value to byte representation of real
 * Values are multiplied by 2^m and encoded as integers
 *
 * @method formatInputReal
 * @param {String|Number|BigNumber}
 * @returns {String} byte representation of real
 */
var formatInputReal = function (value) {
    return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128))); 
};

/**
 * Check if input value is negative
 *
 * @method signedIsNegative
 * @param {String} value is hex format
 * @returns {Boolean} true if it is negative, otherwise false
 */
var signedIsNegative = function (value) {
    return (new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';
};

/**
 * Formats right-aligned output bytes to int
 *
 * @method formatOutputInt
 * @param {String} bytes
 * @returns {BigNumber} right-aligned output bytes formatted to big number
 */
var formatOutputInt = function (value) {

    value = value || "0";

    // check if it's negative number
    // it it is, return two's complement
    if (signedIsNegative(value)) {
        return new BigNumber(value, 16).minus(new BigNumber('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16)).minus(1);
    }
    return new BigNumber(value, 16);
};

/**
 * Formats right-aligned output bytes to uint
 *
 * @method formatOutputUInt
 * @param {String} bytes
 * @returns {BigNumeber} right-aligned output bytes formatted to uint
 */
var formatOutputUInt = function (value) {
    value = value || "0";
    return new BigNumber(value, 16);
};

/**
 * Formats right-aligned output bytes to real
 *
 * @method formatOutputReal
 * @param {String}
 * @returns {BigNumber} input bytes formatted to real
 */
var formatOutputReal = function (value) {
    return formatOutputInt(value).dividedBy(new BigNumber(2).pow(128)); 
};

/**
 * Formats right-aligned output bytes to ureal
 *
 * @method formatOutputUReal
 * @param {String}
 * @returns {BigNumber} input bytes formatted to ureal
 */
var formatOutputUReal = function (value) {
    return formatOutputUInt(value).dividedBy(new BigNumber(2).pow(128)); 
};

/**
 * Should be used to format output hash
 *
 * @method formatOutputHash
 * @param {String}
 * @returns {String} right-aligned output bytes formatted to hex
 */
var formatOutputHash = function (value) {
    return "0x" + value;
};

/**
 * Should be used to format output bool
 *
 * @method formatOutputBool
 * @param {String}
 * @returns {Boolean} right-aligned input bytes formatted to bool
 */
var formatOutputBool = function (value) {
    return value === '0000000000000000000000000000000000000000000000000000000000000001' ? true : false;
};

/**
 * Should be used to format output string
 *
 * @method formatOutputString
 * @param {Sttring} left-aligned hex representation of string
 * @returns {String} ascii string
 */
var formatOutputString = function (value) {
    return utils.toAscii(value);
};

/**
 * Should be used to format output address
 *
 * @method formatOutputAddress
 * @param {String} right-aligned input bytes
 * @returns {String} address
 */
var formatOutputAddress = function (value) {
    return "0x" + value.slice(value.length - 40, value.length);
};

module.exports = {
    formatInputInt: formatInputInt,
    formatInputString: formatInputString,
    formatInputBool: formatInputBool,
    formatInputReal: formatInputReal,
    formatOutputInt: formatOutputInt,
    formatOutputUInt: formatOutputUInt,
    formatOutputReal: formatOutputReal,
    formatOutputUReal: formatOutputUReal,
    formatOutputHash: formatOutputHash,
    formatOutputBool: formatOutputBool,
    formatOutputString: formatOutputString,
    formatOutputAddress: formatOutputAddress
};


},{"../utils/config":6,"../utils/utils":7,"bignumber.js":8}],4:[function(require,module,exports){
/*
    This file is part of ethereum.js.

    ethereum.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ethereum.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with ethereum.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file types.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var f = require('./formatters');

/// @param expected type prefix (string)
/// @returns function which checks if type has matching prefix. if yes, returns true, otherwise false
var prefixedType = function (prefix) {
    return function (type) {
        return type.indexOf(prefix) === 0;
    };
};

/// @param expected type name (string)
/// @returns function which checks if type is matching expected one. if yes, returns true, otherwise false
var namedType = function (name) {
    return function (type) {
        return name === type;
    };
};

/// Setups input formatters for solidity types
/// @returns an array of input formatters 
var inputTypes = function () {
    
    return [
        { type: prefixedType('uint'), format: f.formatInputInt },
        { type: prefixedType('int'), format: f.formatInputInt },
        { type: prefixedType('bytes'), format: f.formatInputString }, 
        { type: prefixedType('real'), format: f.formatInputReal },
        { type: prefixedType('ureal'), format: f.formatInputReal },
        { type: namedType('address'), format: f.formatInputInt },
        { type: namedType('bool'), format: f.formatInputBool }
    ];
};

/// Setups output formaters for solidity types
/// @returns an array of output formatters
var outputTypes = function () {

    return [
        { type: prefixedType('uint'), format: f.formatOutputUInt },
        { type: prefixedType('int'), format: f.formatOutputInt },
        { type: prefixedType('bytes'), format: f.formatOutputString },
        { type: prefixedType('real'), format: f.formatOutputReal },
        { type: prefixedType('ureal'), format: f.formatOutputUReal },
        { type: namedType('address'), format: f.formatOutputAddress },
        { type: namedType('bool'), format: f.formatOutputBool }
    ];
};

module.exports = {
    prefixedType: prefixedType,
    namedType: namedType,
    inputTypes: inputTypes,
    outputTypes: outputTypes
};


},{"./formatters":3}],5:[function(require,module,exports){
/*
    This file is part of ethereum.js.

    ethereum.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ethereum.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with ethereum.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file utils.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

/**
 * Returns the contstructor with matching number of arguments
 *
 * @method getConstructor
 * @param {Array} abi
 * @param {Number} numberOfArgs
 * @returns {Object} constructor function abi
 */
var getConstructor = function (abi, numberOfArgs) {
    return abi.filter(function (f) {
        return f.type === 'constructor' && f.inputs.length === numberOfArgs;
    })[0];
};

/**
 * Filters all functions from input abi
 *
 * @method filterFunctions
 * @param {Array} abi
 * @returns {Array} abi array with filtered objects of type 'function'
 */
var filterFunctions = function (json) {
    return json.filter(function (current) {
        return current.type === 'function'; 
    }); 
};

/**
 * Filters all events from input abi
 *
 * @method filterEvents
 * @param {Array} abi
 * @returns {Array} abi array with filtered objects of type 'event'
 */
var filterEvents = function (json) {
    return json.filter(function (current) {
        return current.type === 'event';
    });
};

module.exports = {
    getConstructor: getConstructor,
    filterFunctions: filterFunctions,
    filterEvents: filterEvents
};


},{}],6:[function(require,module,exports){
/*
    This file is part of ethereum.js.

    ethereum.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ethereum.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with ethereum.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file config.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

/**
 * Utils
 * 
 * @module utils
 */

/**
 * Utility functions
 * 
 * @class [utils] config
 * @constructor
 */

/// required to define ETH_BIGNUMBER_ROUNDING_MODE
var BigNumber = require('bignumber.js');

var ETH_UNITS = [ 
    'wei', 
    'Kwei', 
    'Mwei', 
    'Gwei', 
    'szabo', 
    'finney', 
    'ether', 
    'grand', 
    'Mether', 
    'Gether', 
    'Tether', 
    'Pether', 
    'Eether', 
    'Zether', 
    'Yether', 
    'Nether', 
    'Dether', 
    'Vether', 
    'Uether' 
];

module.exports = {
    ETH_PADDING: 32,
    ETH_SIGNATURE_LENGTH: 4,
    ETH_UNITS: ETH_UNITS,
    ETH_BIGNUMBER_ROUNDING_MODE: { ROUNDING_MODE: BigNumber.ROUND_DOWN },
    ETH_POLLING_TIMEOUT: 1000,
    ETH_DEFAULTBLOCK: 'latest'
};


},{"bignumber.js":8}],7:[function(require,module,exports){
/*
    This file is part of ethereum.js.

    ethereum.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ethereum.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with ethereum.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file utils.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

/**
 * Utils
 * 
 * @module utils
 */

/**
 * Utility functions
 * 
 * @class [utils] utils
 * @constructor
 */

var BigNumber = require('bignumber.js');

var unitMap = {
    'wei':      '1',
    'kwei':     '1000',
    'ada':      '1000',
    'mwei':     '1000000',
    'babbage':  '1000000',
    'gwei':     '1000000000',
    'shannon':  '1000000000',
    'szabo':    '1000000000000',
    'finney':   '1000000000000000',
    'ether':    '1000000000000000000',
    'kether':   '1000000000000000000000',
    'grand':    '1000000000000000000000',
    'einstein': '1000000000000000000000',
    'mether':   '1000000000000000000000000',
    'gether':   '1000000000000000000000000000',
    'tether':   '1000000000000000000000000000000'
};

/**
 * Should be called to pad string to expected length
 *
 * @method padLeft
 * @param {String} string to be padded
 * @param {Number} characters that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var padLeft = function (string, chars, sign) {
    return new Array(chars - string.length + 1).join(sign ? sign : "0") + string;
};

/** Finds first index of array element matching pattern
 *
 * @method findIndex
 * @param {Array}
 * @param {Function} pattern
 * @returns {Number} index of element
 */
var findIndex = function (array, callback) {
    var end = false;
    var i = 0;
    for (; i < array.length && !end; i++) {
        end = callback(array[i]);
    }
    return end ? i - 1 : -1;
};

/** 
 * Should be called to get sting from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
var toAscii = function(hex) {
// Find termination
    var str = "";
    var i = 0, l = hex.length;
    if (hex.substring(0, 2) === '0x') {
        i = 2;
    }
    for (; i < l; i+=2) {
        var code = parseInt(hex.substr(i, 2), 16);
        if (code === 0) {
            break;
        }

        str += String.fromCharCode(code);
    }

    return str;
};
    
/**
 * Shold be called to get hex representation (prefixed by 0x) of ascii string 
 *
 * @method fromAscii
 * @param {String} string
 * @returns {String} hex representation of input string
 */
var toHexNative = function(str) {
    var hex = "";
    for(var i = 0; i < str.length; i++) {
        var n = str.charCodeAt(i).toString(16);
        hex += n.length < 2 ? '0' + n : n;
    }

    return hex;
};

/**
 * Shold be called to get hex representation (prefixed by 0x) of ascii string 
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
var fromAscii = function(str, pad) {
    pad = pad === undefined ? 0 : pad;
    var hex = toHexNative(str);
    while (hex.length < pad*2)
        hex += "00";
    return "0x" + hex;
};

/**
 * Should be called to get display name of contract function
 * 
 * @method extractDisplayName
 * @param {String} name of function/event
 * @returns {String} display name for function/event eg. multiply(uint256) -> multiply
 */
var extractDisplayName = function (name) {
    var length = name.indexOf('('); 
    return length !== -1 ? name.substr(0, length) : name;
};

/// @returns overloaded part of function/event name
var extractTypeName = function (name) {
    /// TODO: make it invulnerable
    var length = name.indexOf('(');
    return length !== -1 ? name.substr(length + 1, name.length - 1 - (length + 1)).replace(' ', '') : "";
};

/**
 * Converts value to it's decimal representation in string
 *
 * @method toDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var toDecimal = function (value) {
    return toBigNumber(value).toNumber();
};

/**
 * Converts value to it's hex representation
 *
 * @method fromDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var fromDecimal = function (value) {
    var number = toBigNumber(value);
    var result = number.toString(16);

    return number.lessThan(0) ? '-0x' + result.substr(1) : '0x' + result;
};

/**
 * Auto converts any given value into it's hex representation.
 *
 * And even stringifys objects before.
 *
 * @method toHex
 * @param {String|Number|BigNumber|Object}
 * @return {String}
 */
var toHex = function (val) {
    /*jshint maxcomplexity:7 */

    if (isBoolean(val))
        return fromDecimal(+val);

    if (isBigNumber(val))
        return fromDecimal(val);

    if (isObject(val))
        return fromAscii(JSON.stringify(val));

    // if its a negative number, pass it through fromDecimal
    if (isString(val)) {
        if (val.indexOf('-0x') === 0)
           return fromDecimal(val);
        else if (!isFinite(val))
            return fromAscii(val);
    }

    return fromDecimal(val);
};

/**
 * Returns value of unit in Wei
 *
 * @method getValueOfUnit
 * @param {String} unit the unit to convert to, default ether
 * @returns {BigNumber} value of the unit (in Wei)
 * @throws error if the unit is not correct:w
 */
var getValueOfUnit = function (unit) {
    unit = unit ? unit.toLowerCase() : 'ether';
    var unitValue = unitMap[unit];
    if (unitValue === undefined) {
        throw new Error('This unit doesn\'t exists, please use the one of the following units' + JSON.stringify(unitMap, null, 2));
    }
    return new BigNumber(unitValue, 10);
};

/**
 * Takes a number of wei and converts it to any other ether unit.
 *
 * Possible units are:
 * - kwei/ada
 * - mwei/babbage
 * - gwei/shannon
 * - szabo
 * - finney
 * - ether
 * - kether/grand/einstein
 * - mether
 * - gether
 * - tether
 *
 * @method fromWei
 * @param {Number|String} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert to, default ether
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var fromWei = function(number, unit) {
    var returnValue = toBigNumber(number).dividedBy(getValueOfUnit(unit));

    return isBigNumber(number) ? returnValue : returnValue.toString(10); 
};

/**
 * Takes a number of a unit and converts it to wei.
 *
 * Possible units are:
 * - kwei/ada
 * - mwei/babbage
 * - gwei/shannon
 * - szabo
 * - finney
 * - ether
 * - kether/grand/einstein
 * - mether
 * - gether
 * - tether
 *
 * @method toWei
 * @param {Number|String|BigNumber} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert from, default ether
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var toWei = function(number, unit) {
    var returnValue = toBigNumber(number).times(getValueOfUnit(unit));

    return isBigNumber(number) ? returnValue : returnValue.toString(10); 
};

/**
 * Takes an input and transforms it into an bignumber
 *
 * @method toBigNumber
 * @param {Number|String|BigNumber} a number, string, HEX string or BigNumber
 * @return {BigNumber} BigNumber
*/
var toBigNumber = function(number) {
    /*jshint maxcomplexity:5 */
    number = number || 0;
    if (isBigNumber(number))
        return number;

    if (isString(number) && (number.indexOf('0x') === 0 || number.indexOf('-0x') === 0)) {
        return new BigNumber(number.replace('0x',''), 16);
    }
   
    return new BigNumber(number.toString(10), 10);
};

/**
 * Takes and input transforms it into bignumber and if it is negative value, into two's complement
 *
 * @method toTwosComplement
 * @param {Number|String|BigNumber}
 * @return {BigNumber}
 */
var toTwosComplement = function (number) {
    var bigNumber = toBigNumber(number);
    if (bigNumber.lessThan(0)) {
        return new BigNumber("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16).plus(bigNumber).plus(1);
    }
    return bigNumber;
};

/**
 * Checks if the given string is strictly an address
 *
 * @method isStrictAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isStrictAddress = function (address) {
    return /^0x[0-9a-f]{40}$/.test(address);
};

/**
 * Checks if the given string is an address
 *
 * @method isAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isAddress = function (address) {
    return /^(0x)?[0-9a-f]{40}$/.test(address);
};

/**
 * Transforms given string to valid 20 bytes-length addres with 0x prefix
 *
 * @method toAddress
 * @param {String} address
 * @return {String} formatted address
 */
var toAddress = function (address) {
    if (isStrictAddress(address)) {
        return address;
    }
    
    if (/^[0-9a-f]{40}$/.test(address)) {
        return '0x' + address;
    }

    return '0x' + padLeft(toHex(address).substr(2), 40);
};

/**
 * Returns true if object is BigNumber, otherwise false
 *
 * @method isBigNumber
 * @param {Object}
 * @return {Boolean} 
 */
var isBigNumber = function (object) {
    return object instanceof BigNumber ||
        (object && object.constructor && object.constructor.name === 'BigNumber');
};

/**
 * Returns true if object is string, otherwise false
 * 
 * @method isString
 * @param {Object}
 * @return {Boolean}
 */
var isString = function (object) {
    return typeof object === 'string' ||
        (object && object.constructor && object.constructor.name === 'String');
};

/**
 * Returns true if object is function, otherwise false
 *
 * @method isFunction
 * @param {Object}
 * @return {Boolean}
 */
var isFunction = function (object) {
    return typeof object === 'function';
};

/**
 * Returns true if object is Objet, otherwise false
 *
 * @method isObject
 * @param {Object}
 * @return {Boolean}
 */
var isObject = function (object) {
    return typeof object === 'object';
};

/**
 * Returns true if object is boolean, otherwise false
 *
 * @method isBoolean
 * @param {Object}
 * @return {Boolean}
 */
var isBoolean = function (object) {
    return typeof object === 'boolean';
};

/**
 * Returns true if object is array, otherwise false
 *
 * @method isArray
 * @param {Object}
 * @return {Boolean}
 */
var isArray = function (object) {
    return object instanceof Array; 
};

/**
 * Returns true if given string is valid json object
 * 
 * @method isJson
 * @param {String}
 * @return {Boolean}
 */
var isJson = function (str) {
    try {
        return !!JSON.parse(str);
    } catch (e) {
        return false;
    }
};

module.exports = {
    padLeft: padLeft,
    findIndex: findIndex,
    toHex: toHex,
    toDecimal: toDecimal,
    fromDecimal: fromDecimal,
    toAscii: toAscii,
    fromAscii: fromAscii,
    extractDisplayName: extractDisplayName,
    extractTypeName: extractTypeName,
    toWei: toWei,
    fromWei: fromWei,
    toBigNumber: toBigNumber,
    toTwosComplement: toTwosComplement,
    toAddress: toAddress,
    isBigNumber: isBigNumber,
    isStrictAddress: isStrictAddress,
    isAddress: isAddress,
    isFunction: isFunction,
    isString: isString,
    isObject: isObject,
    isBoolean: isBoolean,
    isArray: isArray,
    isJson: isJson
};


},{"bignumber.js":8}],8:[function(require,module,exports){
/*! bignumber.js v2.0.7 https://github.com/MikeMcl/bignumber.js/LICENCE */

;(function (global) {
    'use strict';

    /*
      bignumber.js v2.0.7
      A JavaScript library for arbitrary-precision arithmetic.
      https://github.com/MikeMcl/bignumber.js
      Copyright (c) 2015 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */


    var BigNumber, crypto, parseNumeric,
        isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        mathceil = Math.ceil,
        mathfloor = Math.floor,
        notBool = ' not a boolean or binary digit',
        roundingMode = 'rounding mode',
        tooManyDigits = 'number type has more than 15 significant digits',
        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
        BASE = 1e14,
        LOG_BASE = 14,
        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
        SQRT_BASE = 1e7,

        /*
         * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
         * the arguments to toExponential, toFixed, toFormat, and toPrecision, beyond which an
         * exception is thrown (if ERRORS is true).
         */
        MAX = 1E9;                                   // 0 to MAX_INT32


    /*
     * Create and return a BigNumber constructor.
     */
    function another(configObj) {
        var div,

            // id tracks the caller function, so its name can be included in error messages.
            id = 0,
            P = BigNumber.prototype,
            ONE = new BigNumber(1),


            /********************************* EDITABLE DEFAULTS **********************************/


            /*
             * The default values below must be integers within the inclusive ranges stated.
             * The values can also be changed at run-time using BigNumber.config.
             */

            // The maximum number of decimal places for operations involving division.
            DECIMAL_PLACES = 20,                     // 0 to MAX

            /*
             * The rounding mode used when rounding to the above decimal places, and when using
             * toExponential, toFixed, toFormat and toPrecision, and round (default value).
             * UP         0 Away from zero.
             * DOWN       1 Towards zero.
             * CEIL       2 Towards +Infinity.
             * FLOOR      3 Towards -Infinity.
             * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
             * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
             * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
             * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
             * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
             */
            ROUNDING_MODE = 4,                       // 0 to 8

            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

            // The exponent value at and beneath which toString returns exponential notation.
            // Number type: -7
            TO_EXP_NEG = -7,                         // 0 to -MAX

            // The exponent value at and above which toString returns exponential notation.
            // Number type: 21
            TO_EXP_POS = 21,                         // 0 to MAX

            // RANGE : [MIN_EXP, MAX_EXP]

            // The minimum exponent value, beneath which underflow to zero occurs.
            // Number type: -324  (5e-324)
            MIN_EXP = -1e7,                          // -1 to -MAX

            // The maximum exponent value, above which overflow to Infinity occurs.
            // Number type:  308  (1.7976931348623157e+308)
            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
            MAX_EXP = 1e7,                           // 1 to MAX

            // Whether BigNumber Errors are ever thrown.
            ERRORS = true,                           // true or false

            // Change to intValidatorNoErrors if ERRORS is false.
            isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors

            // Whether to use cryptographically-secure random number generation, if available.
            CRYPTO = false,                          // true or false

            /*
             * The modulo mode used when calculating the modulus: a mod n.
             * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
             * The remainder (r) is calculated as: r = a - n * q.
             *
             * UP        0 The remainder is positive if the dividend is negative, else is negative.
             * DOWN      1 The remainder has the same sign as the dividend.
             *             This modulo mode is commonly known as 'truncated division' and is
             *             equivalent to (a % n) in JavaScript.
             * FLOOR     3 The remainder has the same sign as the divisor (Python %).
             * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
             * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
             *             The remainder is always positive.
             *
             * The truncated division, floored division, Euclidian division and IEEE 754 remainder
             * modes are commonly used for the modulus operation.
             * Although the other rounding modes can also be used, they may not give useful results.
             */
            MODULO_MODE = 1,                         // 0 to 9

            // The maximum number of significant digits of the result of the toPower operation.
            // If POW_PRECISION is 0, there will be unlimited significant digits.
            POW_PRECISION = 100,                     // 0 to MAX

            // The format specification used by the BigNumber.prototype.toFormat method.
            FORMAT = {
                decimalSeparator: '.',
                groupSeparator: ',',
                groupSize: 3,
                secondaryGroupSize: 0,
                fractionGroupSeparator: '\xA0',      // non-breaking space
                fractionGroupSize: 0
            };


        /******************************************************************************************/


        // CONSTRUCTOR


        /*
         * The BigNumber constructor and exported function.
         * Create and return a new instance of a BigNumber object.
         *
         * n {number|string|BigNumber} A numeric value.
         * [b] {number} The base of n. Integer, 2 to 64 inclusive.
         */
        function BigNumber( n, b ) {
            var c, e, i, num, len, str,
                x = this;

            // Enable constructor usage without new.
            if ( !( x instanceof BigNumber ) ) {

                // 'BigNumber() constructor call without new: {n}'
                if (ERRORS) raise( 26, 'constructor call without new', n );
                return new BigNumber( n, b );
            }

            // 'new BigNumber() base not an integer: {b}'
            // 'new BigNumber() base out of range: {b}'
            if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

                // Duplicate.
                if ( n instanceof BigNumber ) {
                    x.s = n.s;
                    x.e = n.e;
                    x.c = ( n = n.c ) ? n.slice() : n;
                    id = 0;
                    return;
                }

                if ( ( num = typeof n == 'number' ) && n * 0 == 0 ) {
                    x.s = 1 / n < 0 ? ( n = -n, -1 ) : 1;

                    // Fast path for integers.
                    if ( n === ~~n ) {
                        for ( e = 0, i = n; i >= 10; i /= 10, e++ );
                        x.e = e;
                        x.c = [n];
                        id = 0;
                        return;
                    }

                    str = n + '';
                } else {
                    if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }
            } else {
                b = b | 0;
                str = n + '';

                // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
                // Allow exponential notation to be used with base 10 argument.
                if ( b == 10 ) {
                    x = new BigNumber( n instanceof BigNumber ? n : str );
                    return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
                }

                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                // Any number in exponential form will fail due to the [Ee][+-].
                if ( ( num = typeof n == 'number' ) && n * 0 != 0 ||
                  !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
                    '(?:\\.' + c + ')?$',b < 37 ? 'i' : '' ) ).test(str) ) {
                    return parseNumeric( x, str, num, b );
                }

                if (num) {
                    x.s = 1 / n < 0 ? ( str = str.slice(1), -1 ) : 1;

                    if ( ERRORS && str.replace( /^0\.0*|\./, '' ).length > 15 ) {

                        // 'new BigNumber() number type has more than 15 significant digits: {n}'
                        raise( id, tooManyDigits, n );
                    }

                    // Prevent later check for length on converted number.
                    num = false;
                } else {
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }

                str = convertBase( str, 10, b, x.s );
            }

            // Decimal point?
            if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );

            // Exponential form?
            if ( ( i = str.search( /e/i ) ) > 0 ) {

                // Determine exponent.
                if ( e < 0 ) e = i;
                e += +str.slice( i + 1 );
                str = str.substring( 0, i );
            } else if ( e < 0 ) {

                // Integer.
                e = str.length;
            }

            // Determine leading zeros.
            for ( i = 0; str.charCodeAt(i) === 48; i++ );

            // Determine trailing zeros.
            for ( len = str.length; str.charCodeAt(--len) === 48; );
            str = str.slice( i, len + 1 );

            if (str) {
                len = str.length;

                // Disallow numbers with over 15 significant digits if number type.
                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                if ( num && ERRORS && len > 15 ) raise( id, tooManyDigits, x.s * n );

                e = e - i - 1;

                 // Overflow?
                if ( e > MAX_EXP ) {

                    // Infinity.
                    x.c = x.e = null;

                // Underflow?
                } else if ( e < MIN_EXP ) {

                    // Zero.
                    x.c = [ x.e = 0 ];
                } else {
                    x.e = e;
                    x.c = [];

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = ( e + 1 ) % LOG_BASE;
                    if ( e < 0 ) i += LOG_BASE;

                    if ( i < len ) {
                        if (i) x.c.push( +str.slice( 0, i ) );

                        for ( len -= LOG_BASE; i < len; ) {
                            x.c.push( +str.slice( i, i += LOG_BASE ) );
                        }

                        str = str.slice(i);
                        i = LOG_BASE - str.length;
                    } else {
                        i -= len;
                    }

                    for ( ; i--; str += '0' );
                    x.c.push( +str );
                }
            } else {

                // Zero.
                x.c = [ x.e = 0 ];
            }

            id = 0;
        }


        // CONSTRUCTOR PROPERTIES


        BigNumber.another = another;

        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;


        /*
         * Configure infrequently-changing library-wide settings.
         *
         * Accept an object or an argument list, with one or many of the following properties or
         * parameters respectively:
         *
         *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive
         *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive
         *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to 0 incl., 0 to MAX incl.]
         *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to -1 incl., integer 1 to MAX incl.]
         *   ERRORS          {boolean|number}   true, false, 1 or 0
         *   CRYPTO          {boolean|number}   true, false, 1 or 0
         *   MODULO_MODE     {number}           0 to 9 inclusive
         *   POW_PRECISION   {number}           0 to MAX inclusive
         *   FORMAT          {object}           See BigNumber.prototype.toFormat
         *      decimalSeparator       {string}
         *      groupSeparator         {string}
         *      groupSize              {number}
         *      secondaryGroupSize     {number}
         *      fractionGroupSeparator {string}
         *      fractionGroupSize      {number}
         *
         * (The values assigned to the above FORMAT object properties are not checked for validity.)
         *
         * E.g.
         * BigNumber.config(20, 4) is equivalent to
         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
         *
         * Ignore properties/parameters set to null or undefined.
         * Return an object with the properties current values.
         */
        BigNumber.config = function () {
            var v, p,
                i = 0,
                r = {},
                a = arguments,
                o = a[0],
                has = o && typeof o == 'object'
                  ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
                  : function () { if ( a.length > i ) return ( v = a[i++] ) != null; };

            // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
            // 'config() DECIMAL_PLACES not an integer: {v}'
            // 'config() DECIMAL_PLACES out of range: {v}'
            if ( has( p = 'DECIMAL_PLACES' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                DECIMAL_PLACES = v | 0;
            }
            r[p] = DECIMAL_PLACES;

            // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
            // 'config() ROUNDING_MODE not an integer: {v}'
            // 'config() ROUNDING_MODE out of range: {v}'
            if ( has( p = 'ROUNDING_MODE' ) && isValidInt( v, 0, 8, 2, p ) ) {
                ROUNDING_MODE = v | 0;
            }
            r[p] = ROUNDING_MODE;

            // EXPONENTIAL_AT {number|number[]}
            // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
            // 'config() EXPONENTIAL_AT not an integer: {v}'
            // 'config() EXPONENTIAL_AT out of range: {v}'
            if ( has( p = 'EXPONENTIAL_AT' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, 0, 2, p ) && isValidInt( v[1], 0, MAX, 2, p ) ) {
                        TO_EXP_NEG = v[0] | 0;
                        TO_EXP_POS = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    TO_EXP_NEG = -( TO_EXP_POS = ( v < 0 ? -v : v ) | 0 );
                }
            }
            r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

            // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
            // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
            // 'config() RANGE not an integer: {v}'
            // 'config() RANGE cannot be zero: {v}'
            // 'config() RANGE out of range: {v}'
            if ( has( p = 'RANGE' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, -1, 2, p ) && isValidInt( v[1], 1, MAX, 2, p ) ) {
                        MIN_EXP = v[0] | 0;
                        MAX_EXP = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v < 0 ? -v : v ) | 0 );
                    else if (ERRORS) raise( 2, p + ' cannot be zero', v );
                }
            }
            r[p] = [ MIN_EXP, MAX_EXP ];

            // ERRORS {boolean|number} true, false, 1 or 0.
            // 'config() ERRORS not a boolean or binary digit: {v}'
            if ( has( p = 'ERRORS' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    id = 0;
                    isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = ERRORS;

            // CRYPTO {boolean|number} true, false, 1 or 0.
            // 'config() CRYPTO not a boolean or binary digit: {v}'
            // 'config() crypto unavailable: {crypto}'
            if ( has( p = 'CRYPTO' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    CRYPTO = !!( v && crypto && typeof crypto == 'object' );
                    if ( v && !CRYPTO && ERRORS ) raise( 2, 'crypto unavailable', crypto );
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = CRYPTO;

            // MODULO_MODE {number} Integer, 0 to 9 inclusive.
            // 'config() MODULO_MODE not an integer: {v}'
            // 'config() MODULO_MODE out of range: {v}'
            if ( has( p = 'MODULO_MODE' ) && isValidInt( v, 0, 9, 2, p ) ) {
                MODULO_MODE = v | 0;
            }
            r[p] = MODULO_MODE;

            // POW_PRECISION {number} Integer, 0 to MAX inclusive.
            // 'config() POW_PRECISION not an integer: {v}'
            // 'config() POW_PRECISION out of range: {v}'
            if ( has( p = 'POW_PRECISION' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                POW_PRECISION = v | 0;
            }
            r[p] = POW_PRECISION;

            // FORMAT {object}
            // 'config() FORMAT not an object: {v}'
            if ( has( p = 'FORMAT' ) ) {

                if ( typeof v == 'object' ) {
                    FORMAT = v;
                } else if (ERRORS) {
                    raise( 2, p + ' not an object', v );
                }
            }
            r[p] = FORMAT;

            return r;
        };


        /*
         * Return a new BigNumber whose value is the maximum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.max = function () { return maxOrMin( arguments, P.lt ); };


        /*
         * Return a new BigNumber whose value is the minimum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.min = function () { return maxOrMin( arguments, P.gt ); };


        /*
         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
         * zeros are produced).
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         *
         * 'random() decimal places not an integer: {dp}'
         * 'random() decimal places out of range: {dp}'
         * 'random() crypto unavailable: {crypto}'
         */
        BigNumber.random = (function () {
            var pow2_53 = 0x20000000000000;

            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
            // Check if Math.random() produces more than 32 bits of randomness.
            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
              ? function () { return mathfloor( Math.random() * pow2_53 ); }
              : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                  (Math.random() * 0x800000 | 0); };

            return function (dp) {
                var a, b, e, k, v,
                    i = 0,
                    c = [],
                    rand = new BigNumber(ONE);

                dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
                k = mathceil( dp / LOG_BASE );

                if (CRYPTO) {

                    // Browsers supporting crypto.getRandomValues.
                    if ( crypto && crypto.getRandomValues ) {

                        a = crypto.getRandomValues( new Uint32Array( k *= 2 ) );

                        for ( ; i < k; ) {

                            // 53 bits:
                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                            //                                     11111 11111111 11111111
                            // 0x20000 is 2^21.
                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                            // Rejection sampling:
                            // 0 <= v < 9007199254740992
                            // Probability that v >= 9e15, is
                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                            if ( v >= 9e15 ) {
                                b = crypto.getRandomValues( new Uint32Array(2) );
                                a[i] = b[0];
                                a[i + 1] = b[1];
                            } else {

                                // 0 <= v <= 8999999999999999
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 2;
                            }
                        }
                        i = k / 2;

                    // Node.js supporting crypto.randomBytes.
                    } else if ( crypto && crypto.randomBytes ) {

                        // buffer
                        a = crypto.randomBytes( k *= 7 );

                        for ( ; i < k; ) {

                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                            // 0 <= v < 9007199254740992
                            v = ( ( a[i] & 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
                                  ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
                                  ( a[i + 4] << 16 ) + ( a[i + 5] << 8 ) + a[i + 6];

                            if ( v >= 9e15 ) {
                                crypto.randomBytes(7).copy( a, i );
                            } else {

                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 7;
                            }
                        }
                        i = k / 7;
                    } else if (ERRORS) {
                        raise( 14, 'crypto unavailable', crypto );
                    }
                }

                // Use Math.random: CRYPTO is false or crypto is unavailable and ERRORS is false.
                if (!i) {

                    for ( ; i < k; ) {
                        v = random53bitInt();
                        if ( v < 9e15 ) c[i++] = v % 1e14;
                    }
                }

                k = c[--i];
                dp %= LOG_BASE;

                // Convert trailing digits to zeros according to dp.
                if ( k && dp ) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor( k / v ) * v;
                }

                // Remove trailing elements which are zero.
                for ( ; c[i] === 0; c.pop(), i-- );

                // Zero?
                if ( i < 0 ) {
                    c = [ e = 0 ];
                } else {

                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for ( e = -1 ; c[0] === 0; c.shift(), e -= LOG_BASE);

                    // Count the digits of the first element of c to determine leading zeros, and...
                    for ( i = 1, v = c[0]; v >= 10; v /= 10, i++);

                    // adjust the exponent accordingly.
                    if ( i < LOG_BASE ) e -= LOG_BASE - i;
                }

                rand.e = e;
                rand.c = c;
                return rand;
            };
        })();


        // PRIVATE FUNCTIONS


        // Convert a numeric string of baseIn to a numeric string of baseOut.
        function convertBase( str, baseOut, baseIn, sign ) {
            var d, e, k, r, x, xc, y,
                i = str.indexOf( '.' ),
                dp = DECIMAL_PLACES,
                rm = ROUNDING_MODE;

            if ( baseIn < 37 ) str = str.toLowerCase();

            // Non-integer.
            if ( i >= 0 ) {
                k = POW_PRECISION;

                // Unlimited precision.
                POW_PRECISION = 0;
                str = str.replace( '.', '' );
                y = new BigNumber(baseIn);
                x = y.pow( str.length - i );
                POW_PRECISION = k;

                // Convert str as if an integer, then restore the fraction part by dividing the
                // result by its base raised to a power.
                y.c = toBaseOut( toFixedPoint( coeffToString( x.c ), x.e ), 10, baseOut );
                y.e = y.c.length;
            }

            // Convert the number as integer.
            xc = toBaseOut( str, baseIn, baseOut );
            e = k = xc.length;

            // Remove trailing zeros.
            for ( ; xc[--k] == 0; xc.pop() );
            if ( !xc[0] ) return '0';

            if ( i < 0 ) {
                --e;
            } else {
                x.c = xc;
                x.e = e;

                // sign is needed for correct rounding.
                x.s = sign;
                x = div( x, y, dp, rm, baseOut );
                xc = x.c;
                r = x.r;
                e = x.e;
            }

            d = e + dp + 1;

            // The rounding digit, i.e. the digit to the right of the digit that may be rounded up.
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;

            r = rm < 4 ? ( i != null || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                       : i > k || i == k &&( rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                         rm == ( x.s < 0 ? 8 : 7 ) );

            if ( d < 1 || !xc[0] ) {

                // 1^-dp or 0.
                str = r ? toFixedPoint( '1', -dp ) : '0';
            } else {
                xc.length = d;

                if (r) {

                    // Rounding up may mean the previous digit has to be rounded up and so on.
                    for ( --baseOut; ++xc[--d] > baseOut; ) {
                        xc[d] = 0;

                        if ( !d ) {
                            ++e;
                            xc.unshift(1);
                        }
                    }
                }

                // Determine trailing zeros.
                for ( k = xc.length; !xc[--k]; );

                // E.g. [4, 11, 15] becomes 4bf.
                for ( i = 0, str = ''; i <= k; str += ALPHABET.charAt( xc[i++] ) );
                str = toFixedPoint( str, e );
            }

            // The caller will add the sign.
            return str;
        }


        // Perform division in the specified base. Called by div and convertBase.
        div = (function () {

            // Assume non-zero x and k.
            function multiply( x, k, base ) {
                var m, temp, xlo, xhi,
                    carry = 0,
                    i = x.length,
                    klo = k % SQRT_BASE,
                    khi = k / SQRT_BASE | 0;

                for ( x = x.slice(); i--; ) {
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;
                    carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;
                    x[i] = temp % base;
                }

                if (carry) x.unshift(carry);

                return x;
            }

            function compare( a, b, aL, bL ) {
                var i, cmp;

                if ( aL != bL ) {
                    cmp = aL > bL ? 1 : -1;
                } else {

                    for ( i = cmp = 0; i < aL; i++ ) {

                        if ( a[i] != b[i] ) {
                            cmp = a[i] > b[i] ? 1 : -1;
                            break;
                        }
                    }
                }
                return cmp;
            }

            function subtract( a, b, aL, base ) {
                var i = 0;

                // Subtract b from a.
                for ( ; aL--; ) {
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                }

                // Remove leading zeros.
                for ( ; !a[0] && a.length > 1; a.shift() );
            }

            // x: dividend, y: divisor.
            return function ( x, y, dp, rm, base ) {
                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                    yL, yz,
                    s = x.s == y.s ? 1 : -1,
                    xc = x.c,
                    yc = y.c;

                // Either NaN, Infinity or 0?
                if ( !xc || !xc[0] || !yc || !yc[0] ) {

                    return new BigNumber(

                      // Return NaN if either NaN, or both Infinity or 0.
                      !x.s || !y.s || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :

                        // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                    );
                }

                q = new BigNumber(s);
                qc = q.c = [];
                e = x.e - y.e;
                s = dp + e + 1;

                if ( !base ) {
                    base = BASE;
                    e = bitFloor( x.e / LOG_BASE ) - bitFloor( y.e / LOG_BASE );
                    s = s / LOG_BASE | 0;
                }

                // Result exponent may be one less then the current value of e.
                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );
                if ( yc[i] > ( xc[i] || 0 ) ) e--;

                if ( s < 0 ) {
                    qc.push(1);
                    more = true;
                } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;

                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                    n = mathfloor( base / ( yc[0] + 1 ) );

                    // Not necessary, but to handle odd bases where yc[0] == ( base / 2 ) - 1.
                    // if ( n > 1 || n++ == 1 && yc[0] < base / 2 ) {
                    if ( n > 1 ) {
                        yc = multiply( yc, n, base );
                        xc = multiply( xc, n, base );
                        yL = yc.length;
                        xL = xc.length;
                    }

                    xi = yL;
                    rem = xc.slice( 0, yL );
                    remL = rem.length;

                    // Add zeros to make remainder as long as divisor.
                    for ( ; remL < yL; rem[remL++] = 0 );
                    yz = yc.slice();
                    yz.unshift(0);
                    yc0 = yc[0];
                    if ( yc[1] >= base / 2 ) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if ( base == 3 && yc0 == 1 ) yc0 = 1 + 1e-15;

                    do {
                        n = 0;

                        // Compare divisor and remainder.
                        cmp = compare( yc, rem, yL, remL );

                        // If divisor < remainder.
                        if ( cmp < 0 ) {

                            // Calculate trial digit, n.

                            rem0 = rem[0];
                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );

                            // n is how many times the divisor goes into the current remainder.
                            n = mathfloor( rem0 / yc0 );

                            //  Algorithm:
                            //  1. product = divisor * trial digit (n)
                            //  2. if product > remainder: product -= divisor, n--
                            //  3. remainder -= product
                            //  4. if product was < remainder at 2:
                            //    5. compare new remainder and divisor
                            //    6. If remainder > divisor: remainder -= divisor, n++

                            if ( n > 1 ) {

                                // n may be > base only when base is 3.
                                if (n >= base) n = base - 1;

                                // product = divisor * trial digit.
                                prod = multiply( yc, n, base );
                                prodL = prod.length;
                                remL = rem.length;

                                // Compare product and remainder.
                                // If product > remainder.
                                // Trial digit n too high.
                                // n is 1 too high about 5% of the time, and is not known to have
                                // ever been more than 1 too high.
                                while ( compare( prod, rem, prodL, remL ) == 1 ) {
                                    n--;

                                    // Subtract divisor from product.
                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );
                                    prodL = prod.length;
                                    cmp = 1;
                                }
                            } else {

                                // n is 0 or 1, cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below,
                                // so change cmp to 1 to avoid it.
                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                if ( n == 0 ) {

                                    // divisor < remainder, so n must be at least 1.
                                    cmp = n = 1;
                                }

                                // product = divisor
                                prod = yc.slice();
                                prodL = prod.length;
                            }

                            if ( prodL < remL ) prod.unshift(0);

                            // Subtract product from remainder.
                            subtract( rem, prod, remL, base );
                            remL = rem.length;

                             // If product was < remainder.
                            if ( cmp == -1 ) {

                                // Compare divisor and new remainder.
                                // If divisor < new remainder, subtract divisor from remainder.
                                // Trial digit n too low.
                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                while ( compare( yc, rem, yL, remL ) < 1 ) {
                                    n++;

                                    // Subtract divisor from remainder.
                                    subtract( rem, yL < remL ? yz : yc, remL, base );
                                    remL = rem.length;
                                }
                            }
                        } else if ( cmp === 0 ) {
                            n++;
                            rem = [0];
                        } // else cmp === 1 and n will be 0

                        // Add the next digit, n, to the result array.
                        qc[i++] = n;

                        // Update the remainder.
                        if ( rem[0] ) {
                            rem[remL++] = xc[xi] || 0;
                        } else {
                            rem = [ xc[xi] ];
                            remL = 1;
                        }
                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );

                    more = rem[0] != null;

                    // Leading zero?
                    if ( !qc[0] ) qc.shift();
                }

                if ( base == BASE ) {

                    // To calculate q.e, first get the number of digits of qc[0].
                    for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );
                    round( q, dp + ( q.e = i + e * LOG_BASE - 1 ) + 1, rm, more );

                // Caller is convertBase.
                } else {
                    q.e = e;
                    q.r = +more;
                }

                return q;
            };
        })();


        /*
         * Return a string representing the value of BigNumber n in fixed-point or exponential
         * notation rounded to the specified decimal places or significant digits.
         *
         * n is a BigNumber.
         * i is the index of the last digit required (i.e. the digit that may be rounded up).
         * rm is the rounding mode.
         * caller is caller id: toExponential 19, toFixed 20, toFormat 21, toPrecision 24.
         */
        function format( n, i, rm, caller ) {
            var c0, e, ne, len, str;

            rm = rm != null && isValidInt( rm, 0, 8, caller, roundingMode )
              ? rm | 0 : ROUNDING_MODE;

            if ( !n.c ) return n.toString();
            c0 = n.c[0];
            ne = n.e;

            if ( i == null ) {
                str = coeffToString( n.c );
                str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG
                  ? toExponential( str, ne )
                  : toFixedPoint( str, ne );
            } else {
                n = round( new BigNumber(n), i, rm );

                // n.e may have changed if the value was rounded up.
                e = n.e;

                str = coeffToString( n.c );
                len = str.length;

                // toPrecision returns exponential notation if the number of significant digits
                // specified is less than the number of digits necessary to represent the integer
                // part of the value in fixed-point notation.

                // Exponential notation.
                if ( caller == 19 || caller == 24 && ( i <= e || e <= TO_EXP_NEG ) ) {

                    // Append zeros?
                    for ( ; len < i; str += '0', len++ );
                    str = toExponential( str, e );

                // Fixed-point notation.
                } else {
                    i -= ne;
                    str = toFixedPoint( str, e );

                    // Append zeros?
                    if ( e + 1 > len ) {
                        if ( --i > 0 ) for ( str += '.'; i--; str += '0' );
                    } else {
                        i += e - len;
                        if ( i > 0 ) {
                            if ( e + 1 == len ) str += '.';
                            for ( ; i--; str += '0' );
                        }
                    }
                }
            }

            return n.s < 0 && c0 ? '-' + str : str;
        }


        // Handle BigNumber.max and BigNumber.min.
        function maxOrMin( args, method ) {
            var m, n,
                i = 0;

            if ( isArray( args[0] ) ) args = args[0];
            m = new BigNumber( args[0] );

            for ( ; ++i < args.length; ) {
                n = new BigNumber( args[i] );

                // If any number is NaN, return NaN.
                if ( !n.s ) {
                    m = n;
                    break;
                } else if ( method.call( m, n ) ) {
                    m = n;
                }
            }

            return m;
        }


        /*
         * Return true if n is an integer in range, otherwise throw.
         * Use for argument validation when ERRORS is true.
         */
        function intValidatorWithErrors( n, min, max, caller, name ) {
            if ( n < min || n > max || n != truncate(n) ) {
                raise( caller, ( name || 'decimal places' ) +
                  ( n < min || n > max ? ' out of range' : ' not an integer' ), n );
            }

            return true;
        }


        /*
         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
         * Called by minus, plus and times.
         */
        function normalise( n, c, e ) {
            var i = 1,
                j = c.length;

             // Remove trailing zeros.
            for ( ; !c[--j]; c.pop() );

            // Calculate the base 10 exponent. First get the number of digits of c[0].
            for ( j = c[0]; j >= 10; j /= 10, i++ );

            // Overflow?
            if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {

                // Infinity.
                n.c = n.e = null;

            // Underflow?
            } else if ( e < MIN_EXP ) {

                // Zero.
                n.c = [ n.e = 0 ];
            } else {
                n.e = e;
                n.c = c;
            }

            return n;
        }


        // Handle values that fail the validity test in BigNumber.
        parseNumeric = (function () {
            var basePrefix=/^(-?)0([xbo])/i,
                dotAfter=/^([^.]+)\.$/,
                dotBefore=/^\.([^.]+)$/,
                isInfinityOrNaN=/^-?(Infinity|NaN)$/,
                whitespaceOrPlus=/^\s*\+|^\s+|\s+$/g;

            return function ( x, str, num, b ) {
                var base,
                    s = num ? str : str.replace( whitespaceOrPlus, '' );

                // No exception on ±Infinity or NaN.
                if ( isInfinityOrNaN.test(s) ) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                } else {
                    if ( !num ) {

                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                        s = s.replace( basePrefix, function ( m, p1, p2 ) {
                            base = ( p2 = p2.toLowerCase() ) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                            return !b || b == base ? p1 : m;
                        });

                        if (b) {
                            base = b;

                            // E.g. '1.' to '1', '.1' to '0.1'
                            s = s.replace( dotAfter, '$1' ).replace( dotBefore, '0.$1' );
                        }

                        if ( str != s ) return new BigNumber( s, base );
                    }

                    // 'new BigNumber() not a number: {n}'
                    // 'new BigNumber() not a base {b} number: {n}'
                    if (ERRORS) raise( id, 'not a' + ( b ? ' base ' + b : '' ) + ' number', str );
                    x.s = null;
                }

                x.c = x.e = null;
                id = 0;
            }
        })();


        // Throw a BigNumber Error.
        function raise( caller, msg, val ) {
            var error = new Error( [
                'new BigNumber',     // 0
                'cmp',               // 1
                'config',            // 2
                'div',               // 3
                'divToInt',          // 4
                'eq',                // 5
                'gt',                // 6
                'gte',               // 7
                'lt',                // 8
                'lte',               // 9
                'minus',             // 10
                'mod',               // 11
                'plus',              // 12
                'precision',         // 13
                'random',            // 14
                'round',             // 15
                'shift',             // 16
                'times',             // 17
                'toDigits',          // 18
                'toExponential',     // 19
                'toFixed',           // 20
                'toFormat',          // 21
                'toFraction',        // 22
                'pow',               // 23
                'toPrecision',       // 24
                'toString',          // 25
                'BigNumber'          // 26
            ][caller] + '() ' + msg + ': ' + val );

            error.name = 'BigNumber Error';
            id = 0;
            throw error;
        }


        /*
         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
         * If r is truthy, it is known that there are more digits after the rounding digit.
         */
        function round( x, sd, rm, r ) {
            var d, i, j, k, n, ni, rd,
                xc = x.c,
                pows10 = POWS_TEN;

            // if x is not Infinity or NaN...
            if (xc) {

                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                // ni is the index of n within x.c.
                // d is the number of digits of n.
                // i is the index of rd within n including leading zeros.
                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                out: {

                    // Get the number of digits of the first element of xc.
                    for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );
                    i = sd - d;

                    // If the rounding digit is in the first element of xc...
                    if ( i < 0 ) {
                        i += LOG_BASE;
                        j = sd;
                        n = xc[ ni = 0 ];

                        // Get the rounding digit at index j of n.
                        rd = n / pows10[ d - j - 1 ] % 10 | 0;
                    } else {
                        ni = mathceil( ( i + 1 ) / LOG_BASE );

                        if ( ni >= xc.length ) {

                            if (r) {

                                // Needed by sqrt.
                                for ( ; xc.length <= ni; xc.push(0) );
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                            } else {
                                break out;
                            }
                        } else {
                            n = k = xc[ni];

                            // Get the number of digits of n.
                            for ( d = 1; k >= 10; k /= 10, d++ );

                            // Get the index of rd within n.
                            i %= LOG_BASE;

                            // Get the index of rd within n, adjusted for leading zeros.
                            // The number of leading zeros of n is given by LOG_BASE - d.
                            j = i - LOG_BASE + d;

                            // Get the rounding digit at index j of n.
                            rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;
                        }
                    }

                    r = r || sd < 0 ||

                    // Are there any non-zero digits after the rounding digit?
                    // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                      xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );

                    r = rm < 4
                      ? ( rd || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                      : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&

                        // Check whether the digit to the left of the rounding digit is odd.
                        ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||
                          rm == ( x.s < 0 ? 8 : 7 ) );

                    if ( sd < 1 || !xc[0] ) {
                        xc.length = 0;

                        if (r) {

                            // Convert sd to decimal places.
                            sd -= x.e + 1;

                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                            xc[0] = pows10[ sd % LOG_BASE ];
                            x.e = -sd || 0;
                        } else {

                            // Zero.
                            xc[0] = x.e = 0;
                        }

                        return x;
                    }

                    // Remove excess digits.
                    if ( i == 0 ) {
                        xc.length = ni;
                        k = 1;
                        ni--;
                    } else {
                        xc.length = ni + 1;
                        k = pows10[ LOG_BASE - i ];

                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                        // j > 0 means i > number of leading zeros of n.
                        xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;
                    }

                    // Round up?
                    if (r) {

                        for ( ; ; ) {

                            // If the digit to be rounded up is in the first element of xc...
                            if ( ni == 0 ) {

                                // i will be the length of xc[0] before k is added.
                                for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );
                                j = xc[0] += k;
                                for ( k = 1; j >= 10; j /= 10, k++ );

                                // if i != k the length has increased.
                                if ( i != k ) {
                                    x.e++;
                                    if ( xc[0] == BASE ) xc[0] = 1;
                                }

                                break;
                            } else {
                                xc[ni] += k;
                                if ( xc[ni] != BASE ) break;
                                xc[ni--] = 0;
                                k = 1;
                            }
                        }
                    }

                    // Remove trailing zeros.
                    for ( i = xc.length; xc[--i] === 0; xc.pop() );
                }

                // Overflow? Infinity.
                if ( x.e > MAX_EXP ) {
                    x.c = x.e = null;

                // Underflow? Zero.
                } else if ( x.e < MIN_EXP ) {
                    x.c = [ x.e = 0 ];
                }
            }

            return x;
        }


        // PROTOTYPE/INSTANCE METHODS


        /*
         * Return a new BigNumber whose value is the absolute value of this BigNumber.
         */
        P.absoluteValue = P.abs = function () {
            var x = new BigNumber(this);
            if ( x.s < 0 ) x.s = 1;
            return x;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of Infinity.
         */
        P.ceil = function () {
            return round( new BigNumber(this), this.e + 1, 2 );
        };


        /*
         * Return
         * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
         * 0 if they have the same value,
         * or null if the value of either is NaN.
         */
        P.comparedTo = P.cmp = function ( y, b ) {
            id = 1;
            return compare( this, new BigNumber( y, b ) );
        };


        /*
         * Return the number of decimal places of the value of this BigNumber, or null if the value
         * of this BigNumber is ±Infinity or NaN.
         */
        P.decimalPlaces = P.dp = function () {
            var n, v,
                c = this.c;

            if ( !c ) return null;
            n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;

            // Subtract the number of trailing zeros of the last number.
            if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
            if ( n < 0 ) n = 0;

            return n;
        };


        /*
         *  n / 0 = I
         *  n / N = N
         *  n / I = 0
         *  0 / n = 0
         *  0 / 0 = N
         *  0 / N = N
         *  0 / I = 0
         *  N / n = N
         *  N / 0 = N
         *  N / N = N
         *  N / I = N
         *  I / n = I
         *  I / 0 = I
         *  I / N = N
         *  I / I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.dividedBy = P.div = function ( y, b ) {
            id = 3;
            return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
        };


        /*
         * Return a new BigNumber whose value is the integer part of dividing the value of this
         * BigNumber by the value of BigNumber(y, b).
         */
        P.dividedToIntegerBy = P.divToInt = function ( y, b ) {
            id = 4;
            return div( this, new BigNumber( y, b ), 0, 1 );
        };


        /*
         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.equals = P.eq = function ( y, b ) {
            id = 5;
            return compare( this, new BigNumber( y, b ) ) === 0;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of -Infinity.
         */
        P.floor = function () {
            return round( new BigNumber(this), this.e + 1, 3 );
        };


        /*
         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.greaterThan = P.gt = function ( y, b ) {
            id = 6;
            return compare( this, new BigNumber( y, b ) ) > 0;
        };


        /*
         * Return true if the value of this BigNumber is greater than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.greaterThanOrEqualTo = P.gte = function ( y, b ) {
            id = 7;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;

        };


        /*
         * Return true if the value of this BigNumber is a finite number, otherwise returns false.
         */
        P.isFinite = function () {
            return !!this.c;
        };


        /*
         * Return true if the value of this BigNumber is an integer, otherwise return false.
         */
        P.isInteger = P.isInt = function () {
            return !!this.c && bitFloor( this.e / LOG_BASE ) > this.c.length - 2;
        };


        /*
         * Return true if the value of this BigNumber is NaN, otherwise returns false.
         */
        P.isNaN = function () {
            return !this.s;
        };


        /*
         * Return true if the value of this BigNumber is negative, otherwise returns false.
         */
        P.isNegative = P.isNeg = function () {
            return this.s < 0;
        };


        /*
         * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.
         */
        P.isZero = function () {
            return !!this.c && this.c[0] == 0;
        };


        /*
         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.lessThan = P.lt = function ( y, b ) {
            id = 8;
            return compare( this, new BigNumber( y, b ) ) < 0;
        };


        /*
         * Return true if the value of this BigNumber is less than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.lessThanOrEqualTo = P.lte = function ( y, b ) {
            id = 9;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
        };


        /*
         *  n - 0 = n
         *  n - N = N
         *  n - I = -I
         *  0 - n = -n
         *  0 - 0 = 0
         *  0 - N = N
         *  0 - I = -I
         *  N - n = N
         *  N - 0 = N
         *  N - N = N
         *  N - I = N
         *  I - n = I
         *  I - 0 = I
         *  I - N = N
         *  I - I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
         * BigNumber(y, b).
         */
        P.minus = P.sub = function ( y, b ) {
            var i, j, t, xLTy,
                x = this,
                a = x.s;

            id = 10;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
            if ( a != b ) {
                y.s = -b;
                return x.plus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Either Infinity?
                if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );

                // Either zero?
                if ( !xc[0] || !yc[0] ) {

                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :

                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                      ROUNDING_MODE == 3 ? -0 : 0 );
                }
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Determine which is the bigger number.
            if ( a = xe - ye ) {

                if ( xLTy = a < 0 ) {
                    a = -a;
                    t = xc;
                } else {
                    ye = xe;
                    t = yc;
                }

                t.reverse();

                // Prepend zeros to equalise exponents.
                for ( b = a; b--; t.push(0) );
                t.reverse();
            } else {

                // Exponents equal. Check digit by digit.
                j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;

                for ( a = b = 0; b < j; b++ ) {

                    if ( xc[b] != yc[b] ) {
                        xLTy = xc[b] < yc[b];
                        break;
                    }
                }
            }

            // x < y? Point xc to the array of the bigger number.
            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

            b = ( j = yc.length ) - ( i = xc.length );

            // Append zeros to xc if shorter.
            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
            if ( b > 0 ) for ( ; b--; xc[i++] = 0 );
            b = BASE - 1;

            // Subtract yc from xc.
            for ( ; j > a; ) {

                if ( xc[--j] < yc[j] ) {
                    for ( i = j; i && !xc[--i]; xc[i] = b );
                    --xc[i];
                    xc[j] += BASE;
                }

                xc[j] -= yc[j];
            }

            // Remove leading zeros and adjust exponent accordingly.
            for ( ; xc[0] == 0; xc.shift(), --ye );

            // Zero?
            if ( !xc[0] ) {

                // Following IEEE 754 (2008) 6.3,
                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                y.c = [ y.e = 0 ];
                return y;
            }

            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
            // for finite x and y.
            return normalise( y, xc, ye );
        };


        /*
         *   n % 0 =  N
         *   n % N =  N
         *   n % I =  n
         *   0 % n =  0
         *  -0 % n = -0
         *   0 % 0 =  N
         *   0 % N =  N
         *   0 % I =  0
         *   N % n =  N
         *   N % 0 =  N
         *   N % N =  N
         *   N % I =  N
         *   I % n =  N
         *   I % 0 =  N
         *   I % N =  N
         *   I % I =  N
         *
         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
         */
        P.modulo = P.mod = function ( y, b ) {
            var q, s,
                x = this;

            id = 11;
            y = new BigNumber( y, b );

            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
            if ( !x.c || !y.s || y.c && !y.c[0] ) {
                return new BigNumber(NaN);

            // Return x if y is Infinity or x is zero.
            } else if ( !y.c || x.c && !x.c[0] ) {
                return new BigNumber(x);
            }

            if ( MODULO_MODE == 9 ) {

                // Euclidian division: q = sign(y) * floor(x / abs(y))
                // r = x - qy    where  0 <= r < abs(y)
                s = y.s;
                y.s = 1;
                q = div( x, y, 0, 3 );
                y.s = s;
                q.s *= s;
            } else {
                q = div( x, y, 0, MODULO_MODE );
            }

            return x.minus( q.times(y) );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber negated,
         * i.e. multiplied by -1.
         */
        P.negated = P.neg = function () {
            var x = new BigNumber(this);
            x.s = -x.s || null;
            return x;
        };


        /*
         *  n + 0 = n
         *  n + N = N
         *  n + I = I
         *  0 + n = n
         *  0 + 0 = 0
         *  0 + N = N
         *  0 + I = I
         *  N + n = N
         *  N + 0 = N
         *  N + N = N
         *  N + I = N
         *  I + n = I
         *  I + 0 = I
         *  I + N = N
         *  I + I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
         * BigNumber(y, b).
         */
        P.plus = P.add = function ( y, b ) {
            var t,
                x = this,
                a = x.s;

            id = 12;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
             if ( a != b ) {
                y.s = -b;
                return x.minus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Return ±Infinity if either ±Infinity.
                if ( !xc || !yc ) return new BigNumber( a / 0 );

                // Either zero?
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
            if ( a = xe - ye ) {
                if ( a > 0 ) {
                    ye = xe;
                    t = yc;
                } else {
                    a = -a;
                    t = xc;
                }

                t.reverse();
                for ( ; a--; t.push(0) );
                t.reverse();
            }

            a = xc.length;
            b = yc.length;

            // Point xc to the longer array, and b to the shorter length.
            if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;

            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
            for ( a = 0; b; ) {
                a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
                xc[b] %= BASE;
            }

            if (a) {
                xc.unshift(a);
                ++ye;
            }

            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
            // ye = MAX_EXP + 1 possible
            return normalise( y, xc, ye );
        };


        /*
         * Return the number of significant digits of the value of this BigNumber.
         *
         * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
         */
        P.precision = P.sd = function (z) {
            var n, v,
                x = this,
                c = x.c;

            // 'precision() argument not a boolean or binary digit: {z}'
            if ( z != null && z !== !!z && z !== 1 && z !== 0 ) {
                if (ERRORS) raise( 13, 'argument' + notBool, z );
                if ( z != !!z ) z = null;
            }

            if ( !c ) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;

            if ( v = c[v] ) {

                // Subtract the number of trailing zeros of the last element.
                for ( ; v % 10 == 0; v /= 10, n-- );

                // Add the number of digits of the first element.
                for ( v = c[0]; v >= 10; v /= 10, n++ );
            }

            if ( z && x.e + 1 > n ) n = x.e + 1;

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * dp decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if
         * omitted.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'round() decimal places out of range: {dp}'
         * 'round() decimal places not an integer: {dp}'
         * 'round() rounding mode not an integer: {rm}'
         * 'round() rounding mode out of range: {rm}'
         */
        P.round = function ( dp, rm ) {
            var n = new BigNumber(this);

            if ( dp == null || isValidInt( dp, 0, MAX, 15 ) ) {
                round( n, ~~dp + this.e + 1, rm == null ||
                  !isValidInt( rm, 0, 8, 15, roundingMode ) ? ROUNDING_MODE : rm | 0 );
            }

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
         *
         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         *
         * If k is out of range and ERRORS is false, the result will be ±0 if k < 0, or ±Infinity
         * otherwise.
         *
         * 'shift() argument not an integer: {k}'
         * 'shift() argument out of range: {k}'
         */
        P.shift = function (k) {
            var n = this;
            return isValidInt( k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument' )

              // k < 1e+21, or truncate(k) will produce exponential notation.
              ? n.times( '1e' + truncate(k) )
              : new BigNumber( n.c && n.c[0] && ( k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER )
                ? n.s * ( k < 0 ? 0 : 1 / 0 )
                : n );
        };


        /*
         *  sqrt(-n) =  N
         *  sqrt( N) =  N
         *  sqrt(-I) =  N
         *  sqrt( I) =  I
         *  sqrt( 0) =  0
         *  sqrt(-0) = -0
         *
         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.squareRoot = P.sqrt = function () {
            var m, n, r, rep, t,
                x = this,
                c = x.c,
                s = x.s,
                e = x.e,
                dp = DECIMAL_PLACES + 4,
                half = new BigNumber('0.5');

            // Negative/NaN/Infinity/zero?
            if ( s !== 1 || !c || !c[0] ) {
                return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
            }

            // Initial estimate.
            s = Math.sqrt( +x );

            // Math.sqrt underflow/overflow?
            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
            if ( s == 0 || s == 1 / 0 ) {
                n = coeffToString(c);
                if ( ( n.length + e ) % 2 == 0 ) n += '0';
                s = Math.sqrt(n);
                e = bitFloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );

                if ( s == 1 / 0 ) {
                    n = '1e' + e;
                } else {
                    n = s.toExponential();
                    n = n.slice( 0, n.indexOf('e') + 1 ) + e;
                }

                r = new BigNumber(n);
            } else {
                r = new BigNumber( s + '' );
            }

            // Check for zero.
            // r could be zero if MIN_EXP is changed after the this value was created.
            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
            // coeffToString to throw.
            if ( r.c[0] ) {
                e = r.e;
                s = e + dp;
                if ( s < 3 ) s = 0;

                // Newton-Raphson iteration.
                for ( ; ; ) {
                    t = r;
                    r = half.times( t.plus( div( x, t, dp, 1 ) ) );

                    if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
                         coeffToString( r.c ) ).slice( 0, s ) ) {

                        // The exponent of r may here be one less than the final result exponent,
                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                        // are indexed correctly.
                        if ( r.e < e ) --s;
                        n = n.slice( s - 3, s + 1 );

                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                        // iteration.
                        if ( n == '9999' || !rep && n == '4999' ) {

                            // On the first iteration only, check to see if rounding up gives the
                            // exact result as the nines may infinitely repeat.
                            if ( !rep ) {
                                round( t, t.e + DECIMAL_PLACES + 2, 0 );

                                if ( t.times(t).eq(x) ) {
                                    r = t;
                                    break;
                                }
                            }

                            dp += 4;
                            s += 4;
                            rep = 1;
                        } else {

                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                            // result. If not, then there are further digits and m will be truthy.
                            if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {

                                // Truncate to the first rounding digit.
                                round( r, r.e + DECIMAL_PLACES + 2, 1 );
                                m = !r.times(r).eq(x);
                            }

                            break;
                        }
                    }
                }
            }

            return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
        };


        /*
         *  n * 0 = 0
         *  n * N = N
         *  n * I = I
         *  0 * n = 0
         *  0 * 0 = 0
         *  0 * N = N
         *  0 * I = N
         *  N * n = N
         *  N * 0 = N
         *  N * N = N
         *  N * I = N
         *  I * n = I
         *  I * 0 = N
         *  I * N = N
         *  I * I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber times the value of
         * BigNumber(y, b).
         */
        P.times = P.mul = function ( y, b ) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                base, sqrtBase,
                x = this,
                xc = x.c,
                yc = ( id = 17, y = new BigNumber( y, b ) ).c;

            // Either NaN, ±Infinity or ±0?
            if ( !xc || !yc || !xc[0] || !yc[0] ) {

                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                if ( !x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc ) {
                    y.c = y.e = y.s = null;
                } else {
                    y.s *= x.s;

                    // Return ±Infinity if either is ±Infinity.
                    if ( !xc || !yc ) {
                        y.c = y.e = null;

                    // Return ±0 if either is ±0.
                    } else {
                        y.c = [0];
                        y.e = 0;
                    }
                }

                return y;
            }

            e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;

            // Ensure xc points to longer array and xcL to its length.
            if ( xcL < ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

            // Initialise the result array with zeros.
            for ( i = xcL + ycL, zc = []; i--; zc.push(0) );

            base = BASE;
            sqrtBase = SQRT_BASE;

            for ( i = ycL; --i >= 0; ) {
                c = 0;
                ylo = yc[i] % sqrtBase;
                yhi = yc[i] / sqrtBase | 0;

                for ( k = xcL, j = i + k; j > i; ) {
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
                    c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
                    zc[j--] = xlo % base;
                }

                zc[j] = c;
            }

            if (c) {
                ++e;
            } else {
                zc.shift();
            }

            return normalise( y, zc, e );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * sd significant digits using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toDigits() precision out of range: {sd}'
         * 'toDigits() precision not an integer: {sd}'
         * 'toDigits() rounding mode not an integer: {rm}'
         * 'toDigits() rounding mode out of range: {rm}'
         */
        P.toDigits = function ( sd, rm ) {
            var n = new BigNumber(this);
            sd = sd == null || !isValidInt( sd, 1, MAX, 18, 'precision' ) ? null : sd | 0;
            rm = rm == null || !isValidInt( rm, 0, 8, 18, roundingMode ) ? ROUNDING_MODE : rm | 0;
            return sd ? round( n, sd, rm ) : n;
        };


        /*
         * Return a string representing the value of this BigNumber in exponential notation and
         * rounded using ROUNDING_MODE to dp fixed decimal places.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toExponential() decimal places not an integer: {dp}'
         * 'toExponential() decimal places out of range: {dp}'
         * 'toExponential() rounding mode not an integer: {rm}'
         * 'toExponential() rounding mode out of range: {rm}'
         */
        P.toExponential = function ( dp, rm ) {
            return format( this,
              dp != null && isValidInt( dp, 0, MAX, 19 ) ? ~~dp + 1 : null, rm, 19 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounding
         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
         * but e.g. (-0.00001).toFixed(0) is '-0'.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFixed() decimal places not an integer: {dp}'
         * 'toFixed() decimal places out of range: {dp}'
         * 'toFixed() rounding mode not an integer: {rm}'
         * 'toFixed() rounding mode out of range: {rm}'
         */
        P.toFixed = function ( dp, rm ) {
            return format( this, dp != null && isValidInt( dp, 0, MAX, 20 )
              ? ~~dp + this.e + 1 : null, rm, 20 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounded
         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
         * of the FORMAT object (see BigNumber.config).
         *
         * FORMAT = {
         *      decimalSeparator : '.',
         *      groupSeparator : ',',
         *      groupSize : 3,
         *      secondaryGroupSize : 0,
         *      fractionGroupSeparator : '\xA0',    // non-breaking space
         *      fractionGroupSize : 0
         * };
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFormat() decimal places not an integer: {dp}'
         * 'toFormat() decimal places out of range: {dp}'
         * 'toFormat() rounding mode not an integer: {rm}'
         * 'toFormat() rounding mode out of range: {rm}'
         */
        P.toFormat = function ( dp, rm ) {
            var str = format( this, dp != null && isValidInt( dp, 0, MAX, 21 )
              ? ~~dp + this.e + 1 : null, rm, 21 );

            if ( this.c ) {
                var i,
                    arr = str.split('.'),
                    g1 = +FORMAT.groupSize,
                    g2 = +FORMAT.secondaryGroupSize,
                    groupSeparator = FORMAT.groupSeparator,
                    intPart = arr[0],
                    fractionPart = arr[1],
                    isNeg = this.s < 0,
                    intDigits = isNeg ? intPart.slice(1) : intPart,
                    len = intDigits.length;

                if (g2) i = g1, g1 = g2, g2 = i, len -= i;

                if ( g1 > 0 && len > 0 ) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr( 0, i );

                    for ( ; i < len; i += g1 ) {
                        intPart += groupSeparator + intDigits.substr( i, g1 );
                    }

                    if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                }

                str = fractionPart
                  ? intPart + FORMAT.decimalSeparator + ( ( g2 = +FORMAT.fractionGroupSize )
                    ? fractionPart.replace( new RegExp( '\\d{' + g2 + '}\\B', 'g' ),
                      '$&' + FORMAT.fractionGroupSeparator )
                    : fractionPart )
                  : intPart;
            }

            return str;
        };


        /*
         * Return a string array representing the value of this BigNumber as a simple fraction with
         * an integer numerator and an integer denominator. The denominator will be a positive
         * non-zero value less than or equal to the specified maximum denominator. If a maximum
         * denominator is not specified, the denominator will be the lowest value necessary to
         * represent the number exactly.
         *
         * [md] {number|string|BigNumber} Integer >= 1 and < Infinity. The maximum denominator.
         *
         * 'toFraction() max denominator not an integer: {md}'
         * 'toFraction() max denominator out of range: {md}'
         */
        P.toFraction = function (md) {
            var arr, d0, d2, e, exp, n, n0, q, s,
                k = ERRORS,
                x = this,
                xc = x.c,
                d = new BigNumber(ONE),
                n1 = d0 = new BigNumber(ONE),
                d1 = n0 = new BigNumber(ONE);

            if ( md != null ) {
                ERRORS = false;
                n = new BigNumber(md);
                ERRORS = k;

                if ( !( k = n.isInt() ) || n.lt(ONE) ) {

                    if (ERRORS) {
                        raise( 22,
                          'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
                    }

                    // ERRORS is false:
                    // If md is a finite non-integer >= 1, round it to an integer and use it.
                    md = !k && n.c && round( n, n.e + 1, 1 ).gte(ONE) ? n : null;
                }
            }

            if ( !xc ) return x.toString();
            s = coeffToString(xc);

            // Determine initial denominator.
            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];
            md = !md || n.cmp(d) > 0 ? ( e > 0 ? d : n1 ) : n;

            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber(s);

            // n0 = d1 = 0
            n0.c[0] = 0;

            for ( ; ; )  {
                q = div( n, d, 0, 1 );
                d2 = d0.plus( q.times(d1) );
                if ( d2.cmp(md) == 1 ) break;
                d0 = d1;
                d1 = d2;
                n1 = n0.plus( q.times( d2 = n1 ) );
                n0 = d2;
                d = n.minus( q.times( d2 = d ) );
                n = d2;
            }

            d2 = div( md.minus(d0), d1, 0, 1 );
            n0 = n0.plus( d2.times(n1) );
            d0 = d0.plus( d2.times(d1) );
            n0.s = n1.s = x.s;
            e *= 2;

            // Determine which fraction is closer to x, n0/d0 or n1/d1
            arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).abs().cmp(
                  div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) < 1
                    ? [ n1.toString(), d1.toString() ]
                    : [ n0.toString(), d0.toString() ];

            MAX_EXP = exp;
            return arr;
        };


        /*
         * Return the value of this BigNumber converted to a number primitive.
         */
        P.toNumber = function () {
            var x = this;

            // Ensure zero has correct sign.
            return +x || ( x.s ? x.s * 0 : NaN );
        };


        /*
         * Return a BigNumber whose value is the value of this BigNumber raised to the power n.
         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
         * If POW_PRECISION is not 0, round to POW_PRECISION using ROUNDING_MODE.
         *
         * n {number} Integer, -9007199254740992 to 9007199254740992 inclusive.
         * (Performs 54 loop iterations for n of 9007199254740992.)
         *
         * 'pow() exponent not an integer: {n}'
         * 'pow() exponent out of range: {n}'
         */
        P.toPower = P.pow = function (n) {
            var k, y,
                i = mathfloor( n < 0 ? -n : +n ),
                x = this;

            // Pass ±Infinity to Math.pow if exponent is out of range.
            if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &&
              ( !isFinite(n) || i > MAX_SAFE_INTEGER && ( n /= 0 ) ||
                parseFloat(n) != n && !( n = NaN ) ) ) {
                return new BigNumber( Math.pow( +x, n ) );
            }

            // Truncating each coefficient array to a length of k after each multiplication equates
            // to truncating significant digits to POW_PRECISION + [28, 41], i.e. there will be a
            // minimum of 28 guard digits retained. (Using + 1.5 would give [9, 21] guard digits.)
            k = POW_PRECISION ? mathceil( POW_PRECISION / LOG_BASE + 2 ) : 0;
            y = new BigNumber(ONE);

            for ( ; ; ) {

                if ( i % 2 ) {
                    y = y.times(x);
                    if ( !y.c ) break;
                    if ( k && y.c.length > k ) y.c.length = k;
                }

                i = mathfloor( i / 2 );
                if ( !i ) break;

                x = x.times(x);
                if ( k && x.c && x.c.length > k ) x.c.length = k;
            }

            if ( n < 0 ) y = ONE.div(y);
            return k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
        };


        /*
         * Return a string representing the value of this BigNumber rounded to sd significant digits
         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
         * necessary to represent the integer part of the value in fixed-point notation, then use
         * exponential notation.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toPrecision() precision not an integer: {sd}'
         * 'toPrecision() precision out of range: {sd}'
         * 'toPrecision() rounding mode not an integer: {rm}'
         * 'toPrecision() rounding mode out of range: {rm}'
         */
        P.toPrecision = function ( sd, rm ) {
            return format( this, sd != null && isValidInt( sd, 1, MAX, 24, 'precision' )
              ? sd | 0 : null, rm, 24 );
        };


        /*
         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
         * TO_EXP_NEG, return exponential notation.
         *
         * [b] {number} Integer, 2 to 64 inclusive.
         *
         * 'toString() base not an integer: {b}'
         * 'toString() base out of range: {b}'
         */
        P.toString = function (b) {
            var str,
                n = this,
                s = n.s,
                e = n.e;

            // Infinity or NaN?
            if ( e === null ) {

                if (s) {
                    str = 'Infinity';
                    if ( s < 0 ) str = '-' + str;
                } else {
                    str = 'NaN';
                }
            } else {
                str = coeffToString( n.c );

                if ( b == null || !isValidInt( b, 2, 64, 25, 'base' ) ) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                      ? toExponential( str, e )
                      : toFixedPoint( str, e );
                } else {
                    str = convertBase( toFixedPoint( str, e ), b | 0, 10, s );
                }

                if ( s < 0 && n.c[0] ) str = '-' + str;
            }

            return str;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber truncated to a whole
         * number.
         */
        P.truncated = P.trunc = function () {
            return round( new BigNumber(this), this.e + 1, 1 );
        };



        /*
         * Return as toString, but do not accept a base argument.
         */
        P.valueOf = P.toJSON = function () {
            return this.toString();
        };


        // Aliases for BigDecimal methods.
        //P.add = P.plus;         // P.add included above
        //P.subtract = P.minus;   // P.sub included above
        //P.multiply = P.times;   // P.mul included above
        //P.divide = P.div;
        //P.remainder = P.mod;
        //P.compareTo = P.cmp;
        //P.negate = P.neg;


        if ( configObj != null ) BigNumber.config(configObj);

        return BigNumber;
    }


    // PRIVATE HELPER FUNCTIONS


    function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
    }


    // Return a coefficient array as a string of base 10 digits.
    function coeffToString(a) {
        var s, z,
            i = 1,
            j = a.length,
            r = a[0] + '';

        for ( ; i < j; ) {
            s = a[i++] + '';
            z = LOG_BASE - s.length;
            for ( ; z--; s = '0' + s );
            r += s;
        }

        // Determine trailing zeros.
        for ( j = r.length; r.charCodeAt(--j) === 48; );
        return r.slice( 0, j + 1 || 1 );
    }


    // Compare the value of BigNumbers x and y.
    function compare( x, y ) {
        var a, b,
            xc = x.c,
            yc = y.c,
            i = x.s,
            j = y.s,
            k = x.e,
            l = y.e;

        // Either NaN?
        if ( !i || !j ) return null;

        a = xc && !xc[0];
        b = yc && !yc[0];

        // Either zero?
        if ( a || b ) return a ? b ? 0 : -j : i;

        // Signs differ?
        if ( i != j ) return i;

        a = i < 0;
        b = k == l;

        // Either Infinity?
        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;

        // Compare exponents.
        if ( !b ) return k > l ^ a ? 1 : -1;

        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;

        // Compare digit by digit.
        for ( i = 0; i < j; i++ ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;

        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    }


    /*
     * Return true if n is a valid number in range, otherwise false.
     * Use for argument validation when ERRORS is false.
     * Note: parseInt('1e+1') == 1 but parseFloat('1e+1') == 10.
     */
    function intValidatorNoErrors( n, min, max ) {
        return ( n = truncate(n) ) >= min && n <= max;
    }


    function isArray(obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
    }


    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. convertBase('255', 10, 16) returns [15, 15].
     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut( str, baseIn, baseOut ) {
        var j,
            arr = [0],
            arrL,
            i = 0,
            len = str.length;

        for ( ; i < len; ) {
            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );
            arr[ j = 0 ] += ALPHABET.indexOf( str.charAt( i++ ) );

            for ( ; j < arr.length; j++ ) {

                if ( arr[j] > baseOut - 1 ) {
                    if ( arr[j + 1] == null ) arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                }
            }
        }

        return arr.reverse();
    }


    function toExponential( str, e ) {
        return ( str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str ) +
          ( e < 0 ? 'e' : 'e+' ) + e;
    }


    function toFixedPoint( str, e ) {
        var len, z;

        // Negative exponent?
        if ( e < 0 ) {

            // Prepend zeros.
            for ( z = '0.'; ++e; z += '0' );
            str = z + str;

        // Positive exponent
        } else {
            len = str.length;

            // Append zeros.
            if ( ++e > len ) {
                for ( z = '0', e -= len; --e; z += '0' );
                str += z;
            } else if ( e < len ) {
                str = str.slice( 0, e ) + '.' + str.slice(e);
            }
        }

        return str;
    }


    function truncate(n) {
        n = parseFloat(n);
        return n < 0 ? mathceil(n) : mathfloor(n);
    }


    // EXPORT


    BigNumber = another();

    // AMD.
    if ( typeof define == 'function' && define.amd ) {
        define( function () { return BigNumber; } );

    // Node and other environments that support module.exports.
    } else if ( typeof module != 'undefined' && module.exports ) {
        module.exports = BigNumber;
        if ( !crypto ) try { crypto = require('crypto'); } catch (e) {}

    // Browser.
    } else {
        global.BigNumber = BigNumber;
    }
})(this);

},{"crypto":1}],"natspec":[function(require,module,exports){
/*
    This file is part of natspec.js.

    natspec.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    natspec.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with natspec.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file natspec.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var abi = require('./node_modules/web3/lib/solidity/abi.js'); 

/**
 * This object should be used to evaluate natspec expression
 * It has one method evaluateExpression which shoul be used
 */
var natspec = (function () {
    /**
     * Helper method
     * Should be called to copy values from object to global context
     *
     * @method copyToContext
     * @param {Object} object from which we want to copy properties
     * @param {Object} object to which we copy
     */
    var copyToContext = function (obj, context) {
        Object.keys(obj).forEach(function (key) {
            context[key] = obj[key];
        });
    }
    
    /**
     *  Should be used to generate codes, which will be evaluated
     *
     *  @method generateCode
     *  @param {Object} object from which code will be generated
     *  @return {String} javascript code which is used to initalized variables
     */
    var generateCode = function (obj) {
        return Object.keys(obj).reduce(function (acc, key) {
            return acc + "var " + key + " = context['" + key + "'];\n";
        }, "");
    };

    /**
     * Helper method
     * Should be called to get method with given name from the abi
     *
     * @method getMethodWithName
     * @param {Array} contract's abi
     * @param {String} name of the method that we are looking for
     * @return {Object} abi for method with name
     */
    var getMethodWithName = function(abi, name) {
        return abi.filter(function (method) {
            return method.name === name;
        })[0];
    };

    /**
     * Should be used to get all contract method input variables
     *
     * @method getMethodInputParams
     * @param {Object} abi for certain method
     * @param {Object} transaction object
     * @return {Object} object with all contract's method input variables
     */
    var getMethodInputParams = function (method, transaction) {
        // do it with output formatter (cause we have to decode)
        var params = abi.formatOutput(method.inputs, '0x' + transaction.params[0].data.slice(10)); 

        return method.inputs.reduce(function (acc, current, index) {
            acc[current.name] = params[index];
            return acc;
        }, {});
    };
    
    /**
     * Should be called when we want to evaluate natspec expression
     * Replaces all natspec 'subexpressions' with evaluated value
     *
     * @method mapExpressionToEvaluate
     * @param {String} expression to evaluate
     * @param {Function} callback which is called to evaluate te expression
     * @return {String} evaluated expression
     */
    var mapExpressionsToEvaluate = function (expression, cb) {
        var evaluatedExpression = "";

        // match everything in quotes
        var pattern = /\`(?:\\.|[^`\\])*\`/gim
        var match;
        var lastIndex = 0;
        try {
            while ((match = pattern.exec(expression)) !== null) {
                var startIndex = pattern.lastIndex - match[0].length;
                var toEval = match[0].slice(1, match[0].length - 1);
                evaluatedExpression += expression.slice(lastIndex, startIndex);
                var evaluatedPart = cb(toEval);
                evaluatedExpression += evaluatedPart;
                lastIndex = pattern.lastIndex;
            }
            
            evaluatedExpression += expression.slice(lastIndex);
        }
        catch (err) {
            throw new Error("Natspec evaluation failed, wrong input params");
        }
    
        return evaluatedExpression;
    };

    /** 
     * Should be called to evaluate single expression
     * Is internally using javascript's 'eval' method
     *
     * @method evaluateExpression
     * @param {String} expression which should be evaluated
     * @param {Object} [call] object containing contract abi, transaction, called method
     * @return {String} evaluated expression
     * @throws exception if method is not found or we are trying to evaluate input params that does not exists
     */
	
	var utils = require('../utils/utils');
	
    var evaluateExpression = function (expression, call) {
        //var self = this;
        var context = {};
        
        if (!!call) {
            try {
                var method = getMethodWithName(call.abi, call.method);
                var params = getMethodInputParams(method, call.transaction); 
                copyToContext(params, context);
            }
            catch (err) {
                throw new Error("Natspec evaluation failed, method does not exist");
            }
        }

        var code = generateCode(context);

        var evaluatedExpression = mapExpressionsToEvaluate(expression, function (toEval) {
            //var fn = new Function("context", "toHex", code + "return " + toEval + ";");
            //return fn(context, toHex).toString();
            var fn = new Function("context", "utils", code + "return " + toEval + ";");
            return fn(context, utils).toString();
        });

        return evaluatedExpression;
    };

    /** 
     * Safe version of evaluateExpression
     * Instead of throwing an exception it returns it as a string 
     *
     * @method evaluateExpressionSafe
     * @param {String} expression which should be evaluated
     * @param {Object} [call] object containing contract abi, transaction, called method
     * @return {String} evaluated expression
     */
    var evaluateExpressionSafe = function (expression, call) {
        try {
            return evaluateExpression(expression, call);    
        }
        catch (err) {
            return err.message;
        }
    };

    return {
        evaluateExpression: evaluateExpression,
        evaluateExpressionSafe: evaluateExpressionSafe
    };

})();

module.exports = natspec; 


},{"./node_modules/web3/lib/solidity/abi.js":2,"../utils/utils":7}]},{},[]);
  bgo.string.hdr."var natspec = require('natspec');"             !          Zgo.string."var natspec = require('natspec');"   Zgo.string."var natspec = require('natspec');" P  Dvar natspec = require('natspec');  Tgclocals·7cad11c35fe914c1ff5567188e681a41 P  P                                  Tgclocals·3ae1279d5e348d56f28cce3670b32483 P  P   
   )         )   )   )   )       "go.string.hdr."("                       go.string."("   go.string."("   (  Tgclocals·0ba8541f778fa0d9212354994a24af5b p  p   (                         	 H   	     Tgclocals·a1d155bd7945fa5b509c2735486d8a30 @  @                         Pgo.string.hdr."Invalid transaction data"                       Hgo.string."Invalid transaction data"   Hgo.string."Invalid transaction data" @  2Invalid transaction data  bgo.string.hdr."abi key does not match any method"             !          Zgo.string."abi key does not match any method"   Zgo.string."abi key does not match any method" P  Dabi key does not match any method  Tgclocals·2d441abba90d5bffc819c5be89799912        
            Tgclocals·54204102ae5f74797e57e36f7d22edb3                  Dgo.string.hdr."var transaction = "                       <go.string."var transaction = "   <go.string."var transaction = " 0  &var transaction =   "go.string.hdr.";"                       go.string.";"   go.string.";"   ;  pgo.string.hdr."natspec.js error setting transaction: %v"             (          hgo.string."natspec.js error setting transaction: %v"   hgo.string."natspec.js error setting transaction: %v" `  Rnatspec.js error setting transaction: %v  4go.string.hdr."var abi = "             
          ,go.string."var abi = "   ,go.string."var abi = "    var abi =   `go.string.hdr."natspec.js error setting abi: %v"                        Xgo.string."natspec.js error setting abi: %v"   Xgo.string."natspec.js error setting abi: %v" P  Bnatspec.js error setting abi: %v  <go.string.hdr."var method = '"                       4go.string."var method = '"   4go.string."var method = '"    var method = '  $go.string.hdr."';"                       go.string."';"   go.string."';"   ';  fgo.string.hdr."natspec.js error setting method: %v"             #          ^go.string."natspec.js error setting method: %v"   ^go.string."natspec.js error setting method: %v" P  Hnatspec.js error setting method: %v  Fgo.string.hdr."var expression = \""                       >go.string."var expression = \""   >go.string."var expression = \"" 0  &var expression = "  &go.string.hdr."\";"                       go.string."\";"   go.string."\";"   ";  ngo.string.hdr."natspec.js error setting expression: %v"             '          fgo.string."natspec.js error setting expression: %v"   fgo.string."natspec.js error setting expression: %v" P  Pnatspec.js error setting expression: %v  go.string.hdr."var call = {method: method,abi: abi,transaction: transaction};"             >          go.string."var call = {method: method,abi: abi,transaction: transaction};"   go.string."var call = {method: method,abi: abi,transaction: transaction};"   ~var call = {method: method,abi: abi,transaction: transaction};  zgo.string.hdr."natspec.evaluateExpression(expression, call);"             -          rgo.string."natspec.evaluateExpression(expression, call);"   rgo.string."natspec.evaluateExpression(expression, call);" `  \natspec.evaluateExpression(expression, call);  tgo.string.hdr."natspec.js error evaluating expression: %v"             *          lgo.string."natspec.js error evaluating expression: %v"   lgo.string."natspec.js error evaluating expression: %v" `  Vnatspec.js error evaluating expression: %v  zgo.string.hdr."Natspec evaluation failed, wrong input params"             -          rgo.string."Natspec evaluation failed, wrong input params"   rgo.string."Natspec evaluation failed, wrong input params" `  \Natspec evaluation failed, wrong input params  go.string.hdr."natspec.js error evaluating expression: wrong input params in expression '%s'"             M          go.string."natspec.js error evaluating expression: wrong input params in expression '%s'"   go.string."natspec.js error evaluating expression: wrong input params in expression '%s'"   natspec.js error evaluating expression: wrong input params in expression '%s'  lgo.string.hdr."natspec.js error evaluating expression"             &          dgo.string."natspec.js error evaluating expression"   dgo.string."natspec.js error evaluating expression" P  Nnatspec.js error evaluating expression  Tgclocals·d7e3fc7369d255717fb96672f86fbe64 P  P             0   0        0!  0   Tgclocals·667457f8ddc6c4dfd61b70c4fca21bb8 P  P      +   +   +   +   +   +   +   +    Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           0"".initdone·  type.uint8   "".GetNotice·f              "".GetNotice   ."".getFallbackNotice·f              ("".getFallbackNotice   "".New·f              "".New   4"".FetchDocsForContract·f              ."".FetchDocsForContract   """.NewWithDocs·f              "".NewWithDocs   >"".(*NatSpec).makeAbi2method·f              8"".(*NatSpec).makeAbi2method   ."".(*NatSpec).Notice·f              ("".(*NatSpec).Notice   @"".(*NatSpec).noticeForMethod·f              :"".(*NatSpec).noticeForMethod   "".init·f              "".init   "runtime.gcbits.01    .go.string.hdr."[]uint8"                       &go.string."[]uint8"   &go.string."[]uint8"   []uint8  type.[]uint8                 ~.8                                                         0  runtime.algarray   @  "runtime.gcbits.01   P  .go.string.hdr."[]uint8"   p  *go.weak.type.*[]uint8     "runtime.zerovalue     type.uint8   6go.typelink.[]uint8	[]uint8              type.[]uint8   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             0type..hashfunc."".method              (type..hash."".method   ,type..eqfunc."".method              $type..eq."".method   &type..alg."".method                        0type..hashfunc."".method     ,type..eqfunc."".method   "runtime.gcbits.05    <go.string.hdr."natspec.method"                       4go.string."natspec.method"   4go.string."natspec.method"    natspec.method  ,go.string.hdr."Notice"                       $go.string."Notice"   $go.string."Notice"   Notice  6go.string.hdr."json:notice"                       .go.string."json:notice"   .go.string."json:notice"    json:notice  (go.string.hdr."name"                        go.string."name"    go.string."name"   
name  |go.string.hdr."github.com/ethereum/go-ethereum/common/natspec"             .          tgo.string."github.com/ethereum/go-ethereum/common/natspec"   tgo.string."github.com/ethereum/go-ethereum/common/natspec" `  ^github.com/ethereum/go-ethereum/common/natspec  "go.importpath."".             .          tgo.string."github.com/ethereum/go-ethereum/common/natspec"   ,go.string.hdr."method"                       $go.string."method"   $go.string."method"   method  type."".method                   'Z                                                                                                                                                                                               0  &type..alg."".method   @  "runtime.gcbits.05   P  <go.string.hdr."natspec.method"   p  type.*"".method     "runtime.zerovalue    type."".method     ,go.string.hdr."Notice"     type.string     6go.string.hdr."json:notice"     (go.string.hdr."name"     "go.importpath."".     type.string   ` type."".method     ,go.string.hdr."method"     "go.importpath."".    type."".method   >go.string.hdr."*natspec.method"                       6go.string."*natspec.method"   6go.string."*natspec.method"     *natspec.method  type.*"".method                  +Qo 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  >go.string.hdr."*natspec.method"   p  0go.weak.type.**"".method     "runtime.zerovalue     type."".method   runtime.gcbits.      0go.string.hdr."[8]uint8"                       (go.string."[8]uint8"   (go.string."[8]uint8"    [8]uint8  type.[8]uint8                  >0                                                                        0  runtime.algarray   @  runtime.gcbits.   P  0go.string.hdr."[8]uint8"   p  ,go.weak.type.*[8]uint8     "runtime.zerovalue     type.uint8     type.[]uint8   :go.typelink.[8]uint8	[8]uint8              type.[8]uint8   0go.string.hdr."[]string"                       (go.string."[]string"   (go.string."[]string"    []string  type.[]string                 Ө
                                                         0  runtime.algarray   @  "runtime.gcbits.01   P  0go.string.hdr."[]string"   p  ,go.weak.type.*[]string     "runtime.zerovalue     type.string   :go.typelink.[]string	[]string              type.[]string   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             0type..hashfunc.[8]string              (type..hash.[8]string   ,type..eqfunc.[8]string              $type..eq.[8]string   &type..alg.[8]string                        0type..hashfunc.[8]string     ,type..eqfunc.[8]string   &runtime.gcbits.5555   UU 2go.string.hdr."[8]string"             	          *go.string."[8]string"   *go.string."[8]string"    [8]string  type.[8]string          x       US>                                                                        0  &type..alg.[8]string   @  &runtime.gcbits.5555   P  2go.string.hdr."[8]string"   p  .go.weak.type.*[8]string     "runtime.zerovalue     type.string     type.[]string   >go.typelink.[8]string	[8]string              type.[8]string   Bgo.string.hdr."[]*natspec.method"                       :go.string."[]*natspec.method"   :go.string."[]*natspec.method" 0  $[]*natspec.method  "type.[]*"".method                 $3                                                         0  runtime.algarray   @  "runtime.gcbits.01   P  Bgo.string.hdr."[]*natspec.method"   p  4go.weak.type.*[]*"".method     "runtime.zerovalue     type.*"".method   Tgo.typelink.[]*natspec.method	[]*"".method              "type.[]*"".method    type..hashfunc64             @          ,runtime.memhash_varlen   type..eqfunc64             @          .runtime.memequal_varlen   type..alg64                         type..hashfunc64     type..eqfunc64   "runtime.gcbits.ff    Dgo.string.hdr."[8]*natspec.method"                       <go.string."[8]*natspec.method"   <go.string."[8]*natspec.method" 0  &[8]*natspec.method  $type.[8]*"".method   @       @       3                                                                        0  type..alg64   @  "runtime.gcbits.ff   P  Dgo.string.hdr."[8]*natspec.method"   p  6go.weak.type.*[8]*"".method     "runtime.zerovalue     type.*"".method     "type.[]*"".method   Xgo.typelink.[8]*natspec.method	[8]*"".method              $type.[8]*"".method   dgo.string.hdr."*map.bucket[string]*natspec.method"             "          \go.string."*map.bucket[string]*natspec.method"   \go.string."*map.bucket[string]*natspec.method" P  F*map.bucket[string]*natspec.method  Dtype.*map.bucket[string]*"".method                 r 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  dgo.string.hdr."*map.bucket[string]*natspec.method"   p  Vgo.weak.type.**map.bucket[string]*"".method     "runtime.zerovalue     Btype.map.bucket[string]*"".method   .runtime.gcbits.aaaafe03    bgo.string.hdr."map.bucket[string]*natspec.method"             !          Zgo.string."map.bucket[string]*natspec.method"   Zgo.string."map.bucket[string]*natspec.method" P  Dmap.bucket[string]*natspec.method  .go.string.hdr."topbits"                       &go.string."topbits"   &go.string."topbits"   topbits  (go.string.hdr."keys"                        go.string."keys"    go.string."keys"   
keys  ,go.string.hdr."values"                       $go.string."values"   $go.string."values"   values  0go.string.hdr."overflow"                       (go.string."overflow"   (go.string."overflow"    overflow  Btype.map.bucket[string]*"".method                 eF                                                                                                                                                                                                                                    0  runtime.algarray   @  .runtime.gcbits.aaaafe03   P  bgo.string.hdr."map.bucket[string]*natspec.method"   p  Tgo.weak.type.*map.bucket[string]*"".method     "runtime.zerovalue    Btype.map.bucket[string]*"".method     .go.string.hdr."topbits"     type.[8]uint8     (go.string.hdr."keys"     type.[8]string     ,go.string.hdr."values"     $type.[8]*"".method     0go.string.hdr."overflow"     Dtype.*map.bucket[string]*"".method   "runtime.gcbits.2c   , \go.string.hdr."map.hdr[string]*natspec.method"                       Tgo.string."map.hdr[string]*natspec.method"   Tgo.string."map.hdr[string]*natspec.method" @  >map.hdr[string]*natspec.method  *go.string.hdr."count"                       "go.string."count"   "go.string."count"   count  *go.string.hdr."flags"                       "go.string."flags"   "go.string."flags"   flags  "go.string.hdr."B"                       go.string."B"   go.string."B"   B  *go.string.hdr."hash0"                       "go.string."hash0"   "go.string."hash0"   hash0  .go.string.hdr."buckets"                       &go.string."buckets"   &go.string."buckets"   buckets  4go.string.hdr."oldbuckets"             
          ,go.string."oldbuckets"   ,go.string."oldbuckets"    oldbuckets  2go.string.hdr."nevacuate"             	          *go.string."nevacuate"   *go.string."nevacuate"    nevacuate  <type.map.hdr[string]*"".method   0       0       S$                                                                                                                                                                                      	                                                                                                                                                                                                    (       ,0  runtime.algarray   @  "runtime.gcbits.2c   P  \go.string.hdr."map.hdr[string]*natspec.method"   p  Ngo.weak.type.*map.hdr[string]*"".method     "runtime.zerovalue    <type.map.hdr[string]*"".method     *go.string.hdr."count"     type.int     *go.string.hdr."flags"     type.uint8     "go.string.hdr."B"     type.uint8     *go.string.hdr."hash0"     type.uint32     .go.string.hdr."buckets"     Dtype.*map.bucket[string]*"".method     4go.string.hdr."oldbuckets"     Dtype.*map.bucket[string]*"".method     2go.string.hdr."nevacuate"     type.uintptr     0go.string.hdr."overflow"     &type.unsafe.Pointer   Tgo.string.hdr."map[string]*natspec.method"                       Lgo.string."map[string]*natspec.method"   Lgo.string."map[string]*natspec.method" @  6map[string]*natspec.method  4type.map[string]*"".method                 l 5                                                                                   0  runtime.algarray   @  "runtime.gcbits.01   P  Tgo.string.hdr."map[string]*natspec.method"   p  Fgo.weak.type.*map[string]*"".method     "runtime.zerovalue     type.string     type.*"".method     Btype.map.bucket[string]*"".method     <type.map.hdr[string]*"".method   xgo.typelink.map[string]*natspec.method	map[string]*"".method              4type.map[string]*"".method   @go.string.hdr."*natspec.userDoc"                       8go.string."*natspec.userDoc"   8go.string."*natspec.userDoc" 0  "*natspec.userDoc   type.*"".userDoc                  _V 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  @go.string.hdr."*natspec.userDoc"   p  2go.weak.type.**"".userDoc     "runtime.zerovalue     type."".userDoc   >go.string.hdr."natspec.userDoc"                       6go.string."natspec.userDoc"   6go.string."natspec.userDoc"     natspec.userDoc  .go.string.hdr."Methods"                       &go.string."Methods"   &go.string."Methods"   Methods  8go.string.hdr."json:methods"                       0go.string."json:methods"   0go.string."json:methods"    json:methods  .go.string.hdr."userDoc"                       &go.string."userDoc"   &go.string."userDoc"   userDoc  type."".userDoc                  N| 9                                                                                                                                                      0  runtime.algarray   @  "runtime.gcbits.01   P  >go.string.hdr."natspec.userDoc"   p   type.*"".userDoc     "runtime.zerovalue    type."".userDoc     .go.string.hdr."Methods"     4type.map[string]*"".method     8go.string.hdr."json:methods"   ` type."".userDoc     .go.string.hdr."userDoc"     "go.importpath."".    type."".userDoc   "runtime.gcbits.b3    >go.string.hdr."natspec.NatSpec"                       6go.string."natspec.NatSpec"   6go.string."natspec.NatSpec"     natspec.NatSpec  (go.string.hdr."jsvm"                        go.string."jsvm"    go.string."jsvm"   
jsvm  4go.string.hdr."abiDocJson"             
          ,go.string."abiDocJson"   ,go.string."abiDocJson"    abiDocJson  $go.string.hdr."tx"                       go.string."tx"   go.string."tx"   tx  (go.string.hdr."data"                        go.string."data"    go.string."data"   
data  .go.string.hdr."NatSpec"                       &go.string."NatSpec"   &go.string."NatSpec"   NatSpec  type."".NatSpec    H       @       2S                                                                                                                                                                                                                              (                                       8                                               20  runtime.algarray   @  "runtime.gcbits.b3   P  >go.string.hdr."natspec.NatSpec"   p   type.*"".NatSpec     "runtime.zerovalue    type."".NatSpec     (go.string.hdr."jsvm"     "go.importpath."".     Ntype.*github.com/robertkrimen/otto.Otto     4go.string.hdr."abiDocJson"     "go.importpath."".     type.[]uint8     .go.string.hdr."userDoc"     "go.importpath."".     type."".userDoc     $go.string.hdr."tx"     "go.importpath."".     type.string     (go.string.hdr."data"     "go.importpath."".     type.string   ` type."".NatSpec     .go.string.hdr."NatSpec"     "go.importpath."".    type."".NatSpec   @go.string.hdr."*natspec.NatSpec"                       8go.string."*natspec.NatSpec"   8go.string."*natspec.NatSpec" 0  "*natspec.NatSpec  lgo.string.hdr."func(*natspec.NatSpec) (string, error)"             &          dgo.string."func(*natspec.NatSpec) (string, error)"   dgo.string."func(*natspec.NatSpec) (string, error)" P  Nfunc(*natspec.NatSpec) (string, error)  Ltype.func(*"".NatSpec) (string, error)                 y 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  lgo.string.hdr."func(*natspec.NatSpec) (string, error)"   p  ^go.weak.type.*func(*"".NatSpec) (string, error)     "runtime.zerovalue    Ltype.func(*"".NatSpec) (string, error)    Ltype.func(*"".NatSpec) (string, error)      type.*"".NatSpec     type.string     type.error   go.typelink.func(*natspec.NatSpec) (string, error)	func(*"".NatSpec) (string, error)              Ltype.func(*"".NatSpec) (string, error)   go.string.hdr."func(*natspec.NatSpec, [8]uint8) *natspec.method"             0          xgo.string."func(*natspec.NatSpec, [8]uint8) *natspec.method"   xgo.string."func(*natspec.NatSpec, [8]uint8) *natspec.method" p  bfunc(*natspec.NatSpec, [8]uint8) *natspec.method  Vtype.func(*"".NatSpec, [8]uint8) *"".method                 XO  3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(*natspec.NatSpec, [8]uint8) *natspec.method"   p  hgo.weak.type.*func(*"".NatSpec, [8]uint8) *"".method     "runtime.zerovalue    Vtype.func(*"".NatSpec, [8]uint8) *"".method    Vtype.func(*"".NatSpec, [8]uint8) *"".method      type.*"".NatSpec     type.[8]uint8     type.*"".method   go.typelink.func(*natspec.NatSpec, [8]uint8) *natspec.method	func(*"".NatSpec, [8]uint8) *"".method              Vtype.func(*"".NatSpec, [8]uint8) *"".method   go.string.hdr."func(*natspec.NatSpec, string, string, string) (string, error)"             >          go.string."func(*natspec.NatSpec, string, string, string) (string, error)"   go.string."func(*natspec.NatSpec, string, string, string) (string, error)"   ~func(*natspec.NatSpec, string, string, string) (string, error)  |type.func(*"".NatSpec, string, string, string) (string, error)                 C 3                                                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(*natspec.NatSpec, string, string, string) (string, error)"   p  go.weak.type.*func(*"".NatSpec, string, string, string) (string, error)     "runtime.zerovalue    |type.func(*"".NatSpec, string, string, string) (string, error)    |type.func(*"".NatSpec, string, string, string) (string, error)      type.*"".NatSpec     type.string     type.string     type.string     type.string     type.error   go.typelink.func(*natspec.NatSpec, string, string, string) (string, error)	func(*"".NatSpec, string, string, string) (string, error)              |type.func(*"".NatSpec, string, string, string) (string, error)   Lgo.string.hdr."func() (string, error)"                       Dgo.string."func() (string, error)"   Dgo.string."func() (string, error)" 0  .func() (string, error)  6type.func() (string, error)                 u 3                                                                                                                      0  runtime.algarray   @  "runtime.gcbits.01   P  Lgo.string.hdr."func() (string, error)"   p  Hgo.weak.type.*func() (string, error)     "runtime.zerovalue    6type.func() (string, error)    6type.func() (string, error)     type.string     type.error   rgo.typelink.func() (string, error)	func() (string, error)              6type.func() (string, error)   <go.string.hdr."makeAbi2method"                       4go.string."makeAbi2method"   4go.string."makeAbi2method"    makeAbi2method  \go.string.hdr."func([8]uint8) *natspec.method"                       Tgo.string."func([8]uint8) *natspec.method"   Tgo.string."func([8]uint8) *natspec.method" @  >func([8]uint8) *natspec.method  <type.func([8]uint8) *"".method                 rfE 3                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  \go.string.hdr."func([8]uint8) *natspec.method"   p  Ngo.weak.type.*func([8]uint8) *"".method     "runtime.zerovalue    <type.func([8]uint8) *"".method    <type.func([8]uint8) *"".method     type.[8]uint8     type.*"".method   go.typelink.func([8]uint8) *natspec.method	func([8]uint8) *"".method              <type.func([8]uint8) *"".method   >go.string.hdr."noticeForMethod"                       6go.string."noticeForMethod"   6go.string."noticeForMethod"     noticeForMethod  xgo.string.hdr."func(string, string, string) (string, error)"             ,          pgo.string."func(string, string, string) (string, error)"   pgo.string."func(string, string, string) (string, error)" `  Zfunc(string, string, string) (string, error)  btype.func(string, string, string) (string, error)                 qoS] 3                                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  xgo.string.hdr."func(string, string, string) (string, error)"   p  tgo.weak.type.*func(string, string, string) (string, error)     "runtime.zerovalue    btype.func(string, string, string) (string, error)    btype.func(string, string, string) (string, error)     type.string     type.string     type.string     type.string     type.error   go.typelink.func(string, string, string) (string, error)	func(string, string, string) (string, error)              btype.func(string, string, string) (string, error)    type.*"".NatSpec                  Hat 6                                                                                                                                                                                                                                              20  runtime.algarray   @  "runtime.gcbits.01   P  @go.string.hdr."*natspec.NatSpec"   p  2go.weak.type.**"".NatSpec     "runtime.zerovalue     type."".NatSpec   `  type.*"".NatSpec     type.*"".NatSpec     ,go.string.hdr."Notice"     6type.func() (string, error)     Ltype.func(*"".NatSpec) (string, error)     ("".(*NatSpec).Notice     ("".(*NatSpec).Notice     <go.string.hdr."makeAbi2method"     "go.importpath."".     <type.func([8]uint8) *"".method     Vtype.func(*"".NatSpec, [8]uint8) *"".method     8"".(*NatSpec).makeAbi2method     8"".(*NatSpec).makeAbi2method     >go.string.hdr."noticeForMethod"     "go.importpath."".     btype.func(string, string, string) (string, error)     |type.func(*"".NatSpec, string, string, string) (string, error)     :"".(*NatSpec).noticeForMethod     :"".(*NatSpec).noticeForMethod   "runtime.gcbits.03    8go.string.hdr."interface {}"                       0go.string."interface {}"   0go.string."interface {}"    interface {}  "type.interface {}                 W                                                                         0  runtime.algarray   @  "runtime.gcbits.03   P  8go.string.hdr."interface {}"   p  4go.weak.type.*interface {}     "runtime.zerovalue    "type.interface {}   <go.string.hdr."[]interface {}"                       4go.string."[]interface {}"   4go.string."[]interface {}"    []interface {}  &type.[]interface {}                 p/                                                         0  runtime.algarray   @  "runtime.gcbits.01   P  <go.string.hdr."[]interface {}"   p  8go.weak.type.*[]interface {}     "runtime.zerovalue     "type.interface {}   Rgo.typelink.[]interface {}	[]interface {}              &type.[]interface {}   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             <type..hashfunc.[1]interface {}              4type..hash.[1]interface {}   8type..eqfunc.[1]interface {}              0type..eq.[1]interface {}   2type..alg.[1]interface {}                        <type..hashfunc.[1]interface {}     8type..eqfunc.[1]interface {}   >go.string.hdr."[1]interface {}"                       6go.string."[1]interface {}"   6go.string."[1]interface {}"     [1]interface {}  (type.[1]interface {}                 P[                                                                        0  2type..alg.[1]interface {}   @  "runtime.gcbits.03   P  >go.string.hdr."[1]interface {}"   p  :go.weak.type.*[1]interface {}     "runtime.zerovalue     "type.interface {}     &type.[]interface {}   Vgo.typelink.[1]interface {}	[1]interface {}              (type.[1]interface {}   @go.string.hdr."*[1]interface {}"                       8go.string."*[1]interface {}"   8go.string."*[1]interface {}" 0  "*[1]interface {}  *type.*[1]interface {}                 5 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  @go.string.hdr."*[1]interface {}"   p  <go.weak.type.**[1]interface {}     "runtime.zerovalue     (type.[1]interface {}   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             <type..hashfunc.[2]interface {}              4type..hash.[2]interface {}   8type..eqfunc.[2]interface {}              0type..eq.[2]interface {}   2type..alg.[2]interface {}                        <type..hashfunc.[2]interface {}     8type..eqfunc.[2]interface {}   "runtime.gcbits.0f    >go.string.hdr."[2]interface {}"                       6go.string."[2]interface {}"   6go.string."[2]interface {}"     [2]interface {}  (type.[2]interface {}                   ,Y                                                                        0  2type..alg.[2]interface {}   @  "runtime.gcbits.0f   P  >go.string.hdr."[2]interface {}"   p  :go.weak.type.*[2]interface {}     "runtime.zerovalue     "type.interface {}     &type.[]interface {}   Vgo.typelink.[2]interface {}	[2]interface {}              (type.[2]interface {}   @go.string.hdr."*[2]interface {}"                       8go.string."*[2]interface {}"   8go.string."*[2]interface {}" 0  "*[2]interface {}  *type.*[2]interface {}                 s-q 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  @go.string.hdr."*[2]interface {}"   p  <go.weak.type.**[2]interface {}     "runtime.zerovalue     (type.[2]interface {}   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             :type..hashfunc."".transaction              2type..hash."".transaction   6type..eqfunc."".transaction              .type..eq."".transaction   0type..alg."".transaction                        :type..hashfunc."".transaction     6type..eqfunc."".transaction   Hgo.string.hdr."*natspec.transaction"                       @go.string."*natspec.transaction"   @go.string."*natspec.transaction" 0  **natspec.transaction  (type.*"".transaction                   6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  Hgo.string.hdr."*natspec.transaction"   p  :go.weak.type.**"".transaction     "runtime.zerovalue     &type."".transaction   Fgo.string.hdr."natspec.transaction"                       >go.string."natspec.transaction"   >go.string."natspec.transaction" 0  (natspec.transaction  $go.string.hdr."To"                       go.string."To"   go.string."To"   To  6go.string.hdr."json:\"to\""             	          .go.string."json:\"to\""   .go.string."json:\"to\""    json:"to"  (go.string.hdr."Data"                        go.string."Data"    go.string."Data"   
Data  :go.string.hdr."json:\"data\""                       2go.string."json:\"data\""   2go.string."json:\"data\""    json:"data"  6go.string.hdr."transaction"                       .go.string."transaction"   .go.string."transaction"    transaction  &type."".transaction                   h                                                                                                                                                                                               0  0type..alg."".transaction   @  "runtime.gcbits.05   P  Fgo.string.hdr."natspec.transaction"   p  (type.*"".transaction     "runtime.zerovalue    &type."".transaction     $go.string.hdr."To"     type.string     6go.string.hdr."json:\"to\""     (go.string.hdr."Data"     type.string     :go.string.hdr."json:\"data\""   ` &type."".transaction     6go.string.hdr."transaction"     "go.importpath."".    &type."".transaction   Jgo.string.hdr."[]natspec.transaction"                       Bgo.string."[]natspec.transaction"   Bgo.string."[]natspec.transaction" 0  ,[]natspec.transaction  *type.[]"".transaction                 d                                                         0  runtime.algarray   @  "runtime.gcbits.01   P  Jgo.string.hdr."[]natspec.transaction"   p  <go.weak.type.*[]"".transaction     "runtime.zerovalue     &type."".transaction   dgo.typelink.[]natspec.transaction	[]"".transaction              *type.[]"".transaction   <go.string.hdr."natspec.jsonTx"                       4go.string."natspec.jsonTx"   4go.string."natspec.jsonTx"    natspec.jsonTx  ,go.string.hdr."Params"                       $go.string."Params"   $go.string."Params"   Params  >go.string.hdr."json:\"params\""                       6go.string."json:\"params\""   6go.string."json:\"params\""    json:"params"  ,go.string.hdr."jsonTx"                       $go.string."jsonTx"   $go.string."jsonTx"   jsonTx  type."".jsonTx                                                                                                                                                                         0  runtime.algarray   @  "runtime.gcbits.01   P  <go.string.hdr."natspec.jsonTx"   p  type.*"".jsonTx     "runtime.zerovalue    type."".jsonTx     ,go.string.hdr."Params"     *type.[]"".transaction     >go.string.hdr."json:\"params\""   ` type."".jsonTx     ,go.string.hdr."jsonTx"     "go.importpath."".    type."".jsonTx   >go.string.hdr."*natspec.jsonTx"                       6go.string."*natspec.jsonTx"   6go.string."*natspec.jsonTx"     *natspec.jsonTx  type.*"".jsonTx                  "7y 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  >go.string.hdr."*natspec.jsonTx"   p  0go.weak.type.**"".jsonTx     "runtime.zerovalue     type."".jsonTx   2go.string.hdr."[][]uint8"             	          *go.string."[][]uint8"   *go.string."[][]uint8"    [][]uint8  type.[][]uint8                 }                                                         0  runtime.algarray   @  "runtime.gcbits.01   P  2go.string.hdr."[][]uint8"   p  .go.weak.type.*[][]uint8     "runtime.zerovalue     type.[]uint8   >go.typelink.[][]uint8	[][]uint8              type.[][]uint8   4go.string.hdr."[1][]uint8"             
          ,go.string."[1][]uint8"   ,go.string."[1][]uint8"    [1][]uint8  type.[1][]uint8                 b                                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  4go.string.hdr."[1][]uint8"   p  0go.weak.type.*[1][]uint8     "runtime.zerovalue     type.[]uint8     type.[][]uint8   Bgo.typelink.[1][]uint8	[1][]uint8              type.[1][]uint8   6go.string.hdr."*[1][]uint8"                       .go.string."*[1][]uint8"   .go.string."*[1][]uint8"    *[1][]uint8   type.*[1][]uint8                 m7 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  6go.string.hdr."*[1][]uint8"   p  2go.weak.type.**[1][]uint8     "runtime.zerovalue     type.[1][]uint8   &runtime.gcbits.5506   U Hgo.string.hdr."natspec.contractInfo"                       @go.string."natspec.contractInfo"   @go.string."natspec.contractInfo" 0  *natspec.contractInfo  ,go.string.hdr."Source"                       $go.string."Source"   $go.string."Source"   Source  >go.string.hdr."json:\"source\""                       6go.string."json:\"source\""   6go.string."json:\"source\""    json:"source"  0go.string.hdr."Language"                       (go.string."Language"   (go.string."Language"    Language  Bgo.string.hdr."json:\"language\""                       :go.string."json:\"language\""   :go.string."json:\"language\""     json:"language"  .go.string.hdr."Version"                       &go.string."Version"   &go.string."Version"   Version  Pgo.string.hdr."json:\"compilerVersion\""                       Hgo.string."json:\"compilerVersion\""   Hgo.string."json:\"compilerVersion\"" 0  .json:"compilerVersion"  :go.string.hdr."AbiDefinition"                       2go.string."AbiDefinition"   2go.string."AbiDefinition"    AbiDefinition  Lgo.string.hdr."json:\"abiDefinition\""                       Dgo.string."json:\"abiDefinition\""   Dgo.string."json:\"abiDefinition\"" 0  *json:"abiDefinition"  .go.string.hdr."UserDoc"                       &go.string."UserDoc"   &go.string."UserDoc"   UserDoc  @go.string.hdr."json:\"userDoc\""                       8go.string."json:\"userDoc\""   8go.string."json:\"userDoc\""    json:"userDoc"  8go.string.hdr."DeveloperDoc"                       0go.string."DeveloperDoc"   0go.string."DeveloperDoc"    DeveloperDoc  Jgo.string.hdr."json:\"developerDoc\""                       Bgo.string."json:\"developerDoc\""   Bgo.string."json:\"developerDoc\"" 0  (json:"developerDoc"  8go.string.hdr."contractInfo"                       0go.string."contractInfo"   0go.string."contractInfo"    contractInfo  (type."".contractInfo    h       X       T                                                                                                                                                                                                                              0                                       H                                       P                                               80  runtime.algarray   @  &runtime.gcbits.5506   P  Hgo.string.hdr."natspec.contractInfo"   p  *type.*"".contractInfo     "runtime.zerovalue    (type."".contractInfo     ,go.string.hdr."Source"     type.string     >go.string.hdr."json:\"source\""     0go.string.hdr."Language"     type.string     Bgo.string.hdr."json:\"language\""     .go.string.hdr."Version"     type.string     Pgo.string.hdr."json:\"compilerVersion\""     :go.string.hdr."AbiDefinition"     :type.encoding/json.RawMessage     Lgo.string.hdr."json:\"abiDefinition\""     .go.string.hdr."UserDoc"     type."".userDoc     @go.string.hdr."json:\"userDoc\""     8go.string.hdr."DeveloperDoc"     :type.encoding/json.RawMessage     Jgo.string.hdr."json:\"developerDoc\""   ` (type."".contractInfo     8go.string.hdr."contractInfo"     "go.importpath."".    (type."".contractInfo   Jgo.string.hdr."*natspec.contractInfo"                       Bgo.string."*natspec.contractInfo"   Bgo.string."*natspec.contractInfo" 0  ,*natspec.contractInfo  *type.*"".contractInfo                  }2` 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  Jgo.string.hdr."*natspec.contractInfo"   p  <go.weak.type.**"".contractInfo     "runtime.zerovalue     (type."".contractInfo   @go.string.hdr."**natspec.method"                       8go.string."**natspec.method"   8go.string."**natspec.method" 0  "**natspec.method   type.**"".method                 ?k 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  @go.string.hdr."**natspec.method"   p  2go.weak.type.***"".method     "runtime.zerovalue     type.*"".method   ^go.string.hdr."*map.hdr[string]*natspec.method"                       Vgo.string."*map.hdr[string]*natspec.method"   Vgo.string."*map.hdr[string]*natspec.method" @  @*map.hdr[string]*natspec.method  >type.*map.hdr[string]*"".method                 F>) 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  ^go.string.hdr."*map.hdr[string]*natspec.method"   p  Pgo.weak.type.**map.hdr[string]*"".method     "runtime.zerovalue     <type.map.hdr[string]*"".method   ^go.string.hdr."map.iter[string]*natspec.method"                       Vgo.string."map.iter[string]*natspec.method"   Vgo.string."map.iter[string]*natspec.method" @  @map.iter[string]*natspec.method  &go.string.hdr."key"                       go.string."key"   go.string."key"   key  &go.string.hdr."val"                       go.string."val"   go.string."val"   val  "go.string.hdr."t"                       go.string."t"   go.string."t"   t  "go.string.hdr."h"                       go.string."h"   go.string."h"   h  (go.string.hdr."bptr"                        go.string."bptr"    go.string."bptr"   
bptr  2go.string.hdr."overflow0"             	          *go.string."overflow0"   *go.string."overflow0"    overflow0  2go.string.hdr."overflow1"             	          *go.string."overflow1"   *go.string."overflow1"    overflow1  6go.string.hdr."startBucket"                       .go.string."startBucket"   .go.string."startBucket"    startBucket  *go.string.hdr."stuff"                       "go.string."stuff"   "go.string."stuff"   stuff  ,go.string.hdr."bucket"                       $go.string."bucket"   $go.string."bucket"   bucket  6go.string.hdr."checkBucket"                       .go.string."checkBucket"   .go.string."checkBucket"    checkBucket  >type.map.iter[string]*"".method 	  	`       @       EP                                                                                                                                                                                                                                                                                                            (                                       0                                       8                                       @                                       H                                       P                                       X       <0  runtime.algarray   @  "runtime.gcbits.ff   P  ^go.string.hdr."map.iter[string]*natspec.method"   p  Pgo.weak.type.*map.iter[string]*"".method     "runtime.zerovalue    >type.map.iter[string]*"".method     &go.string.hdr."key"     type.*string     &go.string.hdr."val"      type.**"".method     "go.string.hdr."t"     type.*uint8     "go.string.hdr."h"     >type.*map.hdr[string]*"".method     .go.string.hdr."buckets"     Dtype.*map.bucket[string]*"".method     (go.string.hdr."bptr"     Dtype.*map.bucket[string]*"".method     2go.string.hdr."overflow0"     &type.unsafe.Pointer     2go.string.hdr."overflow1"     &type.unsafe.Pointer     6go.string.hdr."startBucket"     type.uintptr     *go.string.hdr."stuff"     type.uintptr     ,go.string.hdr."bucket"     type.uintptr     6go.string.hdr."checkBucket"     type.uintptr    type..hashfunc32                        ,runtime.memhash_varlen   type..eqfunc32                        .runtime.memequal_varlen   type..alg32                         type..hashfunc32     type..eqfunc32   2go.string.hdr."[32]uint8"             	          *go.string."[32]uint8"   *go.string."[32]uint8"    [32]uint8  type.[32]uint8                   Y                                                                         0  type..alg32   @  runtime.gcbits.   P  2go.string.hdr."[32]uint8"   p  .go.weak.type.*[32]uint8     "runtime.zerovalue     type.uint8     type.[]uint8   >go.typelink.[32]uint8	[32]uint8              type.[32]uint8   4go.string.hdr."[][8]uint8"             
          ,go.string."[][8]uint8"   ,go.string."[][8]uint8"    [][8]uint8  type.[][8]uint8                 ,                                                         0  runtime.algarray   @  "runtime.gcbits.01   P  4go.string.hdr."[][8]uint8"   p  0go.weak.type.*[][8]uint8     "runtime.zerovalue     type.[8]uint8   Bgo.typelink.[][8]uint8	[][8]uint8              type.[][8]uint8   6go.string.hdr."[8][8]uint8"                       .go.string."[8][8]uint8"   .go.string."[8][8]uint8"    [8][8]uint8   type.[8][8]uint8   @               \                                                                        0  type..alg64   @  runtime.gcbits.   P  6go.string.hdr."[8][8]uint8"   p  2go.weak.type.*[8][8]uint8     "runtime.zerovalue     type.[8]uint8     type.[][8]uint8   Fgo.typelink.[8][8]uint8	[8][8]uint8               type.[8][8]uint8   hgo.string.hdr."*map.bucket[[8]uint8]*natspec.method"             $          `go.string."*map.bucket[[8]uint8]*natspec.method"   `go.string."*map.bucket[[8]uint8]*natspec.method" P  J*map.bucket[[8]uint8]*natspec.method  Htype.*map.bucket[[8]uint8]*"".method                 L 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  hgo.string.hdr."*map.bucket[[8]uint8]*natspec.method"   p  Zgo.weak.type.**map.bucket[[8]uint8]*"".method     "runtime.zerovalue     Ftype.map.bucket[[8]uint8]*"".method   *runtime.gcbits.00fe03     fgo.string.hdr."map.bucket[[8]uint8]*natspec.method"             #          ^go.string."map.bucket[[8]uint8]*natspec.method"   ^go.string."map.bucket[[8]uint8]*natspec.method" P  Hmap.bucket[[8]uint8]*natspec.method  Ftype.map.bucket[[8]uint8]*"".method                 tc                                                                                                                                                                                      H                                              0  runtime.algarray   @  *runtime.gcbits.00fe03   P  fgo.string.hdr."map.bucket[[8]uint8]*natspec.method"   p  Xgo.weak.type.*map.bucket[[8]uint8]*"".method     "runtime.zerovalue    Ftype.map.bucket[[8]uint8]*"".method     .go.string.hdr."topbits"     type.[8]uint8     (go.string.hdr."keys"      type.[8][8]uint8     ,go.string.hdr."values"     $type.[8]*"".method     0go.string.hdr."overflow"     Htype.*map.bucket[[8]uint8]*"".method   `go.string.hdr."map.hdr[[8]uint8]*natspec.method"                        Xgo.string."map.hdr[[8]uint8]*natspec.method"   Xgo.string."map.hdr[[8]uint8]*natspec.method" P  Bmap.hdr[[8]uint8]*natspec.method  @type.map.hdr[[8]uint8]*"".method   0       0       ?                                                                                                                                                                                      	                                                                                                                                                                                                    (       ,0  runtime.algarray   @  "runtime.gcbits.2c   P  `go.string.hdr."map.hdr[[8]uint8]*natspec.method"   p  Rgo.weak.type.*map.hdr[[8]uint8]*"".method     "runtime.zerovalue    @type.map.hdr[[8]uint8]*"".method     *go.string.hdr."count"     type.int     *go.string.hdr."flags"     type.uint8     "go.string.hdr."B"     type.uint8     *go.string.hdr."hash0"     type.uint32     .go.string.hdr."buckets"     Htype.*map.bucket[[8]uint8]*"".method     4go.string.hdr."oldbuckets"     Htype.*map.bucket[[8]uint8]*"".method     2go.string.hdr."nevacuate"     type.uintptr     0go.string.hdr."overflow"     &type.unsafe.Pointer   Fgo.string.hdr."*natspec.abi2method"                       >go.string."*natspec.abi2method"   >go.string."*natspec.abi2method" 0  (*natspec.abi2method  &type.*"".abi2method                  ' 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  Fgo.string.hdr."*natspec.abi2method"   p  8go.weak.type.**"".abi2method     "runtime.zerovalue     $type."".abi2method   Dgo.string.hdr."natspec.abi2method"                       <go.string."natspec.abi2method"   <go.string."natspec.abi2method" 0  &natspec.abi2method  4go.string.hdr."abi2method"             
          ,go.string."abi2method"   ,go.string."abi2method"    abi2method  $type."".abi2method                   5                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  Dgo.string.hdr."natspec.abi2method"   p  &type.*"".abi2method     "runtime.zerovalue     type.[8]uint8     type.*"".method     Ftype.map.bucket[[8]uint8]*"".method     @type.map.hdr[[8]uint8]*"".method   ` $type."".abi2method     4go.string.hdr."abi2method"     "go.importpath."".    $type."".abi2method   4go.string.hdr."*[8]string"             
          ,go.string."*[8]string"   ,go.string."*[8]string"    *[8]string  type.*[8]string                 o 6                                                        0  runtime.algarray   @  "runtime.gcbits.01   P  4go.string.hdr."*[8]string"   p  0go.weak.type.**[8]string     "runtime.zerovalue     type.[8]string   .go.string.hdr."runtime"                       &go.string."runtime"   &go.string."runtime"   runtime  ,go.importpath.runtime.                       &go.string."runtime"   *go.string.hdr."bytes"                       "go.string."bytes"   "go.string."bytes"   bytes  (go.importpath.bytes.                       "go.string."bytes"   :go.string.hdr."encoding/json"                       2go.string."encoding/json"   2go.string."encoding/json"    encoding/json  8go.importpath.encoding/json.                       2go.string."encoding/json"   &go.string.hdr."fmt"                       go.string."fmt"   go.string."fmt"   fmt  $go.importpath.fmt.                       go.string."fmt"   .go.string.hdr."strings"                       &go.string."strings"   &go.string."strings"   strings  ,go.importpath.strings.                       &go.string."strings"   lgo.string.hdr."github.com/ethereum/go-ethereum/common"             &          dgo.string."github.com/ethereum/go-ethereum/common"   dgo.string."github.com/ethereum/go-ethereum/common" P  Ngithub.com/ethereum/go-ethereum/common  jgo.importpath.github.com/ethereum/go-ethereum/common.             &          dgo.string."github.com/ethereum/go-ethereum/common"   go.string.hdr."github.com/ethereum/go-ethereum/common/httpclient"             1          zgo.string."github.com/ethereum/go-ethereum/common/httpclient"   zgo.string."github.com/ethereum/go-ethereum/common/httpclient" p  dgithub.com/ethereum/go-ethereum/common/httpclient  go.importpath.github.com/ethereum/go-ethereum/common/httpclient.             1          zgo.string."github.com/ethereum/go-ethereum/common/httpclient"   lgo.string.hdr."github.com/ethereum/go-ethereum/crypto"             &          dgo.string."github.com/ethereum/go-ethereum/crypto"   dgo.string."github.com/ethereum/go-ethereum/crypto" P  Ngithub.com/ethereum/go-ethereum/crypto  jgo.importpath.github.com/ethereum/go-ethereum/crypto.             &          dgo.string."github.com/ethereum/go-ethereum/crypto"   go.string.hdr."github.com/ethereum/go-ethereum/common/registrar"             0          xgo.string."github.com/ethereum/go-ethereum/common/registrar"   xgo.string."github.com/ethereum/go-ethereum/common/registrar" p  bgithub.com/ethereum/go-ethereum/common/registrar  ~go.importpath.github.com/ethereum/go-ethereum/common/registrar.             0          xgo.string."github.com/ethereum/go-ethereum/common/registrar"   hgo.string.hdr."github.com/ethereum/go-ethereum/xeth"             $          `go.string."github.com/ethereum/go-ethereum/xeth"   `go.string."github.com/ethereum/go-ethereum/xeth" P  Jgithub.com/ethereum/go-ethereum/xeth  fgo.importpath.github.com/ethereum/go-ethereum/xeth.             $          `go.string."github.com/ethereum/go-ethereum/xeth"   Xgo.string.hdr."github.com/robertkrimen/otto"                       Pgo.string."github.com/robertkrimen/otto"   Pgo.string."github.com/robertkrimen/otto" @  :github.com/robertkrimen/otto  Vgo.importpath.github.com/robertkrimen/otto.                       Pgo.string."github.com/robertkrimen/otto"   .type..hash."".method·f              (type..hash."".method   *type..eq."".method·f              $type..eq."".method   .type..hash.[8]string·f              (type..hash.[8]string   *type..eq.[8]string·f              $type..eq.[8]string   :type..hash.[1]interface {}·f              4type..hash.[1]interface {}   6type..eq.[1]interface {}·f              0type..eq.[1]interface {}   :type..hash.[2]interface {}·f              4type..hash.[2]interface {}   6type..eq.[2]interface {}·f              0type..eq.[2]interface {}   8type..hash."".transaction·f              2type..hash."".transaction   4type..eq."".transaction·f              .type..eq."".transaction   "runtime.zerovalue      go13ld 